<!DOCTYPE html>
<!-- Crafted by Jared Sanford (Slighty.Toasted) with love. -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>WebOS • Browser Operating System</title>
    <meta name="theme-color" content="#111426">
    <link rel="manifest" href="./manifest.json">
    <style>
        :root {
            color-scheme: dark;
            --background-desktop: radial-gradient(circle at 20% 18%, rgba(73, 92, 142, 0.35), transparent 58%),
                                   radial-gradient(circle at 82% 80%, rgba(34, 44, 88, 0.5), transparent 60%),
                                   #070c1a;
            --panel: rgba(22, 28, 46, 0.8);
            --panel-strong: rgba(14, 18, 30, 0.92);
            --border-soft: 1px solid rgba(255, 255, 255, 0.08);
            --border-strong: 1px solid rgba(255, 255, 255, 0.16);
            --shadow: 0 20px 48px rgba(4, 8, 20, 0.55);
            --shadow-soft: 0 14px 32px rgba(4, 8, 20, 0.35);
            --accent: #0a84ff;
            --accent-strong: #4aa3ff;
            --accent-gradient: linear-gradient(135deg, #0a84ff 0%, #4aa3ff 100%);
            --danger: #ff6058;
            --warning: #ffbd2e;
            --success: #28c941;
            --text-primary: #f4f7ff;
            --text-muted: rgba(200, 210, 240, 0.6);
            --taskbar-height: 76px;
            --base-font-size: 14px;
            --desktop-column-width: 260px;
            --desktop-stack-gap: 18px;
            --desktop-icon-size: 60px;
            --wallpaper-blur: 0px;
            --wallpaper-brightness: 1;
            --wallpaper-opacity: 1;
            --dock-icon-size: 56px;
        }

        [data-theme="light"] {
            color-scheme: light;
            --background-desktop: radial-gradient(circle at 28% 18%, rgba(255, 255, 255, 0.75), transparent 55%),
                                   radial-gradient(circle at 80% 82%, rgba(209, 225, 255, 0.85), transparent 60%),
                                   #e7ebf8;
            --panel: rgba(255, 255, 255, 0.72);
            --panel-strong: rgba(255, 255, 255, 0.9);
            --border-soft: 1px solid rgba(26, 36, 78, 0.12);
            --border-strong: 1px solid rgba(26, 36, 78, 0.18);
            --shadow: 0 24px 60px rgba(18, 31, 68, 0.18);
            --shadow-soft: 0 16px 36px rgba(18, 31, 68, 0.14);
            --text-primary: #1d2336;
            --text-muted: rgba(29, 35, 54, 0.54);
        }

        body[data-wallpaper="aurora"] {
            --background-desktop: radial-gradient(circle at 18% 16%, rgba(74, 104, 172, 0.45), transparent 55%),
                                   radial-gradient(circle at 82% 84%, rgba(56, 90, 160, 0.52), transparent 60%),
                                   #080d1d;
        }
        body[data-wallpaper="nebula"] {
            --background-desktop: radial-gradient(circle at 25% 78%, rgba(138, 78, 150, 0.45), transparent 58%),
                                   radial-gradient(circle at 78% 24%, rgba(64, 94, 168, 0.5), transparent 60%),
                                   #0b0f26;
        }
        body[data-wallpaper="sunset"] {
            --background-desktop: radial-gradient(circle at 42% 0%, rgba(166, 82, 106, 0.45), transparent 55%),
                                   radial-gradient(circle at 80% 88%, rgba(255, 134, 98, 0.42), transparent 60%),
                                   #120c1c;
        }
        body[data-wallpaper="minimal"] {
            --background-desktop: linear-gradient(135deg, #080c16 0%, #121a2a 100%);
        }
        body[data-wallpaper="galaxy"] {
            --background-desktop: radial-gradient(circle at 48% 52%, rgba(125, 110, 255, 0.1), transparent 62%),
                                   radial-gradient(circle at 18% 22%, rgba(255, 142, 226, 0.18), transparent 58%),
                                   radial-gradient(circle at 78% 78%, rgba(76, 158, 255, 0.16), transparent 60%),
                                   #030312;
        }
        body[data-wallpaper="galaxy"] #desktop-bg {
            mix-blend-mode: screen;
            opacity: 0.92;
        }

        body[data-taskbar="top"] #taskbar {
            top: 64px;
            bottom: auto;
        }
        body[data-taskbar="top"] #desktop {
            padding-top: calc(var(--taskbar-height) + 96px);
            padding-bottom: 48px;
        }

        body[data-particles="off"] #desktop-bg {
            opacity: 0;
        }

        #wallpaper-layer {
            position: fixed;
            inset: 0;
            z-index: -2;
            background: var(--background-desktop);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            filter: blur(var(--wallpaper-blur, 0px)) brightness(var(--wallpaper-brightness, 1));
            opacity: var(--wallpaper-opacity, 1);
            transition: filter 0.4s ease, opacity 0.4s ease, background-image 0.4s ease;
        }

        body[data-wallpaper="custom"] #wallpaper-layer {
            background: var(--wallpaper-image, #000) center/cover no-repeat fixed;
        }

        *, *::before, *::after { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; height: 100%; }
        body {
            font-family: "SF Pro Text", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: var(--background-desktop);
            color: var(--text-primary);
            overflow: hidden;
            font-size: var(--base-font-size);
            user-select: none;
            letter-spacing: -0.01em;
        }

        /* Clean desktop: hide all desktop icons (apps and files) */
        #desktop-apps,
        #desktop-files {
            display: none !important;
        }

        button, input, select, textarea { font-family: inherit; }

        #desktop-bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        #menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 18px;
            backdrop-filter: blur(24px);
            background: rgba(255, 255, 255, 0.6);
            border-bottom: var(--border-soft);
            z-index: 1200;
            color: var(--text-primary);
        }

        [data-theme="dark"] #menu-bar {
            background: rgba(16, 20, 32, 0.72);
        }

        .menu-left,
        .menu-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #menu-items {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        #menu-apple {
            font-size: 1.2rem;
            border: none;
            background: transparent;
            color: inherit;
            cursor: pointer;
            padding: 4px 6px;
        }

        #menu-items button {
            border: none;
            background: transparent;
            color: inherit;
            font-size: 0.78rem;
            padding: 4px 6px;
            border-radius: 6px;
            cursor: pointer;
        }

        #menu-items button:hover,
        #menu-items button:focus-visible {
            background: rgba(255, 255, 255, 0.32);
            outline: none;
        }

        [data-theme="dark"] #menu-items button:hover,
        [data-theme="dark"] #menu-items button:focus-visible {
            background: rgba(255, 255, 255, 0.18);
        }

        .menu-center {
            font-size: 0.75rem;
            color: var(--text-muted);
            pointer-events: none;
        }

        .menu-right button {
            border: none;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            width: 30px;
            height: 30px;
            display: grid;
            place-items: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: var(--text-primary);
        }

        [data-theme="dark"] .menu-right button {
            background: rgba(30, 36, 52, 0.6);
            color: #f6f7ff;
        }

        .menu-right button:hover {
            filter: brightness(1.05);
        }

        #tray-clock {
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        .menu-dropdown {
            position: fixed;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 12px;
            border: 1px solid rgba(182, 194, 221, 0.45);
            box-shadow: 0 18px 34px rgba(26, 32, 68, 0.2);
            backdrop-filter: blur(22px);
            padding: 6px;
            display: none;
            flex-direction: column;
            z-index: 2000;
        }

        [data-theme="dark"] .menu-dropdown {
            background: rgba(22, 28, 46, 0.9);
            border: 1px solid rgba(90, 110, 160, 0.35);
            box-shadow: var(--shadow);
        }

        .menu-dropdown[aria-hidden="false"] {
            display: flex;
            animation: menu-in 0.16s ease;
        }

        .menu-dropdown button {
            border: none;
            background: transparent;
            color: inherit;
            font-size: 0.82rem;
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .menu-dropdown button:hover,
        .menu-dropdown button:focus-visible {
            background: rgba(10, 132, 255, 0.12);
            outline: none;
        }

        .menu-dropdown button[disabled] {
            opacity: 0.4;
            cursor: default;
        }

        .menu-dropdown .menu-shortcut {
            margin-left: 18px;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .menu-separator {
            height: 1px;
            background: rgba(120, 130, 150, 0.22);
            margin: 5px 2px;
        }

        #desktop {
            position: relative;
            z-index: 1;
            height: 100%;
            padding: 80px 48px calc(var(--taskbar-height) + 96px);
            display: flex;
            overflow: hidden;
        }

        #desktop-canvas {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 32px;
        }

        #desktop-apps {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 18px;
            align-content: flex-start;
        }

        #desktop-files {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 16px;
            align-content: flex-start;
        }

        .desktop-icon {
            display: flex;
            align-items: center;
            gap: 14px;
            border-radius: 18px;
            padding: 12px 14px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(182, 194, 221, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        [data-theme="dark"] .desktop-icon {
            background: rgba(24, 30, 48, 0.72);
            border: 1px solid rgba(110, 120, 150, 0.3);
        }

        .desktop-icon:hover { transform: translateY(-3px); box-shadow: 0 12px 28px rgba(26, 32, 68, 0.18); }
        .desktop-icon.active { box-shadow: 0 16px 30px rgba(26, 32, 68, 0.26); }
        .desktop-icon.pinned { box-shadow: 0 18px 36px rgba(10, 132, 255, 0.18); }

        .desktop-icon .glyph {
            width: var(--desktop-icon-size);
            height: var(--desktop-icon-size);
            border-radius: 18px;
            display: grid;
            place-items: center;
            font-size: calc(var(--desktop-icon-size) * 0.48);
            background: var(--accent-gradient);
            box-shadow: 0 14px 24px rgba(88, 110, 255, 0.28);
        }

        .desktop-icon .icon-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .desktop-icon .icon-label strong { font-weight: 600; font-size: 0.92rem; }
        .desktop-icon .icon-label span { font-size: 0.78rem; color: var(--text-muted); }

        .desktop-file {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px 14px;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.72);
            border: 1px solid rgba(190, 200, 226, 0.45);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        [data-theme="dark"] .desktop-file {
            background: rgba(22, 28, 46, 0.75);
            border: 1px solid rgba(110, 120, 150, 0.32);
        }

        .desktop-file:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 28px rgba(26, 32, 68, 0.18);
        }

        .desktop-file.active {
            box-shadow: 0 18px 32px rgba(26, 32, 68, 0.22);
            border: 1px solid rgba(10, 132, 255, 0.45);
        }

        .desktop-file .file-glyph {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.75);
            font-size: 1.1rem;
        }

        [data-theme="dark"] .desktop-file .file-glyph {
            background: rgba(34, 40, 64, 0.82);
        }

        .desktop-file .file-info { display: flex; flex-direction: column; gap: 2px; }
        .desktop-file .file-info strong { font-size: 0.9rem; }
        .desktop-file .file-info span { font-size: 0.75rem; color: var(--text-muted); }

        .desktop-file.empty {
            opacity: 0.7;
            border-style: dashed;
            background: rgba(255,255,255,0.55);
        }

        [data-theme="dark"] .desktop-file.empty {
            background: rgba(34, 40, 64, 0.55);
        }

        #window-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .window {
            position: absolute;
            min-width: 320px;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            border-radius: 20px;
            border: var(--border-soft);
            background: rgba(255, 255, 255, 0.88);
            box-shadow: var(--shadow);
            overflow: hidden;
            pointer-events: auto;
            animation: window-in 0.25s ease;
        }

        [data-theme="dark"] .window {
            background: rgba(18, 22, 34, 0.92);
        }

        @keyframes window-in {
            from { opacity: 0; transform: translateY(18px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .window-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.65);
            border-bottom: var(--border-soft);
            cursor: grab;
        }

        [data-theme="dark"] .window-header {
            background: rgba(30, 36, 52, 0.7);
        }
        .window-header:active { cursor: grabbing; }
        .window-controls {
            display: flex;
            gap: 8px;
        }

        .window-header-filler {
            width: 70px;
        }

        .window-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: box-shadow 0.2s ease;
        }

        .window-control[data-role="close"] { background: #ff6058; }
        .window-control[data-role="minimize"] { background: #ffbd2e; }
        .window-control[data-role="maximize"] { background: #28c941; }
        .window-control:hover { box-shadow: 0 0 0 4px rgba(0,0,0,0.08); }

        .window-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-muted);
            flex: 1;
            justify-content: center;
            pointer-events: none;
        }

        .window-title .glyph {
            background: transparent;
            box-shadow: none;
            font-size: 1rem;
        }

        .window-title span:last-child {
            color: var(--text-primary);
        }

        .window-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.65);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        [data-theme="dark"] .window-content {
            background: rgba(12, 16, 28, 0.75);
        }
        .window-footer { border-top: var(--border-soft); padding: 8px 12px; font-size: 0.76rem; color: var(--text-muted); }

        .resize-handle { position: absolute; background: transparent; }
        .resize-handle[data-dir="n"], .resize-handle[data-dir="s"] { left: 8px; right: 8px; height: 10px; cursor: ns-resize; }
        .resize-handle[data-dir="e"], .resize-handle[data-dir="w"] { top: 8px; bottom: 8px; width: 10px; cursor: ew-resize; }
        .resize-handle[data-dir="n"] { top: -5px; }
        .resize-handle[data-dir="s"] { bottom: -5px; }
        .resize-handle[data-dir="e"] { right: -5px; }
        .resize-handle[data-dir="w"] { left: -5px; }
        .resize-handle[data-dir="ne"], .resize-handle[data-dir="nw"], .resize-handle[data-dir="se"], .resize-handle[data-dir="sw"] {
            width: 14px; height: 14px;
        }
        .resize-handle[data-dir="ne"] { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle[data-dir="nw"] { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle[data-dir="se"] { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .resize-handle[data-dir="sw"] { bottom: -6px; left: -6px; cursor: nesw-resize; }

        #taskbar {
            position: fixed;
            left: 50%;
            bottom: 26px;
            transform: translate(-50%, var(--taskbar-offset, 0));
            height: var(--taskbar-height);
            min-width: 360px;
            width: min(88vw, 1080px);
            border-radius: 34px;
            background: rgba(255, 255, 255, 0.62);
            border: 1px solid rgba(182, 194, 221, 0.45);
            backdrop-filter: blur(32px) saturate(140%);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 20px;
            gap: 20px;
            box-shadow: 0 18px 36px rgba(26, 32, 68, 0.18);
            z-index: 1200;
            opacity: 1;
            transition: transform 0.32s ease, opacity 0.24s ease;
        }

        [data-theme="dark"] #taskbar {
            background: rgba(22, 28, 46, 0.78);
            border: 1px solid rgba(110, 120, 150, 0.34);
            box-shadow: var(--shadow);
        }
        body[data-dock-autohide="on"] #taskbar {
            pointer-events: none;
            opacity: 0;
            --taskbar-offset: calc(100% + 48px);
        }

        body[data-dock-autohide="on"] #taskbar.dock-visible {
            pointer-events: auto;
            opacity: 1;
            --taskbar-offset: 0;
        }

        #start-button {
            width: 58px;
            height: 58px;
            border-radius: 20px;
            border: none;
            background: rgba(255, 255, 255, 0.85);
            color: var(--text-primary);
            font-size: 1.35rem;
            display: grid;
            place-items: center;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.75);
            cursor: pointer;
            transition: transform 0.18s ease, filter 0.2s ease;
        }

        [data-theme="dark"] #start-button {
            background: rgba(34, 40, 64, 0.9);
            color: #f5f7ff;
        }

        #start-button:hover { filter: brightness(1.08); }
        #start-button:active { transform: scale(0.95); }

        #taskbar-apps {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
        }

        #dock {
            display: flex;
            align-items: flex-end;
            gap: 18px;
            flex: 1 1 auto;
            justify-content: center;
            flex-wrap: wrap;
        }

        #taskbar-apps {
            display: flex;
            align-items: center;
            gap: 16px;
            overflow: visible;
            min-width: 180px;
            justify-content: flex-end;
        }

        #taskbar-apps::-webkit-scrollbar { display: none; }

        .taskbar-item {
            position: relative;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            color: inherit;
            transition: transform 0.22s ease;
        }

        .taskbar-item:hover,
        .taskbar-item.active {
            transform: translateY(-6px);
        }

        .taskbar-item .glyph {
            width: 54px;
            height: 54px;
            border-radius: 16px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.75);
            box-shadow: 0 12px 24px rgba(26, 32, 68, 0.18);
            font-size: 1.35rem;
        }

        [data-theme="dark"] .taskbar-item .glyph {
            background: rgba(34, 40, 64, 0.82);
            box-shadow: 0 12px 28px rgba(6, 10, 24, 0.45);
        }

        .taskbar-item span:last-child {
            display: none;
        }

        .dock-item {
            position: relative;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: inherit;
            transition: transform 0.2s ease, filter 0.2s ease;
        }

        .dock-item .glyph {
            width: var(--dock-icon-size, 56px);
            height: var(--dock-icon-size, 56px);
            border-radius: 18px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 16px 32px rgba(26, 32, 68, 0.24);
            font-size: calc(var(--dock-icon-size, 56px) * 0.28);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        [data-theme="dark"] .dock-item .glyph {
            background: rgba(34, 40, 64, 0.88);
            box-shadow: 0 18px 28px rgba(6, 10, 24, 0.42);
        }

        .dock-item::after {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .dock-item.running::after {
            opacity: 1;
            transform: translateY(2px);
        }

        .dock-item:hover {
            transform: translateY(-8px) scale(1.05);
        }

        .dock-item.active {
            transform: translateY(-10px) scale(1.08);
        }

        .dock-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dock-group + .dock-group {
            margin-left: 18px;
        }

        .dock-group-label {
            font-size: 0.7rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .dock-group-items {
            display: flex;
            align-items: flex-end;
            gap: 16px;
        }

        #start-menu {
            position: fixed;
            left: 50%;
            bottom: calc(var(--taskbar-height) + 32px);
            transform: translate(-50%, 10%) scale(0.92);
            width: min(760px, 92vw);
            border-radius: 26px;
            background: rgba(255, 255, 255, 0.88);
            border: 1px solid rgba(182, 194, 221, 0.45);
            box-shadow: 0 30px 58px rgba(26, 32, 68, 0.26);
            backdrop-filter: blur(30px) saturate(140%);
            display: none;
            flex-direction: column;
            max-height: min(72vh, 640px);
            z-index: 1500;
        }

        [data-theme="dark"] #start-menu {
            background: rgba(18, 22, 34, 0.95);
            border: 1px solid rgba(90, 110, 160, 0.4);
            box-shadow: var(--shadow);
        }

        #start-menu[aria-hidden="false"] {
            display: flex;
            animation: start-menu-in 0.24s ease;
            transform: translate(-50%, 0) scale(1);
        }

        @keyframes start-menu-in {
            from {
                opacity: 0;
                transform: translate(-50%, 12%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0) scale(1);
            }
        }

        .start-menu-header {
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 24px 28px 0;
        }

        .start-menu-title {
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-muted);
        }

        .start-menu-title .glyph {
            width: 42px;
            height: 42px;
            border-radius: 14px;
            display: grid;
            place-items: center;
            font-size: 1.3rem;
            background: rgba(10, 132, 255, 0.12);
        }

        .start-menu-heading-text {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .start-menu-heading-text strong {
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        #start-menu-app-count {
            font-size: 0.78rem;
            color: var(--text-muted);
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }

        .start-menu-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #start-menu-search {
            flex: 1;
            border: 1px solid rgba(180, 190, 220, 0.45);
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            color: inherit;
        }

        [data-theme="dark"] #start-menu-search {
            background: rgba(30, 38, 62, 0.8);
            border: 1px solid rgba(90, 110, 160, 0.45);
        }

        #start-menu-add-category,
        #start-menu-manage-categories {
            border: none;
            border-radius: 14px;
            background: rgba(255,255,255,0.7);
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.9rem;
            color: inherit;
            transition: filter 0.15s ease;
        }

        [data-theme="dark"] #start-menu-add-category,
        [data-theme="dark"] #start-menu-manage-categories {
            background: rgba(34, 42, 68, 0.8);
        }

        #start-menu-add-category:hover,
        #start-menu-manage-categories:hover {
            filter: brightness(1.08);
        }

        .start-menu-body {
            padding: 20px 28px;
            flex: 1 1 auto;
            overflow-y: auto;
            min-height: 0;
        }

        .start-menu-categories {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding-right: 6px;
        }

        .start-menu-suggestions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .start-menu-suggestions.hidden { display: none; }

        .suggestion-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.6);
            border: var(--border-soft);
            backdrop-filter: blur(18px);
        }

        [data-theme="dark"] .suggestion-group {
            background: rgba(26, 32, 60, 0.6);
        }

        .suggestion-group header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .suggestion-chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .suggestion-chip {
            border: none;
            border-radius: 999px;
            padding: 6px 14px;
            font-size: 0.78rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: inherit;
            background: rgba(255, 255, 255, 0.18);
            transition: transform 0.2s ease, filter 0.2s ease;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.24);
        }

        [data-theme="dark"] .suggestion-chip {
            background: rgba(255, 255, 255, 0.08);
        }

        .suggestion-chip[data-accent] {
            color: var(--chip-accent, inherit);
            box-shadow: inset 0 0 0 1px var(--chip-accent, rgba(255,255,255,0.3));
        }

        .suggestion-chip:hover {
            transform: translateY(-2px);
            filter: brightness(1.08);
        }

        .suggestion-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.9;
        }

        .suggestion-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px;
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.65);
            border: var(--border-soft);
        }

        [data-theme="dark"] .suggestion-card {
            background: rgba(24, 30, 52, 0.68);
        }

        .suggestion-card strong {
            font-size: 0.9rem;
        }

        .suggestion-card footer {
            display: flex;
            gap: 10px;
        }

        .suggestion-card button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.85);
            color: inherit;
        }

        [data-theme="dark"] .suggestion-card button {
            background: rgba(38, 46, 74, 0.85);
        }

        .suggestion-card button.primary {
            background: var(--accent-gradient);
            color: #fff;
        }

        .start-menu-category {
            position: relative;
            background: rgba(255, 255, 255, 0.72);
            border: 1px solid rgba(182, 194, 221, 0.35);
            border-radius: 18px;
            overflow: hidden;
            opacity: 0;
            transform: translateY(16px) scale(0.98);
            transition: transform 0.26s cubic-bezier(0.16, 0.86, 0.35, 1.18), box-shadow 0.24s ease, opacity 0.26s ease;
            margin-left: calc(var(--category-depth, 0) * 12px);
            border-left: 4px solid rgba(255, 255, 255, 0.18);
        }

        .start-menu-category.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .start-menu-category::before {
            content: '';
            position: absolute;
            top: 0;
            left: -1px;
            width: 6px;
            bottom: 0;
            border-radius: 4px 0 0 4px;
            background: var(--category-accent, rgba(123, 139, 255, 0.4));
            opacity: 0.7;
        }

        [data-theme="dark"] .start-menu-category {
            background: rgba(24, 30, 48, 0.78);
            border: 1px solid rgba(90, 110, 160, 0.32);
            border-left-color: rgba(90, 110, 160, 0.38);
        }

        .start-menu-category:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 32px rgba(26, 32, 68, 0.18);
        }

        .start-menu-category.drag-over {
            outline: 2px dashed var(--category-accent, rgba(123, 139, 255, 0.4));
            transform: translateY(-2px) scale(1.01);
        }

        .start-menu-category.drag-source {
            opacity: 0.7;
        }

        .start-menu-category.category-smart::after {
            content: 'Smart';
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 0.65rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.28);
            color: var(--text-muted);
        }

        .start-menu-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 16px 18px;
            cursor: pointer;
        }

        .start-menu-category-meta {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .start-menu-category-meta .glyph {
            width: 32px;
            height: 32px;
            border-radius: 12px;
            display: grid;
            place-items: center;
            background: rgba(10, 132, 255, 0.15);
            font-size: 1.1rem;
        }

        .start-menu-category-meta strong {
            font-size: 0.95rem;
            color: var(--text-primary);
        }

        .start-menu-category-meta span {
            font-size: 0.78rem;
            color: var(--text-muted);
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .start-menu-category-meta small {
            display: block;
            font-size: 0.72rem;
            color: var(--text-muted);
            letter-spacing: 0.04em;
        }

        .start-menu-category-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .start-menu-category-controls button {
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.6);
            color: inherit;
            width: 30px;
            height: 30px;
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: filter 0.15s ease;
        }

        [data-theme="dark"] .start-menu-category-controls button {
            background: rgba(34, 42, 68, 0.72);
        }

        .start-menu-category-controls button:hover {
            filter: brightness(1.1);
        }

        .start-menu-app-wrapper {
            overflow: hidden;
            transition: height 0.24s ease;
        }

        .start-menu-category[aria-expanded="false"] .start-menu-app-wrapper {
            height: 0 !important;
        }

        .start-menu-app-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 14px;
            padding: 0 18px 18px;
        }

        .start-menu-app {
            border: none;
            border-radius: 16px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.75);
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            color: inherit;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            opacity: 0;
            transform: translateY(6px);
        }

        [data-theme="dark"] .start-menu-app {
            background: rgba(30, 38, 62, 0.85);
        }

        .start-menu-app:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 26px rgba(26, 32, 68, 0.2);
        }

        .start-menu-category[aria-expanded="true"] .start-menu-app {
            opacity: 1;
            transform: translateY(0);
            transition-delay: calc(var(--item-index, 0) * 40ms);
        }

        @keyframes start-menu-app-in {
            from { opacity: 0; transform: translateY(8px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @media (prefers-reduced-motion: reduce) {
            .start-menu-category {
                opacity: 1 !important;
                transform: none !important;
            }
            .start-menu-app {
                opacity: 1 !important;
                transform: none !important;
                transition: none !important;
            }
        }

        .start-menu-app .glyph {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.85);
            font-size: 1.45rem;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
        }

        [data-theme="dark"] .start-menu-app .glyph {
            background: rgba(38, 46, 74, 0.88);
        }

        .start-menu-app .app-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .start-menu-app .app-info strong {
            font-size: 0.95rem;
        }

        .start-menu-app .app-info span {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .start-menu-app.empty {
            opacity: 0.6;
            pointer-events: none;
        }

        .start-menu-footer {
            padding: 14px 28px 24px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        #start-menu-pin[aria-pressed="true"] {
            background: rgba(10, 132, 255, 0.2);
            color: var(--accent);
            box-shadow: inset 0 0 0 1px rgba(10, 132, 255, 0.15);
        }

        @keyframes menu-in {
            from { opacity: 0; transform: translate(-50%, -55%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .context-menu {
            position: fixed;
            min-width: 200px;
            background: var(--panel-strong);
            border-radius: 14px;
            border: var(--border-soft);
            box-shadow: var(--shadow-soft);
            padding: 6px;
            display: none;
            flex-direction: column;
            z-index: 1500;
        }
        .context-menu[aria-hidden="false"] { display: flex; }
        .context-menu button {
            border: none; background: transparent; color: inherit;
            text-align: left; padding: 8px 12px;
            border-radius: 10px; font-size: 0.9rem;
            display: flex; justify-content: space-between;
            cursor: pointer;
        }
        .context-menu button:hover { background: rgba(255, 255, 255, 0.1); }

        .context-menu-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            padding: 6px 12px 4px;
        }

        #toast-container {
            position: fixed;
            top: 24px; right: 24px;
            width: min(320px, calc(100vw - 48px));
            display: flex; flex-direction: column; gap: 12px;
            z-index: 1600;
        }
        .toast {
            background: var(--panel-strong);
            border-radius: 16px;
            border: var(--border-soft);
            box-shadow: var(--shadow-soft);
            padding: 14px 16px;
            display: flex; flex-direction: column; gap: 6px;
            animation: toast-in 0.24s ease;
        }
        .toast strong { font-size: 0.94rem; }
        .toast p { margin: 0; font-size: 0.8rem; color: var(--text-muted); }
        @keyframes toast-in { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        #modal-layer {
            position: fixed; inset: 0;
            background: rgba(6, 9, 20, 0.5);
            backdrop-filter: blur(12px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1700;
        }
        #modal-layer[aria-hidden="false"] { display: flex; }
        .modal {
            width: min(560px, 92vw);
            max-height: 90vh;
            background: var(--panel-strong);
            border-radius: 18px;
            border: var(--border-strong);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal header { padding: 18px; border-bottom: var(--border-soft); font-weight: 600; }
        .modal main { padding: 18px; overflow: auto; }
        .modal footer { padding: 12px 18px; border-top: var(--border-soft); display: flex; gap: 10px; justify-content: flex-end; }
        .btn-primary { border: none; border-radius: 12px; padding: 8px 16px; background: var(--accent-gradient); color: #fff; cursor: pointer; }
        .btn-secondary { border: none; border-radius: 12px; padding: 8px 16px; background: rgba(255, 255, 255, 0.08); color: inherit; cursor: pointer; }

        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.16); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.24); }

        .app-shell { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        .app-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.65);
            border-bottom: var(--border-soft);
        }

        [data-theme="dark"] .app-toolbar {
            background: rgba(24, 30, 48, 0.78);
        }

        .app-toolbar button,
        .app-toolbar input,
        .app-toolbar select {
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.65);
            color: inherit;
            padding: 8px 14px;
        }

        [data-theme="dark"] .app-toolbar button,
        [data-theme="dark"] .app-toolbar input,
        [data-theme="dark"] .app-toolbar select {
            background: rgba(34, 42, 68, 0.75);
        }

        .app-toolbar button {
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .app-toolbar button:hover {
            filter: brightness(1.05);
            transform: translateY(-1px);
        }

        .file-explorer {
            flex: 1;
            display: grid;
            grid-template-columns: 230px 1fr 260px;
            min-height: 0;
        }
        .file-explorer section {
            padding: 14px;
            overflow: auto;
            background: rgba(255, 255, 255, 0.62);
        }

        [data-theme="dark"] .file-explorer section {
            background: rgba(16, 22, 36, 0.75);
        }
        .file-explorer section + section { border-left: var(--border-soft); }
        .tree-item { padding: 6px 10px; border-radius: 10px; color: var(--text-muted); cursor: pointer; }
        .tree-item:hover, .tree-item.active { background: rgba(123, 139, 255, 0.2); color: var(--text-primary); }
        .file-table { width: 100%; border-collapse: collapse; }
        .file-table th { text-align: left; font-size: 0.72rem; text-transform: uppercase; color: var(--text-muted); padding-bottom: 6px; }
        .file-row { cursor: pointer; border-radius: 10px; }
        .file-row td { padding: 8px 6px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .file-row:hover { background: rgba(255,255,255,0.08); }
        .file-row.active { background: rgba(123,139,255,0.22); }
        .preview-card {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 16px;
            border: var(--border-soft);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        [data-theme="dark"] .preview-card {
            background: rgba(18, 24, 38, 0.8);
        }

        .preview-body {
            background: rgba(255, 255, 255, 0.75);
            border-radius: 14px;
            padding: 12px;
            font-family: "JetBrains Mono", monospace;
            font-size: 0.82rem;
            max-height: 240px;
            overflow: auto;
        }

        [data-theme="dark"] .preview-body {
            background: rgba(22, 28, 46, 0.72);
        }

        .preview-body img { max-width: 100%; border-radius: 14px; }

        .editor-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.78);
            color: inherit;
            border: none;
            padding: 18px;
            resize: none;
            font-family: "JetBrains Mono", monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            outline: none;
        }

        [data-theme="dark"] .editor-area {
            background: rgba(14, 20, 34, 0.82);
        }
        .editor-status { padding: 6px 12px; border-top: var(--border-soft); display: flex; justify-content: space-between; font-size: 0.78rem; color: var(--text-muted); }

        .browser-layout { flex: 1; display: grid; grid-template-columns: minmax(0, 1fr) 260px; min-height: 0; }
        .browser-viewport {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.72);
            border-right: var(--border-soft);
        }

        [data-theme="dark"] .browser-viewport {
            background: rgba(16, 22, 36, 0.78);
        }
        .browser-viewport iframe { flex: 1; border: none; background: #ffffff; }
        .browser-sidebar {
            background: rgba(255, 255, 255, 0.7);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow: auto;
            border-left: var(--border-soft);
        }

        [data-theme="dark"] .browser-sidebar {
            background: rgba(20, 26, 44, 0.78);
        }
        .browser-panel { display: flex; flex-direction: column; gap: 10px; }
        .browser-panel h3 { margin: 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .browser-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 12px; }
        .browser-list li {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.78);
        }

        [data-theme="dark"] .browser-list li {
            background: rgba(24, 30, 48, 0.82);
        }

        .browser-list li span {
            flex: 1;
            font-size: 0.82rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .browser-list li button {
            border: none;
            background: rgba(255,255,255,0.75);
            color: inherit;
            border-radius: 10px;
            padding: 4px 8px;
            cursor: pointer;
        }

        [data-theme="dark"] .browser-list li button {
            background: rgba(36, 44, 70, 0.85);
        }

        .browser-list li button:hover {
            filter: brightness(1.05);
        }
        .browser-status { font-size: 0.75rem; color: var(--text-muted); }

        .terminal { flex: 1; display: grid; grid-template-rows: 1fr auto; background: #020308; }
        .terminal-output { padding: 16px; font-family: "JetBrains Mono", monospace; font-size: 0.84rem; color: #d4fca3; overflow: auto; }
        .terminal-input { display: flex; gap: 8px; padding: 12px 16px; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.32); }
        .terminal-input input { flex: 1; border: none; border-radius: 8px; background: rgba(255,255,255,0.12); color: inherit; padding: 8px 10px; font-family: inherit; }

        .calculator { flex: 1; display: grid; grid-template-rows: auto 1fr; padding: 20px; gap: 16px; }
        .calc-display { background: rgba(0,0,0,0.4); border-radius: 14px; padding: 18px; text-align: right; font-size: 2rem; font-family: "JetBrains Mono", monospace; }
        .calc-grid { display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 10px; }
        .calc-grid button { border-radius: 12px; border: none; background: rgba(255,255,255,0.1); color: inherit; padding: 14px 0; font-size: 1rem; cursor: pointer; }
        .calc-grid button:hover { background: rgba(255,255,255,0.2); }

        .media-player { flex: 1; display: grid; grid-template-columns: minmax(320px, 2fr) minmax(220px, 1fr); min-height: 0; }
        .media-stage { display: flex; flex-direction: column; padding: 20px; gap: 16px; }
        .media-screen { flex: 1; background: rgba(0,0,0,0.5); border-radius: 16px; display: grid; place-items: center; overflow: hidden; }
        .playlist { padding: 18px; border-left: var(--border-soft); display: flex; flex-direction: column; gap: 12px; overflow: auto; }
        .playlist-item { padding: 10px 12px; border-radius: 12px; background: rgba(255,255,255,0.08); display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .playlist-item.active { background: rgba(123,139,255,0.26); }

        .image-viewer { flex: 1; position: relative; background: rgba(0,0,0,0.92); display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .image-viewer img { max-width: 100%; max-height: 100%; transition: transform 0.25s ease; border-radius: 18px; }
        .image-controls { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.4); padding: 10px 16px; border-radius: 14px; }
        .image-controls button { border: none; background: transparent; color: #fff; font-size: 1.1rem; cursor: pointer; }

        .settings { flex: 1; display: grid; grid-template-columns: 230px 1fr; min-height: 0; }
        .settings-nav { border-right: var(--border-soft); padding: 18px; display: flex; flex-direction: column; gap: 10px; }
        .settings-nav button { border: none; border-radius: 12px; padding: 10px; text-align: left; background: rgba(255,255,255,0.07); color: inherit; cursor: pointer; }
        .settings-nav button.active { background: rgba(123,139,255,0.24); }
        .settings-content { padding: 20px; overflow: auto; display: flex; flex-direction: column; gap: 24px; }
        .settings-section h3 { margin: 0 0 12px; }
        .settings-row { display: flex; flex-direction: column; gap: 8px; }
        .settings-row label { color: var(--text-muted); font-size: 0.82rem; }
        .settings-row input[type="color"], .settings-row select, .settings-row input[type="range"], .settings-row input[type="checkbox"], .settings-row button { width: fit-content; }
        .settings-controls { display: flex; flex-wrap: wrap; gap: 12px; }
        .settings-controls button { border: none; border-radius: 12px; padding: 8px 14px; background: rgba(255,255,255,0.82); cursor: pointer; }
        [data-theme="dark"] .settings-controls button { background: rgba(32, 40, 64, 0.82); }
        .settings-controls button:hover { filter: brightness(1.05); }

        .task-app { flex: 1; display: grid; grid-template-columns: 250px minmax(0, 1fr) 300px; min-height: 0; overflow: hidden; gap: 0; }
        .task-sidebar { display: flex; flex-direction: column; gap: 16px; padding: 20px; background: rgba(255, 255, 255, 0.62); border-right: var(--border-soft); }
        [data-theme="dark"] .task-sidebar { background: rgba(16, 22, 36, 0.8); }
        .task-sidebar header { display: flex; align-items: center; justify-content: space-between; }
        .task-sidebar h3 { margin: 0; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .task-sidebar button { border: none; border-radius: 12px; background: rgba(255,255,255,0.7); color: inherit; padding: 8px 12px; cursor: pointer; }
        [data-theme="dark"] .task-sidebar button { background: rgba(32, 40, 64, 0.82); }
        .task-sidebar button:hover { filter: brightness(1.05); }
        .task-filter-list, .task-project-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 6px; }
        .task-filter-item, .task-project-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 12px; cursor: pointer; }
        .task-filter-item.active, .task-project-item.active { background: rgba(123,139,255,0.22); color: var(--text-primary); }
        .task-filter-item .count, .task-project-item .count { margin-left: auto; color: var(--text-muted); font-size: 0.75rem; }
        .task-project-color { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 0 2px rgba(255,255,255,0.4); }
        .task-project-item button { margin-left: 8px; border: none; background: transparent; color: inherit; cursor: pointer; padding: 0 4px; }
        .task-project-item button:hover { color: var(--danger); }
        .task-new-project { display: grid; grid-template-columns: 1fr 60px auto; gap: 8px; }
        .task-new-project input[type="text"] { border: none; border-radius: 10px; padding: 8px 10px; background: rgba(255,255,255,0.75); color: inherit; }
        .task-new-project input[type="color"] { border: none; border-radius: 10px; padding: 0; height: 36px; }
        .task-new-project button { padding: 8px 12px; }

        .task-main { display: flex; flex-direction: column; background: rgba(255,255,255,0.6); min-height: 0; }
        [data-theme="dark"] .task-main { background: rgba(14, 20, 34, 0.82); }
        .task-toolbar { display: flex; gap: 12px; padding: 16px 18px; align-items: center; border-bottom: var(--border-soft); }
        .task-toolbar input[type="text"] { flex: 1; border: none; border-radius: 12px; padding: 10px 14px; background: rgba(255,255,255,0.78); color: inherit; }
        [data-theme="dark"] .task-toolbar input[type="text"] { background: rgba(28, 36, 60, 0.88); }
        .task-toolbar button { border: none; border-radius: 12px; background: rgba(255,255,255,0.75); padding: 9px 14px; cursor: pointer; color: inherit; }
        [data-theme="dark"] .task-toolbar button { background: rgba(32, 40, 64, 0.85); }
        .task-toolbar button.active { background: var(--accent); color: #fff; }

        .task-list { flex: 1; overflow: auto; padding: 18px; display: flex; flex-direction: column; gap: 12px; }
        .task-card { display: grid; grid-template-columns: auto 1fr auto; gap: 12px; align-items: start; padding: 14px; border-radius: 16px; background: rgba(255,255,255,0.78); border: 1px solid rgba(190, 200, 226, 0.32); cursor: pointer; transition: transform 0.18s ease, box-shadow 0.18s ease; }
        [data-theme="dark"] .task-card { background: rgba(22, 28, 46, 0.85); border: 1px solid rgba(90, 110, 160, 0.32); }
        .task-card:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(26, 32, 68, 0.18); }
        .task-card.active { border-color: rgba(10, 132, 255, 0.45); box-shadow: 0 14px 30px rgba(10, 132, 255, 0.22); }
        .task-card.completed { opacity: 0.55; }
        .task-card h4 { margin: 0; font-size: 1rem; }
        .task-card .task-meta { display: flex; flex-wrap: wrap; gap: 8px; font-size: 0.75rem; color: var(--text-muted); }
        .task-card .task-chip { padding: 4px 8px; border-radius: 999px; background: rgba(123,139,255,0.18); color: var(--text-primary); font-size: 0.72rem; letter-spacing: 0.02em; }
        .task-card .task-chip.due-soon { background: rgba(255,130,102,0.22); }
        .task-card .task-chip.overdue { background: rgba(255,96,88,0.22); }
        .task-card .task-chip.priority-high { background: rgba(255,190,70,0.22); }
        .task-card .task-chip.priority-urgent { background: rgba(255,96,88,0.26); }
        .task-card .task-actions { display: flex; gap: 10px; align-items: center; }
        .task-card .task-actions button { border: none; background: transparent; color: inherit; cursor: pointer; font-size: 1.1rem; }
        .task-card .task-actions button:hover { transform: scale(1.1); }
        .task-card input[type="checkbox"] { width: 18px; height: 18px; }

        .task-focus-panel { flex: 1; display: none; padding: 24px; align-items: center; justify-content: center; }
        .task-focus-panel.active { display: flex; }
        .task-focus-card { max-width: 540px; width: 100%; background: rgba(255,255,255,0.84); border-radius: 22px; border: 1px solid rgba(180, 190, 220, 0.35); padding: 28px; display: flex; flex-direction: column; gap: 18px; box-shadow: 0 28px 38px rgba(24, 32, 64, 0.22); }
        [data-theme="dark"] .task-focus-card { background: rgba(18, 24, 38, 0.92); border: 1px solid rgba(90, 110, 160, 0.35); }
        .task-focus-card h2 { margin: 0; font-size: 1.4rem; }
        .task-focus-actions { display: flex; gap: 12px; }
        .task-focus-actions button { flex: 1; border: none; border-radius: 14px; padding: 12px 16px; cursor: pointer; background: var(--accent-gradient); color: #fff; font-weight: 600; }
        .task-focus-actions button.secondary { background: rgba(255,255,255,0.8); color: var(--text-primary); }
        [data-theme="dark"] .task-focus-actions button.secondary { background: rgba(34, 42, 68, 0.85); color: inherit; }

        .task-detail { background: rgba(255,255,255,0.64); padding: 22px; border-left: var(--border-soft); display: flex; flex-direction: column; gap: 16px; }
        [data-theme="dark"] .task-detail { background: rgba(16, 22, 36, 0.88); }
        .task-detail h3 { margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .task-detail-form { display: flex; flex-direction: column; gap: 12px; }
        .task-detail input[type="text"], .task-detail textarea, .task-detail select, .task-detail input[type="datetime-local"] {
            border: none; border-radius: 12px; padding: 10px 12px; background: rgba(255,255,255,0.78); color: inherit; font-family: inherit;
        }
        [data-theme="dark"] .task-detail input[type="text"], [data-theme="dark"] .task-detail textarea, [data-theme="dark"] .task-detail select, [data-theme="dark"] .task-detail input[type="datetime-local"] {
            background: rgba(28, 36, 60, 0.88);
        }
        .task-detail textarea { min-height: 140px; resize: vertical; }
        .task-detail .task-detail-row { display: flex; flex-direction: column; gap: 6px; }
        .task-detail footer { margin-top: auto; display: flex; gap: 12px; }
        .task-detail footer button { flex: 1; border-radius: 14px; border: none; padding: 10px 14px; cursor: pointer; background: rgba(255,255,255,0.82); }
        [data-theme="dark"] .task-detail footer button { background: rgba(32, 40, 64, 0.85); }
        .task-detail footer button.danger { background: rgba(255,96,88,0.22); color: #ffb0aa; }

        .task-detail-empty { margin: auto; text-align: center; font-size: 0.9rem; color: var(--text-muted); line-height: 1.6; }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
            white-space: nowrap;
        }
        .shortcut-app {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.68);
            border-radius: 22px;
            border: var(--border-soft);
        }
        [data-theme="dark"] .shortcut-app {
            background: rgba(18, 24, 38, 0.82);
        }
        .shortcut-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .shortcut-header h2 {
            margin: 0;
            font-size: 1.35rem;
        }
        .shortcut-url {
            font-size: 0.82rem;
            color: var(--text-muted);
            word-break: break-all;
        }
        .shortcut-body {
            font-size: 0.92rem;
            color: var(--text-muted);
            line-height: 1.6;
        }
        .shortcut-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .shortcut-tag {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(123, 139, 255, 0.2);
            font-size: 0.72rem;
            letter-spacing: 0.02em;
            color: var(--text-primary);
        }
        .shortcut-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: auto;
        }
        .shortcut-actions button {
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.82);
            color: inherit;
        }
        [data-theme="dark"] .shortcut-actions button {
            background: rgba(34, 42, 68, 0.85);
        }
        .shortcut-actions button.primary {
            background: var(--accent-gradient);
            color: #fff;
        }

        @media (max-width: 1100px) {
            #desktop {
                grid-template-columns: minmax(0, 1fr);
                padding: 72px 20px calc(var(--taskbar-height) + 32px);
            }
            #desktop-launcher {
                flex-direction: row;
                gap: 18px;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 16px;
            }
            .desktop-section { min-width: 220px; }
            .file-explorer { grid-template-columns: 210px 1fr; }
            .file-explorer section:last-child { display: none; }
            .media-player { grid-template-columns: 1fr; }
            .playlist { border-left: none; border-top: var(--border-soft); }
            .browser-layout { grid-template-columns: 1fr; }
            .browser-sidebar { border-left: none; border-top: var(--border-soft); }
        }
        @media (max-width: 840px) {
            #desktop-launcher {
                flex-direction: column;
                overflow: auto;
            }
            .desktop-section { min-width: 0; }
            .settings { grid-template-columns: 1fr; }
            .settings-nav { flex-direction: row; overflow-x: auto; }
            .settings-nav button { flex: 1 0 auto; }
            #desktop {
                padding: 72px 18px calc(var(--taskbar-height) + 36px);
            }
        }
        @media (max-width: 680px) {
            #taskbar {
                max-width: 90vw;
                gap: 14px;
            }
            #start-button {
                width: 52px;
                height: 52px;
            }
        }
    </style>
</head>
<body>
    <div id="wallpaper-layer"></div>
    <canvas id="desktop-bg"></canvas>
    <header id="menu-bar">
        <div class="menu-left">
            <button id="menu-apple" aria-label="Apple menu" type="button"></button>
            <nav id="menu-items">
                <button type="button" data-menu="finder">ToastSearcher</button>
                <button type="button" data-menu="file">File</button>
                <button type="button" data-menu="edit">Edit</button>
                <button type="button" data-menu="view">View</button>
                <button type="button" data-menu="go">Go</button>
                <button type="button" data-menu="window">Window</button>
                <button type="button" data-menu="help">Help</button>
            </nav>
        </div>
        <div class="menu-center">Designed by Jared Sanford · Slighty.Toasted</div>
        <div class="menu-right">
            <button id="notification-button" aria-label="Notifications" type="button">🔔</button>
            <button id="theme-toggle" aria-label="Toggle appearance" type="button">🌗</button>
            <span id="tray-clock">00:00</span>
        </div>
    </header>
    <main id="desktop">
        <div id="desktop-canvas">
            <div id="desktop-apps" class="desktop-grid"></div>
            <div id="desktop-files" class="desktop-files-grid"></div>
        </div>
        <div id="window-layer"></div>
    </main>
    <div id="taskbar">
        <button id="start-button" title="Open Start Menu" type="button" aria-haspopup="true" aria-expanded="false">
            <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block">
                <g fill="currentColor">
                    <circle cx="5" cy="5" r="1.8"/>
                    <circle cx="12" cy="5" r="1.8"/>
                    <circle cx="19" cy="5" r="1.8"/>
                    <circle cx="5" cy="12" r="1.8"/>
                    <circle cx="12" cy="12" r="1.8"/>
                    <circle cx="19" cy="12" r="1.8"/>
                    <circle cx="5" cy="19" r="1.8"/>
                    <circle cx="12" cy="19" r="1.8"/>
                    <circle cx="19" cy="19" r="1.8"/>
                </g>
            </svg>
        </button>
        <div id="dock"></div>
        <div id="taskbar-apps"></div>
    </div>
    <section id="start-menu" aria-hidden="true" role="dialog" aria-label="Start Menu">
        <header class="start-menu-header">
            <div class="start-menu-title">
                <span class="glyph">⌘</span>
                <div class="start-menu-heading-text">
                    <strong>Applications</strong>
                    <span id="start-menu-app-count"></span>
                </div>
            </div>
            <div class="start-menu-actions">
                <label class="visually-hidden" for="start-menu-search">Search applications</label>
                <input type="search" id="start-menu-search" placeholder="Search apps or categories" autocomplete="off">
                <button type="button" id="start-menu-add-category" title="Create category">＋</button>
            </div>
        </header>
        <div class="start-menu-body">
            <div id="start-menu-categories" class="start-menu-categories" role="tree"></div>
        </div>
        <footer class="start-menu-footer">
            <button type="button" id="start-menu-manage-categories">Manage categories</button>
            <button type="button" id="start-menu-pin" aria-pressed="false" title="Pin start menu">📌 Pin</button>
        </footer>
    </section>
    <nav id="desktop-menu" class="context-menu" aria-hidden="true">
        <button data-action="new-file">New File <span>Ctrl+Shift+N</span></button>
        <button data-action="new-folder">New Folder <span>Ctrl+Shift+D</span></button>
        <button data-action="paste">Paste</button>
        <button data-action="refresh">Refresh</button>
        <div class="menu-separator"></div>
        <button data-action="stack-files">Stack Selected</button>
        <button data-action="desktop-search">Search Desktop <span>Ctrl+Space</span></button>
        <button data-action="workspace-new">New Workspace</button>
        <button data-action="workspace-switch">Switch Workspace</button>
        <button data-action="workspace-assign">Assign Selection to Workspace</button>
        <button data-action="desktop-clean">Smart Clean</button>
        <button data-action="settings">Settings</button>
    </nav>
    <nav id="icon-menu" class="context-menu" aria-hidden="true">
        <button data-action="app-open">Open</button>
        <button data-action="app-pin">Pin to Dock</button>
        <button data-action="app-unpin">Remove from Dock</button>
    </nav>
    <nav id="dock-menu" class="context-menu" aria-hidden="true"></nav>
    <nav id="start-menu-menu" class="context-menu" aria-hidden="true">
        <button data-action="start-open">Open</button>
        <button data-action="start-pin">Pin to Dock</button>
        <button data-action="start-move">Move to Category…</button>
    </nav>
    <section id="toast-container"></section>
    <section id="modal-layer" aria-hidden="true"></section>
    <input type="file" id="file-input" multiple style="display:none">
    <script>
    (() => {
        const STORAGE_KEYS = {
            FILE_SYSTEM: 'webos.fs.v1',
            SETTINGS: 'webos.settings.v1',
            TERMINAL_HISTORY: 'webos.terminal.history.v1',
            MEDIA_PLAYLIST: 'webos.media.playlist.v1',
            TASKS: 'webos.tasks.v1',
            AI_SETTINGS: 'webos.ai.settings.v1'
        };

        const APP_CATALOG = [
            { id: 'tasks', name: 'Task Command', icon: '✅', hint: 'Plan & focus' },
            { id: 'toastsearcher', name: 'ToastSearcher', icon: '🍞', hint: 'Search & manage files' },
            { id: 'browser', name: 'Web Navigator', icon: '🌐', hint: 'Browse the web' },
            { id: 'text-editor', name: 'Text Studio', icon: '📝', hint: 'Edit documents' },
            { id: 'calculator', name: 'ScientiCalc', icon: '🧮', hint: 'Scientific calculator' },
            { id: 'terminal', name: 'Terminal', icon: '💻', hint: 'Command line' },
            { id: 'media-player', name: 'Media Player', icon: '🎵', hint: 'Audio & video playback' },
            { id: 'image-viewer', name: 'Image Viewer', icon: '🖼️', hint: 'View pictures' },
            { id: 'settings', name: 'System Settings', icon: '⚙️', hint: 'Configure WebOS' },
            { id: 'assistant', name: 'AI Assistant', icon: '🤖', hint: 'Chat & automate' }
        ];

        const WEB_PORTAL_APPS = [
            { id: 'netflix', name: 'Netflix', icon: '🎬', hint: 'Stream movies & TV', url: 'https://www.netflix.com/browse', description: 'Stream Netflix originals, films, and series. A Netflix subscription and regional availability are required.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'youtube', name: 'YouTube', icon: '▶️', hint: 'Watch online video', url: 'https://www.youtube.com/', description: 'Browse channels, watch live streams, and discover trending videos on YouTube.', categories: ['Streaming & Media'] },
            { id: 'primevideo', name: 'Amazon Prime Video', icon: '📺', hint: 'Prime Video library', url: 'https://www.primevideo.com/', description: 'Watch Amazon Originals along with licensed films and series. Requires an Amazon Prime Video membership.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'hulu', name: 'Hulu', icon: '📼', hint: 'Hulu streaming', url: 'https://www.hulu.com/', description: 'Catch next-day TV, movies, and Hulu originals. Service available primarily within the United States.', categories: ['Streaming & Media'], availability: 'Region: United States' },
            { id: 'disneyplus', name: 'Disney+', icon: '🪄', hint: 'Disney, Marvel & more', url: 'https://www.disneyplus.com/', description: 'Stream Disney, Pixar, Marvel, Star Wars, and National Geographic stories in one place.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'hbomax', name: 'Max', icon: '🍿', hint: 'HBO & Warner content', url: 'https://www.max.com/', description: 'Enjoy HBO series, Warner Bros. films, and Max Originals. Availability varies by region.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'spotify', name: 'Spotify', icon: '🎧', hint: 'Music & podcasts', url: 'https://open.spotify.com/', description: 'Listen to millions of songs, curated playlists, and podcasts on Spotify.', categories: ['Music & Audio'], availability: 'Login required' },
            { id: 'bbciplayer', name: 'BBC iPlayer', icon: '📻', hint: 'BBC live & on-demand', url: 'https://www.bbc.co.uk/iplayer', description: 'Stream BBC TV channels, live news, and on-demand programmes. Access limited to UK audiences.', categories: ['News & Live TV'], availability: 'Region: United Kingdom' },
            { id: 'cnn', name: 'CNN', icon: '📰', hint: 'Global news updates', url: 'https://www.cnn.com/', description: 'Stay informed with breaking news, live video, and world coverage from CNN.', categories: ['News & Live TV'] },
            { id: 'accuweather', name: 'AccuWeather', icon: '🌤️', hint: 'Forecasts & radar', url: 'https://www.accuweather.com/', description: 'Track hyperlocal forecasts, severe weather alerts, and radar maps.', categories: ['Weather', 'Utilities'] },
            { id: 'facebookwatch', name: 'Facebook Watch', icon: '📱', hint: 'Shows & live streams', url: 'https://www.facebook.com/watch', description: 'Discover trending videos, live streams, and Facebook Originals.', categories: ['Social & Communication', 'Streaming & Media'], availability: 'Login required' },
            { id: 'zoom', name: 'Zoom Meetings', icon: '🎥', hint: 'Video conferencing', url: 'https://zoom.us/wc/join', description: 'Join or host video meetings directly in the browser with Zoom Web Client.', categories: ['Social & Communication', 'Productivity'] },
            { id: 'twitch', name: 'Twitch', icon: '🕹️', hint: 'Live gaming streams', url: 'https://www.twitch.tv/', description: 'Watch live gaming broadcasts, esports events, and creative streams.', categories: ['Gaming & Entertainment'] },
            { id: 'plex', name: 'Plex', icon: '📦', hint: 'Personal media hub', url: 'https://app.plex.tv/desktop', description: 'Stream your personal media library or ad-supported content through Plex.', categories: ['Streaming & Media', 'Personal Media'], availability: 'Login required' },
            { id: 'kodi', name: 'Kodi Web', icon: '🧩', hint: 'Kodi remote interface', url: 'http://kodi.tv/', description: 'Connect to the Kodi web interface for browsing and controlling a configured Kodi media center.', categories: ['Streaming & Media', 'Personal Media'], availability: 'Requires existing Kodi setup' },
            { id: 'google', name: 'Google Search', icon: '🔍', hint: 'Search the web', url: 'https://www.google.com/', description: 'Quickly search the web with Google Search.', categories: ['Utilities', 'Productivity'] },
            { id: 'gmail', name: 'Gmail', icon: '✉️', hint: 'Google email', url: 'https://mail.google.com/', description: 'Read and compose email using the Gmail web client.', categories: ['Productivity', 'Email'], availability: 'Login required' },
            { id: 'outlookmail', name: 'Outlook Mail', icon: '📬', hint: 'Microsoft email', url: 'https://outlook.office.com/mail/', description: 'Access Outlook, Microsoft 365, or Hotmail inboxes in the browser.', categories: ['Productivity', 'Email'], availability: 'Login required' },
            { id: 'googledrive', name: 'Google Drive', icon: '📁', hint: 'Google cloud files', url: 'https://drive.google.com/drive/my-drive', description: 'Manage documents, spreadsheets, and cloud storage with Google Drive.', categories: ['Productivity', 'Cloud Storage'], availability: 'Login required' },
            { id: 'dropbox', name: 'Dropbox', icon: '🗄️', hint: 'Dropbox storage', url: 'https://www.dropbox.com/home', description: 'Browse and share files stored in Dropbox cloud storage.', categories: ['Productivity', 'Cloud Storage'], availability: 'Login required' }
        ];

        WEB_PORTAL_APPS.forEach(app => APP_CATALOG.push({ id: app.id, name: app.name, icon: app.icon, hint: app.hint }));

        const APP_CATEGORY_STORAGE_KEY = 'webos.appCategories.v1';
        const DEFAULT_CATEGORY_DEFS = [
            { id: 'productivity', name: 'Productivity', icon: '📂', accent: '#7b8bff', custom: false },
            { id: 'productivity-collab', parentId: 'productivity', name: 'Collaboration', icon: '🤝', accent: '#9b7bff', type: 'smart', filters: { keywords: ['meeting', 'mail', 'drive', 'cloud', 'team'] }, custom: false },
            { id: 'media', name: 'Media & Entertainment', icon: '🎬', accent: '#ff8f70', custom: false },
            { id: 'media-streaming', parentId: 'media', name: 'Streaming Services', icon: '📺', accent: '#ffb347', type: 'smart', filters: { keywords: ['stream', 'video', 'tv', 'movie'] }, custom: false },
            { id: 'media-music', parentId: 'media', name: 'Music & Audio', icon: '🎧', accent: '#6ad2ff', type: 'smart', filters: { keywords: ['music', 'audio', 'podcast'] }, custom: false },
            { id: 'games', name: 'Games & Fun', icon: '🕹️', accent: '#ff7096', custom: false },
            { id: 'news', name: 'News & Weather', icon: '📰', accent: '#6ddccf', custom: false },
            { id: 'utilities', name: 'Utilities', icon: '🧰', accent: '#f6c667', custom: false },
            { id: 'utilities-web', parentId: 'utilities', name: 'Web Tools', icon: '🧭', accent: '#57c7ff', type: 'smart', filters: { keywords: ['web', 'search', 'browser'] }, custom: false },
            { id: 'system', name: 'System', icon: '🛠️', accent: '#6f7cff', custom: false },
            { id: 'uncategorized', name: 'Uncategorized', icon: '🗂️', accent: '#a0aec0', custom: false }
        ];

        const DEFAULT_APP_CATEGORY_ASSIGNMENTS = {
            tasks: 'productivity',
            toastsearcher: 'system',
            browser: 'utilities-web',
            'text-editor': 'productivity',
            calculator: 'utilities',
            terminal: 'system',
            'media-player': 'media',
            'image-viewer': 'media',
            settings: 'system',
            assistant: 'system',
            netflix: 'media-streaming',
            youtube: 'media-streaming',
            primevideo: 'media-streaming',
            hulu: 'media-streaming',
            disneyplus: 'media-streaming',
            hbomax: 'media-streaming',
            spotify: 'media-music',
            plex: 'media-streaming',
            kodi: 'media-streaming',
            facebookwatch: 'media-streaming',
            zoom: 'productivity-collab',
            twitch: 'media-streaming',
            google: 'utilities-web',
            gmail: 'productivity-collab',
            outlookmail: 'productivity-collab',
            googledrive: 'productivity-collab',
            dropbox: 'productivity-collab',
            cnn: 'news',
            bbciplayer: 'news',
            accuweather: 'news'
        };

        const CATEGORY_KEYWORD_RULES = [
            { category: 'productivity-collab', keywords: ['email', 'mail', 'meet', 'calendar', 'drive', 'doc', 'team', 'collab', 'office', 'zoom'] },
            { category: 'productivity', keywords: ['note', 'task', 'todo', 'plan', 'write', 'editor', 'text'] },
            { category: 'media-streaming', keywords: ['stream', 'movie', 'tv', 'video', 'show', 'series', 'watch'] },
            { category: 'media-music', keywords: ['music', 'audio', 'podcast', 'playlist', 'song'] },
            { category: 'games', keywords: ['game', 'play', 'fun', 'arcade'] },
            { category: 'news', keywords: ['news', 'weather', 'forecast', 'headline'] },
            { category: 'utilities-web', keywords: ['web', 'browser', 'search', 'drive', 'cloud'] },
            { category: 'system', keywords: ['settings', 'system', 'config', 'terminal'] }
        ];

        const CATEGORY_ACCENTS = ['#7b8bff', '#ff8f70', '#6ad2ff', '#6ddccf', '#ff7096', '#f6c667', '#9b7bff', '#57c7ff'];

        const reconcileOrder = (existing = [], required = []) => {
            const reqSet = new Set(required);
            const filtered = Array.isArray(existing) ? existing.filter(id => reqSet.has(id)) : [];
            required.forEach(id => {
                if (!filtered.includes(id)) filtered.push(id);
            });
            return filtered;
        };

        const DOCK_QUICK_ACTIONS = {
            'text-editor': [
                { label: 'New Document', handler: ctx => ctx.appManager.open('text-editor') },
                { label: 'Open Notes Folder', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Documents/notes' }) }
            ],
            browser: [
                { label: 'New Tab', handler: ctx => ctx.appManager.open('browser') },
                { label: 'Cascade Projects', handler: ctx => ctx.appManager.open('browser', { url: 'https://cascade.cool' }) },
                { label: 'MDN Docs', handler: ctx => ctx.appManager.open('browser', { url: 'https://developer.mozilla.org' }) }
            ],
            tasks: [
                { label: 'Focus Session', handler: ctx => ctx.appManager.open('tasks', { focus: true }) },
                { label: 'Today View', handler: ctx => ctx.appManager.open('tasks', { focus: false }) }
            ],
            'media-player': [
                { label: 'Open Playlist', handler: ctx => ctx.appManager.open('media-player') }
            ]
        };

        const DOCK_JUMP_LISTS = {
            browser: [
                { label: 'OpenAI', handler: ctx => ctx.appManager.open('browser', { url: 'https://openai.com' }) },
                { label: 'YouTube', handler: ctx => ctx.appManager.open('browser', { url: 'https://www.youtube.com/' }) },
                { label: 'Netflix', handler: ctx => ctx.appManager.open('browser', { url: 'https://www.netflix.com/browse' }) }
            ],
            'text-editor': [
                { label: 'Welcome File', handler: ctx => ctx.appManager.open('text-editor', { path: '/Documents/welcome.txt' }) }
            ],
            toastsearcher: [
                { label: 'Documents Folder', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Documents' }) },
                { label: 'Downloads', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Downloads' }) }
            ]
        };

        const MIME_TYPES = {
            '.txt': 'text/plain', '.md': 'text/markdown', '.json': 'application/json', '.js': 'application/javascript',
            '.ts': 'application/typescript', '.html': 'text/html', '.css': 'text/css', '.csv': 'text/csv', '.xml': 'application/xml',
            '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.png': 'image/png', '.gif': 'image/gif', '.webp': 'image/webp', '.svg': 'image/svg+xml',
            '.mp3': 'audio/mpeg', '.wav': 'audio/wav', '.ogg': 'audio/ogg', '.mp4': 'video/mp4', '.webm': 'video/webm', '.mov': 'video/quicktime'
        };

        const APP_ASSOCIATIONS = {
            text: ['.txt', '.md', '.json', '.js', '.ts', '.html', '.css', '.csv', '.xml'],
            image: ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'],
            audio: ['.mp3', '.wav', '.ogg'],
            video: ['.mp4', '.webm', '.mov']
        };

        const utils = {
            nowISO: () => new Date().toISOString(),
            ext(name) { const idx = name.lastIndexOf('.'); return idx >= 0 ? name.slice(idx).toLowerCase() : ''; },
            dirname(path) {
                if (path === '/' || !path) return '/';
                const parts = path.split('/').filter(Boolean);
                parts.pop();
                return '/' + parts.join('/');
            },
            join(...parts) {
                const path = parts.join('/').replace(/\\+/g, '/');
                if (!path.startsWith('/')) return utils.normalize('/' + path);
                return utils.normalize(path);
            },
            normalize(path) {
                if (!path) return '/';
                const segments = [];
                path.split('/').forEach(segment => {
                    if (!segment || segment === '.') return;
                    if (segment === '..') segments.pop(); else segments.push(segment);
                });
                return segments.length ? '/' + segments.join('/') : '/';
            },
            uuid() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
                return `id-${Math.random().toString(16).slice(2)}${Date.now().toString(16)}`;
            },
            bytesToBase64(bytes) {
                let binary = '';
                const len = bytes.length;
                for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
                return btoa(binary);
            },
            base64ToBytes(base64) {
                const binary = atob(base64);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
                return bytes;
            },
            textToBase64(text) {
                const bytes = new TextEncoder().encode(text);
                return utils.bytesToBase64(bytes);
            },
            base64ToText(base64, encoding = 'utf-8') {
                return new TextDecoder(encoding).decode(utils.base64ToBytes(base64));
            },
            mimeFromName(name) { return MIME_TYPES[utils.ext(name)] || 'application/octet-stream'; },
            formatBytes(bytes) {
                if (!bytes) return '0 B';
                const units = ['B', 'KB', 'MB', 'GB'];
                const index = Math.floor(Math.log(bytes) / Math.log(1024));
                return `${(bytes / 1024 ** index).toFixed(index ? 1 : 0)} ${units[index]}`;
            },
            debounce(fn, wait = 200) {
                let timer;
                let lastArgs;
                const debounced = (...args) => {
                    lastArgs = args;
                    clearTimeout(timer);
                    timer = setTimeout(() => {
                        timer = null;
                        fn(...lastArgs);
                    }, wait);
                };
                debounced.cancel = () => {
                    clearTimeout(timer);
                    timer = null;
                };
                debounced.flush = () => {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                        fn(...lastArgs);
                    }
                };
                return debounced;
            },
            throttle(fn, wait = 100) {
                let last = 0;
                return (...args) => {
                    const now = Date.now();
                    if (now - last >= wait) {
                        last = now;
                        fn(...args);
                    }
                };
            },
            createEl(tag, className, props = {}) {
                const el = document.createElement(tag);
                if (className) el.className = className;
                Object.entries(props).forEach(([key, value]) => {
                    if (key === 'text') el.textContent = value;
                    else if (key === 'html') el.innerHTML = value;
                    else el.setAttribute(key, value);
                });
                return el;
            },
            humanDate(iso) { return new Date(iso).toLocaleString(); },
            relativeTime(value) {
                if (!value) return '';
                const date = value instanceof Date ? value : new Date(value);
                if (Number.isNaN(date.getTime())) return '';
                const diff = date.getTime() - Date.now();
                const absolute = Math.abs(diff);
                const units = [
                    { unit: 'second', ms: 1000 },
                    { unit: 'minute', ms: 60_000 },
                    { unit: 'hour', ms: 3_600_000 },
                    { unit: 'day', ms: 86_400_000 },
                    { unit: 'week', ms: 604_800_000 },
                    { unit: 'month', ms: 2_629_800_000 },
                    { unit: 'year', ms: 31_557_600_000 }
                ];
                const entry = units.find((item, index) => absolute < (index < units.length - 1 ? units[index + 1].ms : Infinity)) || units[units.length - 1];
                const valueRounded = Math.round(diff / entry.ms);
                try {
                    const formatter = new Intl.RelativeTimeFormat(undefined, { numeric: 'auto' });
                    return formatter.format(valueRounded, entry.unit);
                } catch (error) {
                    const absValue = Math.abs(valueRounded);
                    const suffix = valueRounded > 0 ? 'from now' : 'ago';
                    return `${absValue} ${entry.unit}${absValue === 1 ? '' : 's'} ${suffix}`;
                }
            },
            clamp(value, min, max) { return Math.min(Math.max(value, min), max); },
            nextColor(color, amount = 0.2) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.min(255, (num >> 16) + Math.round(255 * amount));
                const g = Math.min(255, ((num >> 8) & 0xff) + Math.round(255 * amount));
                const b = Math.min(255, (num & 0xff) + Math.round(255 * amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }
        };

        class EventEmitter {
            constructor() { this.listeners = new Map(); }
            on(event, handler) {
                if (!this.listeners.has(event)) this.listeners.set(event, new Set());
                this.listeners.get(event).add(handler);
                return () => this.off(event, handler);
            }
            off(event, handler) {
                const set = this.listeners.get(event);
                if (set) set.delete(handler);
            }
            emit(event, payload) {
                const set = this.listeners.get(event);
                if (set) set.forEach(handler => handler(payload));
            }
        }
        class FileSystem extends EventEmitter {
            constructor() {
                super();
                this.storageKey = STORAGE_KEYS.FILE_SYSTEM;
                this.root = null;
                this.load();
            }

            load() {
                try {
                    const raw = localStorage.getItem(this.storageKey);
                    if (raw) {
                        this.root = JSON.parse(raw);
                    } else {
                        this.root = this.createDefaultStructure();
                        this.persist();
                    }
                } catch (error) {
                    console.error('Failed to load file system', error);
                    this.root = this.createDefaultStructure();
                    this.persist();
                }
            }

            persist() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.root));
            }

            createDefaultStructure() {
                const now = utils.nowISO();
                const file = (name, content, mime = 'text/plain') => ({
                    type: 'file',
                    name,
                    mime,
                    encoding: 'utf-8',
                    data: utils.textToBase64(content),
                    size: content.length,
                    createdAt: now,
                    updatedAt: now,
                    metadata: {}
                });
                return {
                    type: 'directory',
                    name: '',
                    createdAt: now,
                    updatedAt: now,
                    children: {
                        Desktop: { type: 'directory', name: 'Desktop', createdAt: now, updatedAt: now, children: {} },
                        Documents: {
                            type: 'directory',
                            name: 'Documents',
                            createdAt: now,
                            updatedAt: now,
                            children: {
                                'welcome.txt': file('welcome.txt', 'Welcome to WebOS!\n\nOpen ToastSearcher to browse the virtual file system. Double click files to open them. Drag files on the desktop to upload. Enjoy!'),
                                notes: { type: 'directory', name: 'notes', createdAt: now, updatedAt: now, children: {} }
                            }
                        },
                        Downloads: { type: 'directory', name: 'Downloads', createdAt: now, updatedAt: now, children: {} },
                        Pictures: { type: 'directory', name: 'Pictures', createdAt: now, updatedAt: now, children: {} },
                        Music: { type: 'directory', name: 'Music', createdAt: now, updatedAt: now, children: {} },
                        System: {
                            type: 'directory',
                            name: 'System',
                            createdAt: now,
                            updatedAt: now,
                            children: {
                                'config.json': file('config.json', JSON.stringify({
                                    theme: 'auto',
                                    accent: '#7b8bff',
                                    fontScale: 1,
                                    notifications: true,
                                    autoSave: true,
                                    showSeconds: false,
                                    wallpaper: 'aurora',
                                    taskbarPosition: 'bottom',
                                    desktopDensity: 'comfortable',
                                    showParticles: true,
                                    useBrowserProxy: true,
                                    dockAutoHide: false,
                                    dockSmartSizing: true,
                                    dockPredictivePinning: true,
                                    dockGroupedView: false
                                }, null, 2), 'application/json'),
                                'bookmarks.json': file('bookmarks.json', JSON.stringify([
                                    { title: 'Cascade Projects', url: 'https://cascade.cool' },
                                    { title: 'MDN Web Docs', url: 'https://developer.mozilla.org' },
                                    { title: 'OpenAI', url: 'https://openai.com' }
                                ], null, 2), 'application/json')
                            }
                        }
                    }
                };
            }

            resolve(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') return { parent: null, entry: this.root, name: '' };
                const segments = normalized.split('/').filter(Boolean);
                let current = this.root;
                let parent = null;
                for (const segment of segments) {
                    if (!current || current.type !== 'directory') return { parent, entry: null, name: segment };
                    parent = current;
                    current = current.children[segment];
                    if (!current) return { parent, entry: null, name: segment };
                }
                return { parent, entry: current, name: segments[segments.length - 1] };
            }

            ensureDirectory(path) {
                const { entry } = this.resolve(path);
                if (!entry) throw new Error(`Path not found: ${path}`);
                if (entry.type !== 'directory') throw new Error(`Not a directory: ${path}`);
                return entry;
            }

            exists(path) {
                return Boolean(this.resolve(path).entry);
            }

            listDirectory(path) {
                const dir = this.ensureDirectory(path);
                return Object.values(dir.children || {})
                    .map(entry => ({
                        name: entry.name,
                        type: entry.type,
                        mime: entry.mime,
                        encoding: entry.encoding,
                        size: entry.size || 0,
                        createdAt: entry.createdAt,
                        updatedAt: entry.updatedAt,
                        metadata: entry.metadata || {},
                        path: utils.join(path, entry.name)
                    }))
                    .sort((a, b) => {
                        if (a.type === b.type) return a.name.localeCompare(b.name);
                        return a.type === 'directory' ? -1 : 1;
                    });
            }

            createDirectory(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') return;
                const { parent, entry, name } = this.resolve(normalized);
                if (entry) throw new Error('Directory already exists');
                if (!parent || parent.type !== 'directory') throw new Error('Parent directory not found');
                parent.children[name] = {
                    type: 'directory',
                    name,
                    createdAt: utils.nowISO(),
                    updatedAt: utils.nowISO(),
                    children: {}
                };
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'createDirectory', path: normalized });
            }

            createFile(path, content = '', options = {}) {
                const normalized = utils.normalize(path);
                const dirPath = utils.dirname(normalized);
                const directory = this.ensureDirectory(dirPath);
                const name = normalized.split('/').pop();
                if (directory.children[name]) throw new Error('File already exists');
                const mime = options.mime || utils.mimeFromName(name);
                let data = '';
                if (content instanceof Uint8Array) data = utils.bytesToBase64(content);
                else if (typeof content === 'string') data = utils.textToBase64(content);
                else if (content === null) data = '';
                else throw new Error('Unsupported file content');
                directory.children[name] = {
                    type: 'file',
                    name,
                    mime,
                    encoding: options.encoding || 'utf-8',
                    data,
                    size: utils.base64ToBytes(data).length,
                    createdAt: utils.nowISO(),
                    updatedAt: utils.nowISO(),
                    metadata: options.metadata || {}
                };
                directory.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'createFile', path: normalized });
            }

            readFile(path, { encoding = 'utf-8', as = 'text' } = {}) {
                const { entry } = this.resolve(path);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                const bytes = utils.base64ToBytes(entry.data || '');
                if (as === 'bytes') return bytes;
                return new TextDecoder(encoding || entry.encoding || 'utf-8').decode(bytes);
            }

            readFileMeta(path) {
                const { entry } = this.resolve(path);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                return entry;
            }

            writeFile(path, content, options = {}) {
                const normalized = utils.normalize(path);
                const { entry } = this.resolve(normalized);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                let data;
                if (content instanceof Uint8Array) data = utils.bytesToBase64(content);
                else if (typeof content === 'string') data = utils.textToBase64(content);
                else throw new Error('Unsupported content');
                entry.data = data;
                entry.mime = options.mime || entry.mime;
                entry.encoding = options.encoding || entry.encoding || 'utf-8';
                entry.updatedAt = utils.nowISO();
                entry.size = utils.base64ToBytes(data).length;
                this.persist();
                this.emit('change', { type: 'writeFile', path: normalized });
            }

            delete(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') throw new Error('Cannot delete root directory');
                const { parent, entry, name } = this.resolve(normalized);
                if (!entry) throw new Error('Path not found');
                delete parent.children[name];
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'delete', path: normalized });
            }

            rename(path, newName) {
                const normalized = utils.normalize(path);
                const { parent, entry, name } = this.resolve(normalized);
                if (!entry || !parent) throw new Error('Path not found');
                if (parent.children[newName]) throw new Error('Destination exists');
                delete parent.children[name];
                entry.name = newName;
                parent.children[newName] = entry;
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'rename', path: normalized, newPath: utils.join(utils.dirname(normalized), newName) });
            }

            copy(sourcePath, targetDirPath) {
                const { entry } = this.resolve(sourcePath);
                if (!entry) throw new Error('Source not found');
                const targetDir = this.ensureDirectory(targetDirPath);
                if (targetDir.children[entry.name]) throw new Error('Target already exists');
                const cloneEntry = JSON.parse(JSON.stringify(entry));
                cloneEntry.createdAt = utils.nowISO();
                cloneEntry.updatedAt = utils.nowISO();
                targetDir.children[entry.name] = cloneEntry;
                targetDir.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'copy', path: sourcePath, target: utils.join(targetDirPath, entry.name) });
            }

            move(sourcePath, targetDirPath) {
                const normalizedSource = utils.normalize(sourcePath);
                const normalizedTarget = utils.normalize(targetDirPath);
                const { parent, entry, name } = this.resolve(normalizedSource);
                if (!entry || !parent) throw new Error('Source not found');
                const targetDir = this.ensureDirectory(normalizedTarget);
                if (targetDir.children[entry.name]) throw new Error('Target already exists');
                targetDir.children[entry.name] = entry;
                delete parent.children[name];
                parent.updatedAt = utils.nowISO();
                targetDir.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'move', path: normalizedSource, target: utils.join(normalizedTarget, entry.name) });
            }

            search(term) {
                const results = [];
                const lower = term.toLowerCase();
                const traverse = (entry, currentPath) => {
                    if (entry !== this.root && entry.name.toLowerCase().includes(lower)) {
                        results.push({ name: entry.name, type: entry.type, path: currentPath, updatedAt: entry.updatedAt });
                    }
                    if (entry.type === 'directory') {
                        Object.entries(entry.children).forEach(([name, child]) => {
                            traverse(child, utils.join(currentPath, name));
                        });
                    }
                };
                traverse(this.root, '/');
                return results.sort((a, b) => a.name.localeCompare(b.name));
            }
        }
        class SettingsManager extends EventEmitter {
            constructor() {
                super();
                this.storageKey = STORAGE_KEYS.SETTINGS;
                this.defaults = {
                    theme: 'auto',
                    accent: '#7b8bff',
                    fontScale: 1,
                    notifications: true,
                    autoSave: true,
                    showSeconds: false,
                    wallpaper: 'aurora',
                    taskbarPosition: 'bottom',
                    desktopDensity: 'comfortable',
                    showParticles: true,
                    useBrowserProxy: true,
                    wallpaperCustom: null,
                    wallpaperBlur: 6,
                    wallpaperBrightness: 1,
                    wallpaperOpacity: 0.95,
                    dockAutoHide: false,
                    dockSmartSizing: true,
                    dockPredictivePinning: true,
                    dockGroupedView: false
                };
                this.state = this.load();
                this.particlesController = null;
                this.dockController = null;
                this.applyTheme();
                this.applyAccent();
                this.applyFontScale();
                this.applyWallpaper();
                this.applyWallpaperEffects();
                this.applyTaskbarPosition();
                this.applyDesktopDensity();
                this.applyParticles();
                this.applyDockPreferences();
            }

            load() {
                try {
                    const raw = localStorage.getItem(this.storageKey);
                    if (raw) return { ...this.defaults, ...JSON.parse(raw) };
                } catch (error) {
                    console.warn('Failed to load settings', error);
                }
                return { ...this.defaults };
            }

            save() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.state));
                this.emit('change', { ...this.state });
            }

            update(partial) {
                Object.assign(this.state, partial);
                this.save();
                if ('theme' in partial) this.applyTheme();
                if ('accent' in partial) this.applyAccent();
                if ('fontScale' in partial) this.applyFontScale();
                if ('wallpaper' in partial || 'wallpaperCustom' in partial) this.applyWallpaper();
                if ('wallpaperBlur' in partial || 'wallpaperBrightness' in partial || 'wallpaperOpacity' in partial) this.applyWallpaperEffects();
                if ('taskbarPosition' in partial) this.applyTaskbarPosition();
                if ('desktopDensity' in partial) this.applyDesktopDensity();
                if ('showParticles' in partial) this.applyParticles();
                if ('dockAutoHide' in partial || 'dockSmartSizing' in partial || 'dockPredictivePinning' in partial || 'dockGroupedView' in partial) this.applyDockPreferences();
            }

            applyTheme() {
                const theme = this.state.theme;
                if (theme === 'auto') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.documentElement.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.documentElement.dataset.theme = theme;
                }
            }

            applyAccent() {
                const color = this.state.accent;
                document.documentElement.style.setProperty('--accent', color);
                document.documentElement.style.setProperty('--accent-strong', color);
                document.documentElement.style.setProperty('--accent-gradient', `linear-gradient(135deg, ${color} 0%, ${utils.nextColor(color)} 100%)`);
            }

            applyFontScale() {
                document.documentElement.style.setProperty('--base-font-size', `${14 * this.state.fontScale}px`);
            }

            applyWallpaper() {
                const wallpaper = this.state.wallpaper;
                if (wallpaper === 'custom' && this.state.wallpaperCustom) {
                    document.body.dataset.wallpaper = 'custom';
                    document.documentElement.style.setProperty('--wallpaper-image', `url('${this.state.wallpaperCustom}')`);
                } else {
                    document.documentElement.style.removeProperty('--wallpaper-image');
                    document.body.dataset.wallpaper = wallpaper;
                }
                this.particlesController?.setMode?.(wallpaper);
            }

            applyWallpaperEffects() {
                const blurValue = Number(this.state.wallpaperBlur ?? 0);
                const brightnessValue = Number(this.state.wallpaperBrightness ?? 1);
                const opacityValue = Number(this.state.wallpaperOpacity ?? 1);
                document.documentElement.style.setProperty('--wallpaper-blur', `${blurValue}px`);
                document.documentElement.style.setProperty('--wallpaper-brightness', String(brightnessValue));
                document.documentElement.style.setProperty('--wallpaper-opacity', String(opacityValue));
            }

            applyTaskbarPosition() {
                document.body.dataset.taskbar = this.state.taskbarPosition;
            }

            applyDesktopDensity() {
                const density = this.state.desktopDensity;
                const presets = {
                    compact: { icon: 50, gap: 10 },
                    comfortable: { icon: 62, gap: 16 },
                    spacious: { icon: 74, gap: 20 }
                };
                const chosen = presets[density] || presets.comfortable;
                document.documentElement.style.setProperty('--desktop-icon-size', `${chosen.icon}px`);
                document.documentElement.style.setProperty('--desktop-stack-gap', `${chosen.gap}px`);
                document.body.dataset.desktopDensity = density;
            }

            applyParticles() {
                document.body.dataset.particles = this.state.showParticles ? 'on' : 'off';
                this.particlesController?.setEnabled(this.state.showParticles);
            }

            setBackgroundController(controller) {
                this.particlesController = controller;
                this.particlesController?.setMode?.(this.state.wallpaper);
                this.applyParticles();
                this.applyWallpaperEffects();
            }

            applyDockPreferences() {
                document.body.dataset.dockAutohide = this.state.dockAutoHide ? 'on' : 'off';
                document.body.dataset.dockGrouped = this.state.dockGroupedView ? 'on' : 'off';
                document.body.dataset.dockSizing = this.state.dockSmartSizing ? 'smart' : 'static';
                this.dockController?.applyPreferences?.(this.state);
            }

            setDockController(controller) {
                this.dockController = controller;
                this.applyDockPreferences();
            }
        }

        class NotificationCenter {
            constructor(settings) {
                this.settings = settings;
                this.container = document.getElementById('toast-container');
            }

            notify(title, message, options = {}) {
                if (!this.settings.state.notifications) return;
                const toast = utils.createEl('div', 'toast');
                toast.innerHTML = `<strong>${title}</strong><p>${message}</p>`;
                if (options.action) {
                    const actionBtn = utils.createEl('button', 'btn-secondary', { text: options.action.label });
                    actionBtn.style.alignSelf = 'flex-end';
                    actionBtn.addEventListener('click', () => {
                        options.action.handler();
                        toast.remove();
                    });
                    toast.appendChild(actionBtn);
                }
                this.container.appendChild(toast);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 250);
                }, options.duration || 4000);
            }
        }

        class ModalManager {
            constructor() {
                this.layer = document.getElementById('modal-layer');
            }

            open({ title, body, actions = [] }) {
                this.close();
                const modal = utils.createEl('div', 'modal');
                const header = utils.createEl('header', '', { text: title });
                const content = utils.createEl('main');
                if (body instanceof HTMLElement) content.appendChild(body); else content.innerHTML = body;
                const footer = utils.createEl('footer');
                actions.forEach(action => {
                    const btn = utils.createEl('button', action.primary ? 'btn-primary' : 'btn-secondary', { text: action.label });
                    btn.addEventListener('click', () => {
                        const shouldClose = action.onClick ? action.onClick() !== false : true;
                        if (shouldClose) this.close();
                    });
                    footer.appendChild(btn);
                });
                modal.append(header, content, footer);
                this.layer.appendChild(modal);
                this.layer.setAttribute('aria-hidden', 'false');
                return modal;
            }

            close() {
                this.layer.setAttribute('aria-hidden', 'true');
                this.layer.innerHTML = '';
            }
        }
        class WindowManager extends EventEmitter {
            constructor() {
                super();
                this.container = document.getElementById('window-layer');
                this.taskbar = document.getElementById('taskbar-apps');
                this.windows = new Map();
                this.zCounter = 10;
                this.activeWindowId = null;
            }

            create(appId, { title, icon, content, width = '720px', height = '520px', onClose, onFocus, onBlur }) {
                const id = `win-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                const windowEl = utils.createEl('div', 'window');
                windowEl.dataset.id = id;
                windowEl.dataset.appId = appId;
                windowEl.style.width = width;
                windowEl.style.height = height;
                windowEl.style.left = `${80 + Math.random() * 140}px`;
                windowEl.style.top = `${80 + Math.random() * 100}px`;
                windowEl.style.zIndex = ++this.zCounter;

                const header = utils.createEl('div', 'window-header');
                const controls = utils.createEl('div', 'window-controls');
                ['close', 'minimize', 'maximize'].forEach(role => {
                    const button = utils.createEl('button', 'window-control', { 'data-role': role });
                    controls.appendChild(button);
                });
                const titleEl = utils.createEl('div', 'window-title');
                const glyphText = icon || '🪟';
                const titleText = title || 'Window';
                const glyph = utils.createEl('span', 'glyph', { text: glyphText });
                const label = utils.createEl('span', '', { text: titleText });
                titleEl.append(glyph, label);
                const headerFiller = utils.createEl('div', 'window-header-filler');
                header.append(controls, titleEl, headerFiller);

                const contentContainer = utils.createEl('div', 'window-content');
                if (content instanceof HTMLElement) contentContainer.appendChild(content);
                else contentContainer.innerHTML = content || '';

                windowEl.append(header, contentContainer);

                const resizeDirections = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
                resizeDirections.forEach(dir => {
                    const handle = utils.createEl('div', 'resize-handle');
                    handle.dataset.dir = dir;
                    windowEl.appendChild(handle);
                });

                this.attachEvents(windowEl);
                this.container.appendChild(windowEl);
                const taskbarItem = this.createTaskbarItem(id, appId, titleText, glyphText);

                const state = {
                    id,
                    appId,
                    element: windowEl,
                    content: contentContainer,
                    onClose,
                    onFocus,
                    onBlur,
                    minimized: false,
                    maximized: false,
                    previousBounds: null,
                    title: titleText,
                    icon: glyphText,
                    titleElement: label,
                    taskbarItem
                };
                this.windows.set(id, state);
                this.focus(id);
                this.emit('created', state);
                return state;
            }

            attachEvents(windowEl) {
                const id = windowEl.dataset.id;
                const header = windowEl.querySelector('.window-header');
                header.addEventListener('mousedown', event => this.startDrag(id, event));
                header.addEventListener('dblclick', () => this.toggleMaximize(id));
                windowEl.querySelector('[data-role="close"]').addEventListener('click', () => this.close(id));
                windowEl.querySelector('[data-role="minimize"]').addEventListener('click', () => this.minimize(id));
                windowEl.querySelector('[data-role="maximize"]').addEventListener('click', () => this.toggleMaximize(id));
                windowEl.addEventListener('mousedown', () => this.focus(id));
                windowEl.querySelectorAll('.resize-handle').forEach(handle => handle.addEventListener('mousedown', event => this.startResize(id, handle.dataset.dir, event)));
            }

            createTaskbarItem(id, appId, title, icon) {
                const item = utils.createEl('button', 'taskbar-item');
                item.dataset.windowId = id;
                item.setAttribute('aria-label', title);
                item.innerHTML = `<span class="glyph">${icon || '🪟'}</span><span>${title}</span>`;
                item.addEventListener('click', () => {
                    const state = this.windows.get(id);
                    if (!state) return;
                    if (state.minimized) this.restore(id);
                    else if (this.activeWindowId === id) this.minimize(id);
                    else this.focus(id);
                });
                this.taskbar.appendChild(item);
                return item;
            }

            updateTaskbarState(activeId) {
                this.taskbar.querySelectorAll('.taskbar-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.windowId === activeId);
                });
            }

            focus(id) {
                const state = this.windows.get(id);
                if (!state) return;
                this.windows.forEach(win => {
                    const active = win.id === id;
                    win.element.classList.toggle('active', active);
                    if (!active) win.onBlur?.(win);
                });
                state.element.style.display = 'flex';
                state.element.style.zIndex = ++this.zCounter;
                state.minimized = false;
                this.activeWindowId = id;
                this.updateTaskbarState(id);
                state.onFocus?.(state);
                this.emit('focus', state);
            }

            minimize(id) {
                const state = this.windows.get(id);
                if (!state) return;
                state.element.style.display = 'none';
                state.minimized = true;
                if (this.activeWindowId === id) this.activeWindowId = null;
                this.updateTaskbarState(null);
            }

            restore(id) {
                const state = this.windows.get(id);
                if (!state) return;
                state.element.style.display = 'flex';
                state.minimized = false;
                this.focus(id);
            }

            toggleMaximize(id) {
                const state = this.windows.get(id);
                if (!state) return;
                const el = state.element;
                if (!state.maximized) {
                    const rect = el.getBoundingClientRect();
                    state.previousBounds = { left: rect.left, top: rect.top, width: rect.width, height: rect.height };
                    el.style.left = '0px';
                    el.style.top = '0px';
                    el.style.width = '100%';
                    el.style.height = '100%';
                    state.maximized = true;
                } else {
                    const { left, top, width, height } = state.previousBounds || { left: 100, top: 100, width: 720, height: 520 };
                    el.style.left = `${left}px`;
                    el.style.top = `${top}px`;
                    el.style.width = `${width}px`;
                    el.style.height = `${height}px`;
                    state.maximized = false;
                }
                this.focus(id);
            }

            close(id) {
                const state = this.windows.get(id);
                if (!state) return;
                const shouldClose = state.onClose ? state.onClose(state) !== false : true;
                if (!shouldClose) return;
                state.element.remove();
                this.windows.delete(id);
                state.taskbarItem?.remove();
                if (this.activeWindowId === id) {
                    this.activeWindowId = null;
                    const next = Array.from(this.windows.keys()).pop();
                    if (next) this.focus(next);
                }
                this.emit('closed', state);
            }

            startDrag(id, event) {
                if (event.button !== 0) return;
                const state = this.windows.get(id);
                if (!state || state.maximized) return;
                this.focus(id);
                const el = state.element;
                const rect = el.getBoundingClientRect();
                const offsetX = event.clientX - rect.left;
                const offsetY = event.clientY - rect.top;
                const move = utils.throttle(moveEvent => {
                    el.style.left = `${moveEvent.clientX - offsetX}px`;
                    el.style.top = `${moveEvent.clientY - offsetY}px`;
                }, 16);
                const up = () => {
                    document.removeEventListener('mousemove', move);
                    document.removeEventListener('mouseup', up);
                };
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', up);
            }

            startResize(id, dir, event) {
                event.preventDefault();
                const state = this.windows.get(id);
                if (!state || state.maximized) return;
                const el = state.element;
                const rect = el.getBoundingClientRect();
                const startX = event.clientX;
                const startY = event.clientY;
                const startWidth = rect.width;
                const startHeight = rect.height;
                const startLeft = rect.left;
                const startTop = rect.top;
                const move = utils.throttle(moveEvent => {
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;
                    if (dir.includes('e')) el.style.width = `${Math.max(320, startWidth + dx)}px`;
                    if (dir.includes('s')) el.style.height = `${Math.max(220, startHeight + dy)}px`;
                    if (dir.includes('w')) {
                        const width = Math.max(320, startWidth - dx);
                        el.style.width = `${width}px`;
                        el.style.left = `${startLeft + dx}px`;
                    }
                    if (dir.includes('n')) {
                        const height = Math.max(220, startHeight - dy);
                        el.style.height = `${height}px`;
                        el.style.top = `${startTop + dy}px`;
                    }
                }, 16);
                const up = () => {
                    document.removeEventListener('mousemove', move);
                    document.removeEventListener('mouseup', up);
                };
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', up);
            }

            getWindows() {
                return Array.from(this.windows.values()).map(state => ({
                    id: state.id,
                    appId: state.appId,
                    title: state.titleElement?.textContent || state.title || 'Window',
                    minimized: state.minimized,
                    maximized: state.maximized
                }));
            }

            focusWindow(id) {
                if (this.windows.has(id)) this.focus(id);
            }

            minimizeAll() {
                this.windows.forEach((_, id) => this.minimize(id));
            }

            restoreAll() {
                let lastId = null;
                this.windows.forEach((state, id) => {
                    if (state.minimized) {
                        state.element.style.display = 'flex';
                        state.minimized = false;
                        lastId = id;
                    }
                });
                if (lastId) this.focus(lastId);
                else if (!this.activeWindowId && this.windows.size) {
                    const ids = Array.from(this.windows.keys());
                    this.focus(ids[ids.length - 1]);
                }
            }

            cycle() {
                const ids = Array.from(this.windows.keys());
                if (!ids.length) return;
                const currentIndex = ids.indexOf(this.activeWindowId);
                const nextIndex = (currentIndex + 1) % ids.length;
                this.focus(ids[nextIndex]);
            }
        }
        class DesktopManager {
            constructor(fileSystem, appManager, notifications, settings) {
                this.fileSystem = fileSystem;
                this.appManager = appManager;
                this.notifications = notifications;
                this.settings = settings;
                this.root = document.getElementById('desktop');
                this.canvas = document.getElementById('desktop-canvas');
                this.appsContainer = document.getElementById('desktop-apps');
                this.filesContainer = document.getElementById('desktop-files');
                this.windowLayer = document.getElementById('window-layer');
                this.workspace = this.canvas;
                this.contextMenu = document.getElementById('desktop-menu');
                this.iconMenu = document.getElementById('icon-menu');
                this.fileInput = document.getElementById('file-input');
                this.clipboard = null;
                this.selectedItems = new Set();
                this.lastFileSelectionIndex = null;
                this.activeAppContext = null;
                this.dockManager = null;
                this.layoutMode = settings?.state.desktopLayout || 'grid';
                this.workspaces = this.loadWorkspaces();
                this.activeWorkspaceId = this.workspaces.active || Object.keys(this.workspaces.items)[0];
                this.alignmentGuides = this.createAlignmentGuides();
                this.selectionOverlay = this.createSelectionOverlay();
                this.searchOverlay = this.createSearchOverlay();
                this.isLassoing = false;
                this.dragState = null;
                this.registerEvents();
                this.applyLayout();
                this.render();
                fileSystem.on('change', utils.debounce(() => this.render(), 120));
                this.scheduleCleanupCheck();
            }

            loadWorkspaces() {
                try {
                    const raw = localStorage.getItem('webos.desktop.workspaces.v1');
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (parsed && parsed.items && typeof parsed.items === 'object') {
                            return parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load workspaces', error);
                }
                return {
                    active: 'main',
                    items: {
                        main: {
                            id: 'main',
                            name: 'Main Desktop',
                            apps: [],
                            files: [],
                            positions: { apps: {}, files: {} }
                        }
                    }
                };
            }

            saveWorkspaces() {
                try {
                    localStorage.setItem('webos.desktop.workspaces.v1', JSON.stringify(this.workspaces));
                } catch (error) {
                    console.warn('Failed to save workspaces', error);
                }
            }

            getActiveWorkspace() {
                return this.workspaces.items[this.activeWorkspaceId] || this.workspaces.items[Object.keys(this.workspaces.items)[0]];
            }

            applyLayout() {
                document.body.dataset.desktopLayout = this.layoutMode;
            }

            createAlignmentGuides() {
                const vertical = utils.createEl('div', 'alignment-guide vertical hidden');
                const horizontal = utils.createEl('div', 'alignment-guide horizontal hidden');
                this.workspace.appendChild(vertical);
                this.workspace.appendChild(horizontal);
                return { vertical, horizontal };
            }

            createSelectionOverlay() {
                const overlay = utils.createEl('div', 'selection-overlay hidden');
                this.workspace.appendChild(overlay);
                return overlay;
            }

            createSearchOverlay() {
                const overlay = utils.createEl('div', 'desktop-search hidden');
                overlay.innerHTML = `
                    <div class="desktop-search-panel">
                        <input type="search" class="desktop-search-input" placeholder="Search apps and files" aria-label="Search" autocomplete="off" />
                        <ul class="desktop-search-results"></ul>
                    </div>`;
                document.body.appendChild(overlay);
                this.searchInput = overlay.querySelector('.desktop-search-input');
                this.searchResults = overlay.querySelector('.desktop-search-results');
                this.searchInput?.addEventListener('input', utils.debounce(() => this.performSearch(this.searchInput.value), 120));
                overlay.addEventListener('click', event => {
                    if (event.target === overlay) this.closeSearch();
                });
                this.searchInput?.addEventListener('keydown', event => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.closeSearch();
                    }
                    if (event.key === 'Enter') {
                        const first = this.searchResults.querySelector('li[data-id]');
                        if (first) this.activateSearchResult(first.dataset.id);
                    }
                });
                return overlay;
            }

            registerEvents() {
                this.workspace.addEventListener('contextmenu', event => {
                    if (event.target.closest('.desktop-icon')) return;
                    event.preventDefault();
                    this.hideIconMenu();
                    this.showContextMenu(event.clientX, event.clientY);
                });

                this.appsContainer.addEventListener('contextmenu', event => {
                    const icon = event.target.closest('.desktop-icon');
                    if (!icon) return;
                    event.preventDefault();
                    event.stopPropagation();
                    this.showIconMenu(icon.dataset.appId, event.clientX, event.clientY);
                });

                this.workspace.addEventListener('click', event => {
                    if (event.target.closest('.desktop-icon') || event.target.closest('.desktop-file') || event.target.closest('.window')) {
                        return;
                    }
                    this.hideIconMenu();
                    this.clearSelection();
                });

                document.addEventListener('click', event => {
                    if (!this.contextMenu.contains(event.target)) this.hideContextMenu();
                    if (!this.iconMenu.contains(event.target)) this.hideIconMenu();
                });

                this.contextMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button) return;
                    this.hideContextMenu();
                    const action = button.dataset.action;
                    switch (action) {
                        case 'new-file':
                            this.createDesktopFile();
                            break;
                        case 'new-folder':
                            this.createDesktopFolder();
                            break;
                        case 'paste':
                            this.pasteClipboard('/Desktop');
                            break;
                        case 'refresh':
                            this.render();
                            break;
                        case 'settings':
                            this.appManager.open('settings');
                            break;
                    }
                });

                this.iconMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button || !this.activeAppContext) return;
                    const action = button.dataset.action;
                    const appId = this.activeAppContext.id;
                    this.hideIconMenu();
                    switch (action) {
                        case 'app-open':
                            this.appManager.open(appId);
                            break;
                        case 'app-pin':
                            this.dockManager?.pin(appId);
                            break;
                        case 'app-unpin':
                            this.dockManager?.unpin(appId);
                            break;
                    }
                });

                this.workspace.addEventListener('dragover', event => event.preventDefault());
                this.workspace.addEventListener('drop', event => {
                    event.preventDefault();
                    const items = event.dataTransfer?.items;
                    if (!items) return;
                    const uploads = [];
                    for (const item of items) if (item.kind === 'file') uploads.push(item.getAsFile());
                    Promise.all(uploads.map(file => this.importFile('/Desktop', file))).then(() => this.render());
                });

                this.fileInput.addEventListener('change', () => {
                    const files = Array.from(this.fileInput.files || []);
                    Promise.all(files.map(file => this.importFile('/Desktop', file))).then(() => {
                        this.fileInput.value = '';
                        this.render();
                    });
                });

                this.workspace.addEventListener('pointerdown', event => this.handleWorkspacePointerDown(event));
                window.addEventListener('pointermove', event => this.handleWorkspacePointerMove(event));
                window.addEventListener('pointerup', () => this.handleWorkspacePointerUp());
            }

            showContextMenu(x, y) {
                const menuWidth = 220;
                const menuHeight = 180;
                this.contextMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.contextMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.contextMenu.setAttribute('aria-hidden', 'false');
            }

            hideContextMenu() {
                this.contextMenu.setAttribute('aria-hidden', 'true');
            }

            setDockManager(manager) {
                this.dockManager = manager;
                manager?.on?.('change', () => this.renderApps());
                this.renderApps();
            }

            showIconMenu(appId, x, y) {
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                if (!descriptor) return;
                this.activeAppContext = descriptor;
                const pinned = this.dockManager?.isPinned?.(appId);
                const pinBtn = this.iconMenu.querySelector('[data-action="app-pin"]');
                const unpinBtn = this.iconMenu.querySelector('[data-action="app-unpin"]');
                if (pinBtn) pinBtn.style.display = pinned ? 'none' : '';
                if (unpinBtn) unpinBtn.style.display = pinned ? '' : 'none';
                const menuWidth = 200;
                const menuHeight = 160;
                this.iconMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.iconMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.iconMenu.setAttribute('aria-hidden', 'false');
            }

            hideIconMenu() {
                this.iconMenu.setAttribute('aria-hidden', 'true');
                this.activeAppContext = null;
            }

            async importFile(targetDir, file) {
                if (!file) return;
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                try {
                    this.fileSystem.createFile(utils.join(targetDir, file.name), bytes, { mime: file.type || utils.mimeFromName(file.name) });
                    this.notifications.notify('File uploaded', `${file.name} saved to ${targetDir}`);
                } catch (error) {
                    this.notifications.notify('Upload failed', error.message);
                }
            }

            createDesktopFile() {
                const name = prompt('File name', 'New File.txt');
                if (!name) return;
                try {
                    this.fileSystem.createFile(`/Desktop/${name}`, '');
                    this.notifications.notify('File created', name);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            createDesktopFolder() {
                const name = prompt('Folder name', 'New Folder');
                if (!name) return;
                try {
                    this.fileSystem.createDirectory(`/Desktop/${name}`);
                    this.notifications.notify('Folder created', name);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            setClipboard(paths, mode) {
                this.clipboard = { paths, mode };
            }

            pasteClipboard(targetDir) {
                if (!this.clipboard) return;
                try {
                    for (const path of this.clipboard.paths) {
                        if (this.clipboard.mode === 'copy') this.fileSystem.copy(path, targetDir);
                        if (this.clipboard.mode === 'cut') this.fileSystem.move(path, targetDir);
                    }
                    if (this.clipboard.mode === 'cut') this.clipboard = null;
                    this.notifications.notify('Paste complete', `Items pasted into ${targetDir}`);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            render() {
                this.renderApps();
                this.renderDesktopFiles();
            }

            getSelectionPaths() {
                return this.getSelectedFiles();
            }

            copySelection() {
                const selection = this.getSelectionPaths();
                if (!selection.length) return false;
                this.setClipboard(selection, 'copy');
                this.notifications.notify('Copied', `${selection.length} item ready to paste`);
                return true;
            }

            cutSelection() {
                const selection = this.getSelectionPaths();
                if (!selection.length) return false;
                this.setClipboard(selection, 'cut');
                this.notifications.notify('Cut', `${selection.length} item ready to move`);
                return true;
            }

            clearSelection() {
                this.selectedItems.clear();
                this.refreshSelections();
            }

            refreshSelections() {
                this.appsContainer.querySelectorAll('.desktop-icon').forEach(icon => {
                    const key = this.encodeSelection('app', icon.dataset.appId);
                    icon.classList.toggle('active', this.selectedItems.has(key));
                });
                this.filesContainer.querySelectorAll('.desktop-file').forEach(row => {
                    const key = this.encodeSelection('file', row.dataset.path);
                    row.classList.toggle('active', this.selectedItems.has(key));
                });
            }

            encodeSelection(type, id) {
                return `${type}::${id}`;
            }

            getSelectedFiles() {
                const files = [];
                this.selectedItems.forEach(key => {
                    if (key.startsWith('file::')) files.push(key.slice(6));
                });
                return files;
            }

            handleAppClick(event, app, element) {
                event.stopPropagation();
                const key = this.encodeSelection('app', app.id);
                if (event.metaKey || event.ctrlKey) {
                    if (this.selectedItems.has(key)) this.selectedItems.delete(key); else this.selectedItems.add(key);
                } else {
                    this.selectedItems.clear();
                    this.selectedItems.add(key);
                }
                this.refreshSelections();
            }

            handleFileClick(event, entry, index, row) {
                event.stopPropagation();
                const key = this.encodeSelection('file', entry.path);
                if (event.shiftKey && this.lastFileSelectionIndex !== null && Array.isArray(this.desktopEntries)) {
                    const start = Math.min(this.lastFileSelectionIndex, index);
                    const end = Math.max(this.lastFileSelectionIndex, index);
                    this.selectedItems.clear();
                    for (let i = start; i <= end; i += 1) {
                        const item = this.desktopEntries[i];
                        if (!item) continue;
                        this.selectedItems.add(this.encodeSelection('file', item.path));
                    }
                } else if (event.metaKey || event.ctrlKey) {
                    if (this.selectedItems.has(key)) this.selectedItems.delete(key); else this.selectedItems.add(key);
                    this.lastFileSelectionIndex = index;
                } else {
                    this.selectedItems.clear();
                    this.selectedItems.add(key);
                    this.lastFileSelectionIndex = index;
                }
                this.refreshSelections();
            }

            beginIconDrag(event, payload, element) {
                if (event.button !== 0 || this.layoutMode !== 'freeform') return;
                event.preventDefault();
                const initialLeft = parseFloat(element.style.left || '0');
                const initialTop = parseFloat(element.style.top || '0');
                this.dragState = {
                    payload,
                    element,
                    startX: event.clientX,
                    startY: event.clientY,
                    initialLeft,
                    initialTop,
                    pointerId: event.pointerId
                };
                this.onIconDragMove = evt => this.handleIconDragMove(evt);
                this.onIconDragEnd = evt => this.handleIconDragEnd(evt);
                element.setPointerCapture?.(event.pointerId);
                element.addEventListener('pointermove', this.onIconDragMove);
                element.addEventListener('pointerup', this.onIconDragEnd);
                element.addEventListener('pointercancel', this.onIconDragEnd);
            }

            handleIconDragMove(event) {
                if (!this.dragState) return;
                const { element, startX, startY, initialLeft, initialTop } = this.dragState;
                const deltaX = event.clientX - startX;
                const deltaY = event.clientY - startY;
                const left = Math.max(0, initialLeft + deltaX);
                const top = Math.max(0, initialTop + deltaY);
                element.style.left = `${left}px`;
                element.style.top = `${top}px`;
                this.updateAlignmentGuides(left, top, element);
            }

            handleIconDragEnd(event) {
                if (!this.dragState) return;
                const { element, payload } = this.dragState;
                element.releasePointerCapture?.(event.pointerId || this.dragState.pointerId);
                element.removeEventListener('pointermove', this.onIconDragMove);
                element.removeEventListener('pointerup', this.onIconDragEnd);
                element.removeEventListener('pointercancel', this.onIconDragEnd);
                this.hideAlignmentGuides();
                const left = Math.max(0, parseFloat(element.style.left || '0'));
                const top = Math.max(0, parseFloat(element.style.top || '0'));
                const workspace = this.getActiveWorkspace();
                workspace.positions = workspace.positions || { apps: {}, files: {} };
                if (!workspace.positions.apps) workspace.positions.apps = {};
                workspace.positions.apps[payload.id] = { x: left, y: top };
                this.saveWorkspaces();
                this.dragState = null;
            }

            updateAlignmentGuides(left, top, element) {
                if (!this.alignmentGuides) return;
                const threshold = 12;
                let verticalShown = false;
                let horizontalShown = false;
                const centerX = left + element.offsetWidth / 2;
                const centerY = top + element.offsetHeight / 2;
                this.appsContainer.querySelectorAll('.desktop-icon.freeform').forEach(icon => {
                    if (icon === element) return;
                    const otherLeft = parseFloat(icon.style.left || '0');
                    const otherTop = parseFloat(icon.style.top || '0');
                    const otherCenterX = otherLeft + icon.offsetWidth / 2;
                    const otherCenterY = otherTop + icon.offsetHeight / 2;
                    if (Math.abs(otherCenterX - centerX) <= threshold) {
                        verticalShown = true;
                        this.alignmentGuides.vertical.classList.remove('hidden');
                        this.alignmentGuides.vertical.style.left = `${otherCenterX}px`;
                    }
                    if (Math.abs(otherCenterY - centerY) <= threshold) {
                        horizontalShown = true;
                        this.alignmentGuides.horizontal.classList.remove('hidden');
                        this.alignmentGuides.horizontal.style.top = `${otherCenterY}px`;
                    }
                });
                if (!verticalShown) this.alignmentGuides.vertical.classList.add('hidden');
                if (!horizontalShown) this.alignmentGuides.horizontal.classList.add('hidden');
            }

            hideAlignmentGuides() {
                if (!this.alignmentGuides) return;
                this.alignmentGuides.vertical.classList.add('hidden');
                this.alignmentGuides.horizontal.classList.add('hidden');
            }

            handleWorkspacePointerDown(event) {
                if (event.button !== 0) return;
                if (event.target.closest('.desktop-icon') || event.target.closest('.desktop-file') || event.target.closest('.window')) return;
                this.hideIconMenu();
                const rect = this.canvas.getBoundingClientRect();
                this.isLassoing = true;
                this.lassoOrigin = { x: event.clientX, y: event.clientY };
                this.selectionOverlay.classList.remove('hidden');
                this.selectionOverlay.style.left = `${this.lassoOrigin.x - rect.left}px`;
                this.selectionOverlay.style.top = `${this.lassoOrigin.y - rect.top}px`;
                this.selectionOverlay.style.width = '0px';
                this.selectionOverlay.style.height = '0px';
                this.selectedItems.clear();
                this.refreshSelections();
            }

            handleWorkspacePointerMove(event) {
                if (!this.isLassoing) return;
                const rect = this.canvas.getBoundingClientRect();
                const currentX = Math.min(Math.max(event.clientX, rect.left), rect.right);
                const currentY = Math.min(Math.max(event.clientY, rect.top), rect.bottom);
                const minX = Math.min(this.lassoOrigin.x, currentX);
                const minY = Math.min(this.lassoOrigin.y, currentY);
                const width = Math.abs(currentX - this.lassoOrigin.x);
                const height = Math.abs(currentY - this.lassoOrigin.y);
                this.selectionOverlay.style.left = `${minX - rect.left}px`;
                this.selectionOverlay.style.top = `${minY - rect.top}px`;
                this.selectionOverlay.style.width = `${width}px`;
                this.selectionOverlay.style.height = `${height}px`;
                this.updateLassoSelection({ left: minX, top: minY, right: minX + width, bottom: minY + height });
            }

            handleWorkspacePointerUp() {
                if (!this.isLassoing) return;
                this.isLassoing = false;
                this.selectionOverlay.classList.add('hidden');
                this.selectionOverlay.style.width = '0px';
                this.selectionOverlay.style.height = '0px';
                this.refreshSelections();
            }

            updateLassoSelection(bounds) {
                const selected = new Set();
                this.appsContainer.querySelectorAll('.desktop-icon').forEach(icon => {
                    const rect = icon.getBoundingClientRect();
                    if (this.rectIntersects(bounds, rect)) selected.add(this.encodeSelection('app', icon.dataset.appId));
                });
                this.filesContainer.querySelectorAll('.desktop-file').forEach(row => {
                    const rect = row.getBoundingClientRect();
                    if (this.rectIntersects(bounds, rect)) selected.add(this.encodeSelection('file', row.dataset.path));
                });
                this.selectedItems = selected;
                this.refreshSelections();
            }

            rectIntersects(a, b) {
                return !(b.left > a.right || b.right < a.left || b.top > a.bottom || b.bottom < a.top);
            }

            openSearch() {
                if (!this.searchOverlay) return;
                this.searchOverlay.classList.remove('hidden');
                this.performSearch('');
                setTimeout(() => this.searchInput?.focus({ preventScroll: true }), 10);
            }

            closeSearch() {
                if (!this.searchOverlay) return;
                this.searchOverlay.classList.add('hidden');
                if (this.searchResults) this.searchResults.innerHTML = '';
            }

            performSearch(rawQuery) {
                if (!this.searchResults) return;
                const query = (rawQuery || '').trim().toLowerCase();
                this.searchResults.innerHTML = '';
                if (!query) return;
                const fragment = document.createDocumentFragment();
                const workspace = this.getActiveWorkspace();
                const allowedApps = workspace?.apps || [];
                const includeAll = !allowedApps.length;
                const allowedSet = new Set(allowedApps);
                APP_CATALOG.forEach(app => {
                    if (!includeAll && !allowedSet.has(app.id)) return;
                    const haystack = `${app.name} ${app.hint}`.toLowerCase();
                    if (!haystack.includes(query)) return;
                    const li = utils.createEl('li', 'search-result');
                    li.dataset.id = `app:${app.id}`;
                    li.innerHTML = `<strong>${app.name}</strong><span>${app.hint || ''}</span>`;
                    li.addEventListener('click', () => this.activateSearchResult(li.dataset.id));
                    fragment.appendChild(li);
                });
                const matches = this.fileSystem.search(query).slice(0, 20);
                matches.forEach(match => {
                    const li = utils.createEl('li', 'search-result');
                    li.dataset.id = `file:${match.path}`;
                    li.innerHTML = `<strong>${match.name}</strong><span>${match.path}</span>`;
                    li.addEventListener('click', () => this.activateSearchResult(li.dataset.id));
                    fragment.appendChild(li);
                });
                this.searchResults.appendChild(fragment);
            }

            activateSearchResult(id) {
                if (!id) return;
                const [type, ...rest] = id.split(':');
                const value = rest.join(':');
                if (type === 'app') {
                    this.appManager.open(value);
                } else if (type === 'file') {
                    try {
                        const meta = this.fileSystem.readFileMeta(value);
                        this.appManager.openByFile(value, meta.mime);
                    } catch (error) {
                        this.notifications.notify('Desktop Search', error.message || 'Unable to open file');
                    }
                }
                this.closeSearch();
            }

            switchWorkspace(id) {
                if (!id || !this.workspaces.items[id]) return;
                this.activeWorkspaceId = id;
                this.workspaces.active = id;
                this.saveWorkspaces();
                this.selectedItems.clear();
                this.applyLayout();
                this.render();
            }

            createWorkspace(name = 'Workspace') {
                const base = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'workspace';
                let id = base;
                let counter = 2;
                while (this.workspaces.items[id]) id = `${base}-${counter++}`;
                this.workspaces.items[id] = {
                    id,
                    name,
                    apps: [],
                    files: [],
                    positions: { apps: {}, files: {} }
                };
                this.switchWorkspace(id);
                this.saveWorkspaces();
                return id;
            }

            assignSelectedToWorkspace(id) {
                const workspace = this.workspaces.items[id];
                if (!workspace) return;
                workspace.apps = workspace.apps || [];
                workspace.files = workspace.files || [];
                const appSet = new Set(workspace.apps);
                const fileSet = new Set(workspace.files);
                this.selectedItems.forEach(key => {
                    if (key.startsWith('app::')) appSet.add(key.slice(5));
                    if (key.startsWith('file::')) fileSet.add(key.slice(6));
                });
                workspace.apps = Array.from(appSet);
                workspace.files = Array.from(fileSet);
                this.saveWorkspaces();
                if (id === this.activeWorkspaceId) this.render();
            }

            handleSettingsChange(state) {
                if (!state) return;
                if (state.desktopLayout && state.desktopLayout !== this.layoutMode) {
                    this.layoutMode = state.desktopLayout;
                    this.applyLayout();
                }
            }

            stackSelectedFiles() {
                const files = this.getSelectedFiles();
                if (files.length < 2) {
                    this.notifications.notify('Desktop', 'Select two or more files to stack.');
                    return;
                }
                const name = prompt('New folder name', 'Stacked Files');
                if (!name) return;
                const targetDir = `/Desktop/${name}`;
                try {
                    if (!this.fileSystem.exists(targetDir)) this.fileSystem.createDirectory(targetDir);
                    files.forEach(path => this.fileSystem.move(path, targetDir));
                    this.notifications.notify('Desktop', `${files.length} items moved to ${name}.`);
                    this.selectedItems.clear();
                    this.render();
                } catch (error) {
                    this.notifications.notify('Desktop', error.message || 'Unable to stack files.');
                }
            }

            promptWorkspaceSwitch() {
                const entries = Object.values(this.workspaces.items).map(ws => `${ws.id}: ${ws.name}`);
                const choice = prompt(`Switch to workspace:\n${entries.join('\n')}`);
                if (!choice) return;
                const trimmed = choice.trim().toLowerCase();
                const match = Object.values(this.workspaces.items).find(ws => ws.id === trimmed || ws.name.toLowerCase() === trimmed);
                if (match) this.switchWorkspace(match.id);
                else this.notifications.notify('Desktop', 'Workspace not found.');
            }

            promptAssignWorkspace() {
                if (!this.selectedItems.size) {
                    this.notifications.notify('Desktop', 'Select items to assign to a workspace.');
                    return;
                }
                const entries = Object.values(this.workspaces.items).map(ws => `${ws.id}: ${ws.name}`);
                const choice = prompt(`Assign selection to workspace:\n${entries.join('\n')}`);
                if (!choice) return;
                const trimmed = choice.trim().toLowerCase();
                const match = Object.values(this.workspaces.items).find(ws => ws.id === trimmed || ws.name.toLowerCase() === trimmed);
                if (!match) {
                    this.notifications.notify('Desktop', 'Workspace not found.');
                    return;
                }
                this.assignSelectedToWorkspace(match.id);
                this.notifications.notify('Desktop', `Selection assigned to ${match.name}.`);
            }

            smartCleanDesktop() {
                const entries = this.fileSystem.listDirectory('/Desktop');
                const now = Date.now();
                const threshold = 21 * 24 * 60 * 60 * 1000;
                const stale = entries.filter(entry => entry.type === 'file' && entry.updatedAt && now - new Date(entry.updatedAt).getTime() > threshold);
                if (!stale.length) {
                    this.notifications.notify('Desktop', 'No stale files detected.');
                    return;
                }
                const archiveDir = '/Desktop/Archive';
                if (!this.fileSystem.exists(archiveDir)) this.fileSystem.createDirectory(archiveDir);
                stale.forEach(entry => {
                    try {
                        this.fileSystem.move(entry.path, archiveDir);
                    } catch (error) {
                        console.warn('Failed to move file during cleanup', error);
                    }
                });
                this.notifications.notify('Desktop', `Moved ${stale.length} items to Archive.`);
                this.render();
            }

            scheduleCleanupCheck() {
                try {
                    const key = 'webos.desktop.clean.timestamp';
                    const last = Number(localStorage.getItem(key) || 0);
                    if (Date.now() - last < 24 * 60 * 60 * 1000) return;
                    const entries = this.fileSystem.listDirectory('/Desktop');
                    const stale = entries.filter(entry => entry.type === 'file' && entry.updatedAt && Date.now() - new Date(entry.updatedAt).getTime() > 21 * 24 * 60 * 60 * 1000);
                    if (stale.length) {
                        this.notifications.notify('Desktop Cleanup', `${stale.length} items look unused.`, {
                            action: {
                                label: 'Clean now',
                                handler: () => this.smartCleanDesktop()
                            }
                        });
                    }
                    localStorage.setItem(key, String(Date.now()));
                } catch (error) {
                    console.warn('Cleanup suggestion failed', error);
                }
            }

            renderApps() {
                this.hideIconMenu();
                this.appsContainer.innerHTML = '';
                const workspace = this.getActiveWorkspace();
                const allowedApps = workspace?.apps || [];
                const includeAll = !allowedApps.length;
                const allowedSet = new Set(allowedApps);
                const layoutFreeform = this.layoutMode === 'freeform';
                const positions = workspace?.positions?.apps || {};
                const apps = APP_CATALOG.slice();
                apps.forEach((app, index) => {
                    if (!includeAll && !allowedSet.has(app.id)) return;
                    const icon = utils.createEl('div', 'desktop-icon');
                    icon.setAttribute('aria-label', app.name);
                    icon.dataset.appId = app.id;
                    if (layoutFreeform) {
                        icon.classList.add('freeform');
                        icon.style.position = 'absolute';
                        const fallback = { x: (index % 6) * 120, y: Math.floor(index / 6) * 120 };
                        const position = positions[app.id] || fallback;
                        icon.style.left = `${position.x}px`;
                        icon.style.top = `${position.y}px`;
                    } else {
                        icon.style.removeProperty('left');
                        icon.style.removeProperty('top');
                        icon.style.removeProperty('position');
                    }
                    const glyph = utils.createEl('div', 'glyph', { text: app.icon });
                    const label = utils.createEl('div', 'icon-label');
                    label.innerHTML = `<strong>${app.name}</strong><span>${app.hint}</span>`;
                    icon.append(glyph, label);
                    const key = this.encodeSelection('app', app.id);
                    icon.classList.toggle('active', this.selectedItems.has(key));
                    if (this.dockManager?.isPinned?.(app.id)) icon.classList.add('pinned'); else icon.classList.remove('pinned');
                    icon.addEventListener('click', event => this.handleAppClick(event, app, icon));
                    icon.addEventListener('dblclick', () => this.appManager.open(app.id));
                    icon.addEventListener('contextmenu', event => {
                        event.preventDefault();
                        event.stopPropagation();
                        this.showIconMenu(app.id, event.clientX, event.clientY);
                    });
                    if (layoutFreeform) {
                        icon.addEventListener('pointerdown', event => this.beginIconDrag(event, { type: 'app', id: app.id }, icon));
                    }
                    this.appsContainer.appendChild(icon);
                });
            }

            renderDesktopFiles() {
                this.filesContainer.innerHTML = '';
                const entries = this.fileSystem.listDirectory('/Desktop');
                this.desktopEntries = entries;
                if (!entries.length) {
                    const emptyState = utils.createEl('div', 'desktop-file');
                    emptyState.classList.add('empty');
                    emptyState.innerHTML = '<div class="file-glyph">🗂️</div><div class="file-info"><strong>No files yet</strong><span>Drag files here or create a new item.</span></div>';
                    emptyState.style.pointerEvents = 'none';
                    this.filesContainer.appendChild(emptyState);
                    return;
                }
                entries.forEach((entry, index) => {
                    const row = utils.createEl('div', 'desktop-file');
                    row.dataset.path = entry.path;
                    row.dataset.type = entry.type;
                    row.setAttribute('aria-label', entry.name);
                    const glyph = utils.createEl('div', 'file-glyph', { text: entry.type === 'directory' ? '📁' : '📄' });
                    const info = utils.createEl('div', 'file-info');
                    info.innerHTML = `<strong>${entry.name}</strong><span>${entry.type === 'directory' ? 'Folder' : entry.mime} · ${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size)}</span>`;
                    row.append(glyph, info);
                    const key = this.encodeSelection('file', entry.path);
                    row.classList.toggle('active', this.selectedItems.has(key));
                    row.addEventListener('click', event => this.handleFileClick(event, entry, index, row));
                    row.addEventListener('dblclick', () => {
                        if (entry.type === 'directory') this.appManager.open('toastsearcher', { path: entry.path });
                        else this.appManager.openByFile(entry.path, entry.mime);
                    });
                    this.filesContainer.appendChild(row);
                });
            }
        }

        class DockManager extends EventEmitter {
            constructor(appManager, windowManager, notifications, settings, categoryManager) {
                super();
                this.appManager = appManager;
                this.windowManager = windowManager;
                this.notifications = notifications;
                this.settings = settings;
                this.categoryManager = categoryManager;
                this.storageKey = 'webos.dock.pins.v1';
                this.element = document.getElementById('dock');
                this.menu = document.getElementById('dock-menu');
                this.taskbar = document.getElementById('taskbar');
                this.pins = this.load();
                this.running = new Map();
                this.activeAppId = null;
                this.menuTarget = null;
                this.menuActions = new Map();
                this.autoHide = settings?.state.dockAutoHide ?? false;
                this.smartSizing = settings?.state.dockSmartSizing !== false;
                this.predictivePinning = settings?.state.dockPredictivePinning !== false;
                this.groupedView = settings?.state.dockGroupedView ?? false;
                this.autoHideTimer = null;
                this.mouseMoveHandler = event => this.handleMouseMove(event);
                this.mouseMoveActive = false;
                this.dockHover = false;
                this.recentLaunches = new Map();
                this.render();
                this.attachEvents();
                this.updateAutohideListeners();
                windowManager.on('created', state => this.handleCreated(state));
                windowManager.on('closed', state => this.handleClosed(state));
                windowManager.on('focus', state => this.markActive(state.appId));
                settings?.setDockController?.(this);
            }

            load() {
                try {
                    const raw = localStorage.getItem(this.storageKey);
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (Array.isArray(parsed) && parsed.length) return parsed;
                    }
                } catch (error) {
                    console.warn('Failed to load dock pins', error);
                }
                return ['browser', 'toastsearcher', 'tasks', 'netflix', 'spotify'];
            }

            save() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.pins));
            }

            isPinned(id) {
                return this.pins.includes(id);
            }

            pin(id, options = {}) {
                if (!id || this.isPinned(id)) return;
                this.pins.push(id);
                this.save();
                this.render();
                if (!options.silent) {
                    const message = options.reason === 'predictive'
                        ? 'Pinned to dock based on recent activity.'
                        : 'Pinned to dock.';
                    this.notifications?.notify('Dock', message);
                }
                this.emit('change', this.pins.slice());
            }

            unpin(id) {
                if (!id) return;
                this.pins = this.pins.filter(pin => pin !== id);
                this.save();
                this.render();
                this.notifications?.notify('Dock', 'Removed from dock.');
                this.emit('change', this.pins.slice());
            }

            openApp(id) {
                if (!id) return;
                try {
                    this.appManager.open(id);
                } catch (error) {
                    this.notifications?.notify('Dock', error.message || 'Unable to open application.');
                }
            }

            render() {
                this.element.innerHTML = '';
                const groups = this.buildGroups();
                let totalIcons = 0;
                groups.forEach(group => {
                    let host = this.element;
                    if (this.groupedView) {
                        const wrapper = utils.createEl('div', 'dock-group');
                        if (group.name) {
                            const label = utils.createEl('span', 'dock-group-label', { text: group.name });
                            wrapper.appendChild(label);
                        }
                        host = utils.createEl('div', 'dock-group-items');
                        wrapper.appendChild(host);
                        this.element.appendChild(wrapper);
                    }
                    group.pins.forEach(id => {
                        const button = this.createDockButton(id);
                        if (!button) return;
                        host.appendChild(button);
                        totalIcons += 1;
                    });
                });
                this.updateIndicators();
                this.applySmartSizing(totalIcons);
            }

            buildGroups() {
                if (!this.groupedView || !this.categoryManager) {
                    return [{ id: 'default', name: '', pins: this.pins.slice() }];
                }
                const rootOrder = this.categoryManager.getChildOrder(null);
                const groups = new Map();
                this.pins.forEach(id => {
                    const categoryId = this.categoryManager.getCategoryForApp(id);
                    const path = this.categoryManager.getCategoryPath(categoryId);
                    const root = path[0];
                    const key = root?.id || 'other';
                    if (!groups.has(key)) {
                        groups.set(key, { id: key, name: root?.name || 'Other', accent: root?.accent, pins: [] });
                    }
                    groups.get(key).pins.push(id);
                });
                const ordered = [];
                rootOrder.forEach(rootId => {
                    if (groups.has(rootId)) {
                        ordered.push(groups.get(rootId));
                        groups.delete(rootId);
                    }
                });
                if (groups.has('other')) {
                    ordered.push(groups.get('other'));
                    groups.delete('other');
                }
                groups.forEach(group => ordered.push(group));
                return ordered.length ? ordered : [{ id: 'default', name: '', pins: this.pins.slice() }];
            }

            createDockButton(id) {
                const descriptor = APP_CATALOG.find(app => app.id === id);
                if (!descriptor) return null;
                const button = utils.createEl('button', 'dock-item');
                button.dataset.appId = id;
                button.title = descriptor.name;
                const glyph = utils.createEl('span', 'glyph', { text: descriptor.icon });
                button.appendChild(glyph);
                if (this.running.get(id)) button.classList.add('running');
                if (this.activeAppId === id) button.classList.add('active');
                button.addEventListener('click', () => this.openApp(id));
                button.addEventListener('contextmenu', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.showMenu(button, id, event.clientX, event.clientY);
                });
                return button;
            }

            applySmartSizing(count) {
                if (!this.smartSizing) {
                    this.element.style.removeProperty('--dock-icon-size');
                    return;
                }
                if (!count) {
                    this.element.style.removeProperty('--dock-icon-size');
                    return;
                }
                const base = 64;
                const min = 44;
                const size = Math.max(min, Math.min(base, base - Math.max(0, count - 5) * 3));
                this.element.style.setProperty('--dock-icon-size', `${Math.round(size)}px`);
            }

            attachEvents() {
                document.addEventListener('click', event => {
                    if (!this.menu.contains(event.target)) this.hideMenu();
                });
                document.addEventListener('keydown', event => {
                    if (event.key === 'Escape') this.hideMenu();
                });
                this.menu.addEventListener('click', event => {
                    const button = event.target.closest('button[data-action-key]');
                    if (!button) return;
                    const handler = this.menuActions.get(button.dataset.actionKey);
                    this.hideMenu();
                    handler?.();
                });
                this.element.addEventListener('mouseenter', () => {
                    this.dockHover = true;
                    this.showDock();
                });
                this.element.addEventListener('mouseleave', () => {
                    this.dockHover = false;
                    this.scheduleHide();
                });
            }

            applyPreferences(state) {
                if (!state) return;
                this.autoHide = Boolean(state.dockAutoHide);
                this.smartSizing = state.dockSmartSizing !== false;
                this.predictivePinning = state.dockPredictivePinning !== false;
                this.groupedView = Boolean(state.dockGroupedView);
                this.updateAutohideListeners();
                this.render();
            }

            updateAutohideListeners() {
                if (this.autoHide) {
                    if (!this.mouseMoveActive) {
                        window.addEventListener('mousemove', this.mouseMoveHandler, { passive: true });
                        this.mouseMoveActive = true;
                    }
                    this.showDock(true);
                    this.scheduleHide();
                } else if (this.mouseMoveActive) {
                    window.removeEventListener('mousemove', this.mouseMoveHandler);
                    this.mouseMoveActive = false;
                    this.showDock(true);
                    if (this.autoHideTimer) {
                        clearTimeout(this.autoHideTimer);
                        this.autoHideTimer = null;
                    }
                } else {
                    this.showDock(true);
                }
            }

            showDock(force = false) {
                if (this.taskbar) this.taskbar.classList.add('dock-visible');
                if (this.autoHideTimer) {
                    clearTimeout(this.autoHideTimer);
                    this.autoHideTimer = null;
                }
            }

            hideDock() {
                if (!this.autoHide) return;
                if (this.taskbar) this.taskbar.classList.remove('dock-visible');
            }

            scheduleHide(delay = 1800) {
                if (!this.autoHide) return;
                if (this.autoHideTimer) clearTimeout(this.autoHideTimer);
                this.autoHideTimer = setTimeout(() => {
                    if (!this.dockHover) this.hideDock();
                }, delay);
            }

            handleMouseMove(event) {
                if (!this.autoHide) return;
                const position = document.body.dataset.taskbar || 'bottom';
                const threshold = 90;
                const nearEdge = position === 'top'
                    ? event.clientY <= threshold
                    : window.innerHeight - event.clientY <= threshold;
                if (nearEdge) {
                    this.showDock();
                } else if (!this.dockHover) {
                    this.scheduleHide();
                }
            }

            showMenu(target, appId, x, y) {
                this.menuTarget = target;
                this.menuActions.clear();
                this.menu.innerHTML = '';
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const context = { appId, descriptor, appManager: this.appManager, dockManager: this };
                const quickActions = DOCK_QUICK_ACTIONS[appId] || [];
                if (quickActions.length) {
                    this.addMenuLabel('Quick Actions');
                    quickActions.forEach(action => this.addMenuButton(action.label, () => action.handler(context)));
                    this.addMenuSeparator();
                }
                const jumpList = DOCK_JUMP_LISTS[appId] || [];
                if (jumpList.length) {
                    this.addMenuLabel('Jump List');
                    jumpList.forEach(item => this.addMenuButton(item.label, () => item.handler(context)));
                    this.addMenuSeparator();
                }
                const recents = (this.recentLaunches.get(appId) || []).slice(-3).reverse();
                if (recents.length) {
                    this.addMenuLabel('Recent Activity');
                    recents.forEach(timestamp => {
                        const relative = utils.relativeTime(new Date(timestamp));
                        this.addMenuButton(relative, null, { disabled: true });
                    });
                    this.addMenuSeparator();
                }
                const windows = this.windowManager.getWindows().filter(win => win.appId === appId);
                if (windows.length) {
                    this.addMenuLabel('Running Windows');
                    windows.forEach(win => {
                        const title = win.title || 'Window';
                        this.addMenuButton(`Focus ${title}`, () => this.windowManager.focusWindow(win.id));
                        this.addMenuButton(`Close ${title}`, () => this.windowManager.close?.(win.id));
                    });
                    this.addMenuSeparator();
                }
                this.addMenuLabel('Dock');
                this.addMenuButton('Open', () => this.openApp(appId));
                if (this.isPinned(appId)) {
                    this.addMenuButton('Unpin from Dock', () => this.unpin(appId));
                } else {
                    this.addMenuButton('Pin to Dock', () => this.pin(appId));
                }
                if (windows.length) {
                    this.addMenuButton('Close All Windows', () => {
                        this.windowManager.getWindows().filter(win => win.appId === appId).forEach(win => this.windowManager.close?.(win.id));
                    });
                }
                const separators = this.menu.querySelectorAll('.menu-separator');
                if (separators.length && separators[separators.length - 1].nextSibling === null) {
                    separators[separators.length - 1].remove();
                }
                this.menu.setAttribute('aria-hidden', 'false');
                requestAnimationFrame(() => {
                    const rect = this.menu.getBoundingClientRect();
                    const width = rect.width || 200;
                    const height = rect.height || 160;
                    const left = Math.min(x, window.innerWidth - width - 8);
                    const top = Math.min(y, window.innerHeight - height - 8);
                    this.menu.style.left = `${left}px`;
                    this.menu.style.top = `${top}px`;
                });
            }

            addMenuLabel(text) {
                if (!text) return;
                this.menu.appendChild(utils.createEl('div', 'context-menu-label', { text }));
            }

            addMenuSeparator() {
                this.menu.appendChild(utils.createEl('div', 'menu-separator'));
            }

            addMenuButton(label, handler, options = {}) {
                const button = utils.createEl('button');
                if (options.hint) {
                    button.innerHTML = `<span>${label}</span><span class="menu-shortcut">${options.hint}</span>`;
                } else {
                    button.textContent = label;
                }
                if (options.disabled) {
                    button.disabled = true;
                } else if (handler) {
                    const key = `${label}-${Math.random().toString(16).slice(2)}`;
                    button.dataset.actionKey = key;
                    this.menuActions.set(key, handler);
                }
                this.menu.appendChild(button);
            }

            hideMenu() {
                this.menu.setAttribute('aria-hidden', 'true');
                this.menu.innerHTML = '';
                this.menuActions.clear();
                this.menuTarget = null;
            }

            handleCreated(state) {
                if (!state?.appId) return;
                this.running.set(state.appId, (this.running.get(state.appId) || 0) + 1);
                this.updateIndicators();
            }

            handleClosed(state) {
                if (!state?.appId) return;
                const count = (this.running.get(state.appId) || 1) - 1;
                if (count <= 0) this.running.delete(state.appId); else this.running.set(state.appId, count);
                if (this.activeAppId === state.appId && count <= 0) this.activeAppId = null;
                this.updateIndicators();
            }

            markActive(appId) {
                this.activeAppId = appId;
                this.updateIndicators();
            }

            updateIndicators() {
                this.element.querySelectorAll('.dock-item').forEach(item => {
                    const id = item.dataset.appId;
                    if (!id) return;
                    item.classList.toggle('running', this.running.has(id));
                    item.classList.toggle('active', this.activeAppId === id);
                });
            }

            handleAppUsage(appId) {
                this.recordRecent(appId);
                if (!this.predictivePinning || this.isPinned(appId)) return;
                const usage = this.categoryManager?.getAppUsage?.(appId);
                if (!usage) return;
                if (usage.count >= 4) {
                    this.pin(appId, { reason: 'predictive' });
                }
            }

            recordRecent(appId) {
                const list = this.recentLaunches.get(appId) || [];
                list.push(Date.now());
                if (list.length > 5) list.shift();
                this.recentLaunches.set(appId, list);
            }
        }

        class MenuManager {
            constructor(deps) {
                this.deps = deps;
                this.dropdown = utils.createEl('div', 'menu-dropdown', { 'aria-hidden': 'true' });
                document.body.appendChild(this.dropdown);
                this.activeMenu = null;
                this.anchorButton = null;
                document.addEventListener('click', (event) => {
                    if (!this.dropdown.contains(event.target)) this.hide();
                });
            }

            attach(button, menuId) {
                button.setAttribute('aria-haspopup', 'true');
                button.setAttribute('aria-expanded', 'false');
                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (this.activeMenu === menuId) this.hide(); else this.show(menuId, button);
                });
            }

            show(menuId, button) {
                this.deps.startMenu?.hide?.();
                this.dropdown.innerHTML = '';
                const items = this.getItems(menuId);
                items.forEach(item => {
                    if (item.type === 'separator') {
                        this.dropdown.appendChild(utils.createEl('div', 'menu-separator'));
                        return;
                    }
                    const btn = utils.createEl('button');
                    btn.textContent = item.label;
                    if (item.shortcut) {
                        btn.appendChild(utils.createEl('span', 'menu-shortcut', { text: item.shortcut }));
                    }
                    if (item.disabled) {
                        btn.disabled = true;
                    } else {
                        btn.addEventListener('click', () => {
                            this.hide();
                            item.handler();
                        });
                    }
                    this.dropdown.appendChild(btn);
                });
                const rect = button.getBoundingClientRect();
                this.dropdown.style.left = `${rect.left}px`;
                this.dropdown.style.top = `${rect.bottom + 4}px`;
                this.dropdown.setAttribute('aria-hidden', 'false');
                this.activeMenu = menuId;
                if (this.anchorButton && this.anchorButton !== button) this.anchorButton.setAttribute('aria-expanded', 'false');
                this.anchorButton = button;
                this.anchorButton.setAttribute('aria-expanded', 'true');
            }

            hide() {
                this.dropdown.setAttribute('aria-hidden', 'true');
                this.dropdown.innerHTML = '';
                if (this.anchorButton) this.anchorButton.setAttribute('aria-expanded', 'false');
                this.activeMenu = null;
                this.anchorButton = null;
            }

            getItems(menuId) {
                const { desktopManager, windowManager, appManager, settings, notifications } = this.deps;
                switch (menuId) {
                    case 'finder':
                        return [
                            { label: 'About ToastSearcher', handler: () => appManager.open('toastsearcher', { path: '/Documents' }) },
                            { type: 'separator' },
                            { label: 'Preferences…', shortcut: '⌘,', handler: () => appManager.open('settings', { section: 'appearance' }) }
                        ];
                    case 'file':
                        return [
                            { label: 'New File…', shortcut: '⌘N', handler: () => desktopManager.createDesktopFile() },
                            { label: 'New Folder…', shortcut: '⇧⌘N', handler: () => desktopManager.createDesktopFolder() },
                            { type: 'separator' },
                            { label: 'Open ToastSearcher', shortcut: '⌘O', handler: () => appManager.open('toastsearcher', { path: '/Desktop' }) },
                            { label: 'Download From URL…', handler: () => this.downloadFromUrl() },
                            { type: 'separator' },
                            { label: 'Export File System Snapshot', handler: () => {
                                downloadFileSystemSnapshot(this.deps.fileSystem);
                                notifications.notify('Snapshot saved', 'Filesystem exported successfully.');
                            } }
                        ];
                    case 'edit':
                        return [
                            { label: 'Copy', shortcut: '⌘C', handler: () => desktopManager.copySelection?.() || notifications.notify('Edit', 'Select files to copy.') },
                            { label: 'Cut', shortcut: '⌘X', handler: () => desktopManager.cutSelection?.() || notifications.notify('Edit', 'Select files to cut.') },
                            { label: 'Paste', shortcut: '⌘V', handler: () => desktopManager.pasteClipboard('/Desktop') },
                            { type: 'separator' },
                            { label: 'Select None', handler: () => desktopManager.clearSelection?.() }
                        ];
                    case 'view':
                        return [
                            { label: settings.state.showParticles ? 'Hide Desktop Particles' : 'Show Desktop Particles', handler: () => settings.update({ showParticles: !settings.state.showParticles }) },
                            { label: 'Toggle Dark Mode', shortcut: '⌘⌥L', handler: () => {
                                const next = settings.state.theme === 'dark' ? 'light' : 'dark';
                                settings.update({ theme: next });
                                notifications.notify('Appearance', `Switched to ${next} mode.`);
                            } },
                            { label: 'Refresh Desktop', handler: () => desktopManager.render() }
                        ];
                    case 'go': {
                        const destinations = [
                            { label: 'Desktop', path: '/Desktop' },
                            { label: 'Documents', path: '/Documents' },
                            { label: 'Downloads', path: '/Downloads' },
                            { label: 'Pictures', path: '/Pictures' },
                            { label: 'Music', path: '/Music' }
                        ];
                        return destinations.map(dest => ({ label: dest.label, handler: () => appManager.open('toastsearcher', { path: dest.path }) }));
                    }
                    case 'window': {
                        const items = [];
                        const wins = windowManager.getWindows();
                        if (!wins.length) {
                            items.push({ label: 'No open windows', disabled: true });
                        } else {
                            wins.forEach(win => {
                                items.push({ label: win.title || 'Untitled', handler: () => windowManager.focusWindow(win.id) });
                            });
                            items.push({ type: 'separator' });
                        }
                        items.push({ label: 'Minimize All', handler: () => windowManager.minimizeAll() });
                        items.push({ label: 'Show All', handler: () => windowManager.restoreAll() });
                        return items;
                    }
                    case 'help':
                        return [
                            { label: 'ToastSearcher Help', handler: () => appManager.open('toastsearcher', { path: '/System' }) },
                            { label: 'View Keyboard Shortcuts', handler: () => {
                                this.deps.modals.open({
                                    title: 'Keyboard Shortcuts',
                                    body: `<ul style="padding-left:18px; line-height:1.6;">
                                        <li><strong>⌥ Tab</strong> — Cycle windows</li>
                                        <li><strong>⌘⇧N</strong> — New note in Text Studio</li>
                                        <li><strong>⌘O</strong> — Open ToastSearcher</li>
                                        <li><strong>⌘⌥L</strong> — Toggle dark mode</li>
                                    </ul>`,
                                    actions: [{ label: 'Done', primary: true }]
                                });
                            } },
                            { label: 'About Slighty.Toasted', handler: () => appManager.open('settings', { section: 'about' }) }
                        ];
                    default:
                        return [];
                }
            }

            async downloadFromUrl() {
                const { fileSystem, notifications } = this.deps;
                const url = prompt('Enter the file URL to download into Downloads');
                if (!url) return;
                try {
                    notifications.notify('Download', 'Fetching remote file…');
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
                    const buffer = await response.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    const contentType = response.headers.get('Content-Type') || utils.mimeFromName(url);
                    const suggested = (() => {
                        try {
                            const withoutQuery = url.split('#')[0].split('?')[0];
                            const segment = withoutQuery.split('/').filter(Boolean).pop();
                            return segment && segment.length < 128 ? segment : null;
                        } catch (error) {
                            return null;
                        }
                    })();
                    const defaultName = suggested || `download-${Date.now()}`;
                    const name = prompt('Save file as', defaultName);
                    if (!name) return;
                    const target = `/Downloads/${name}`;
                    if (fileSystem.exists(target)) {
                        if (!confirm('File exists. Overwrite?')) return;
                        fileSystem.writeFile(target, bytes, { mime: contentType });
                    } else {
                        fileSystem.createFile(target, bytes, { mime: contentType });
                    }
                    notifications.notify('Download complete', `${name} stored in Downloads.`);
                } catch (error) {
                    notifications.notify('Download failed', error.message || 'Unable to fetch remote file.');
                }
            }
        }

        class AppCategoryManager extends EventEmitter {
            constructor(appDescriptors = []) {
                super();
                this.storageKey = APP_CATEGORY_STORAGE_KEY;
                this.state = this.load();
                this.ensureDefaults();
                if (appDescriptors.length) this.registerDescriptors(appDescriptors);
            }

            load() {
                try {
                    const raw = localStorage.getItem(this.storageKey);
                    const parsed = raw ? JSON.parse(raw) : {};
                    const categories = Array.isArray(parsed.categories) ? parsed.categories.map(cat => this.normalizeCategory(cat)).filter(Boolean) : [];
                    const assignments = parsed.assignments && typeof parsed.assignments === 'object' ? parsed.assignments : {};
                    const order = Array.isArray(parsed.order) ? parsed.order : [];
                    const suggestions = parsed.suggestions && typeof parsed.suggestions === 'object' ? parsed.suggestions : {};
                    const usageRaw = parsed.usage && typeof parsed.usage === 'object' ? parsed.usage : {};
                    const usage = {
                        apps: usageRaw.apps && typeof usageRaw.apps === 'object' ? usageRaw.apps : {},
                        categories: usageRaw.categories && typeof usageRaw.categories === 'object' ? usageRaw.categories : {}
                    };
                    return { categories, assignments, order, suggestions, usage };
                } catch (error) {
                    console.warn('Failed to load category assignments', error);
                    return { categories: [], assignments: {}, order: [], suggestions: {}, usage: { apps: {}, categories: {} } };
                }
            }

            normalizeCategory(cat) {
                if (!cat || !cat.id) return null;
                return {
                    id: cat.id,
                    name: cat.name || 'Untitled',
                    icon: cat.icon || '🗂️',
                    accent: cat.accent || '#7b8bff',
                    custom: Boolean(cat.custom),
                    expanded: cat.expanded !== undefined ? Boolean(cat.expanded) : true,
                    parentId: cat.parentId || null,
                    type: cat.type || 'standard',
                    filters: cat.filters || null,
                    theme: cat.theme || 'default',
                    childrenOrder: Array.isArray(cat.childrenOrder) ? cat.childrenOrder.slice() : []
                };
            }

            ensureDefaults() {
                let changed = false;
                const categoriesMap = new Map(this.state.categories.map(cat => [cat.id, cat]));
                DEFAULT_CATEGORY_DEFS.forEach(def => {
                    const normalized = this.normalizeCategory(def);
                    if (!categoriesMap.has(def.id)) {
                        this.state.categories.push({ ...normalized, custom: Boolean(def.custom), expanded: true });
                        categoriesMap.set(def.id, this.state.categories[this.state.categories.length - 1]);
                        changed = true;
                    } else {
                        const existing = categoriesMap.get(def.id);
                        Object.assign(existing, {
                            name: normalized.name,
                            icon: normalized.icon,
                            accent: normalized.accent,
                            type: normalized.type,
                            filters: normalized.filters,
                            parentId: normalized.parentId || null,
                            custom: Boolean(def.custom),
                            theme: normalized.theme || existing.theme
                        });
                        if (existing.expanded === undefined) existing.expanded = true;
                        if (!Array.isArray(existing.childrenOrder)) existing.childrenOrder = [];
                    }
                });

                this.state.categories = this.state.categories.filter(cat => cat && cat.id);
                const validIds = new Set(this.state.categories.map(cat => cat.id));

                this.state.categories.forEach(cat => {
                    if (cat.parentId && !validIds.has(cat.parentId)) {
                        cat.parentId = null;
                        changed = true;
                    }
                });

                const rootIds = this.state.categories.filter(cat => !cat.parentId).map(cat => cat.id);
                this.state.order = reconcileOrder(this.state.order, rootIds);

                const childrenMap = new Map();
                this.state.categories.forEach(cat => {
                    if (!childrenMap.has(cat.parentId || '__root__')) childrenMap.set(cat.parentId || '__root__', []);
                    childrenMap.get(cat.parentId || '__root__').push(cat.id);
                });
                this.state.categories.forEach(cat => {
                    const children = childrenMap.get(cat.id) || [];
                    cat.childrenOrder = reconcileOrder(cat.childrenOrder, children);
                });

                if (!this.state.usage || typeof this.state.usage !== 'object') {
                    this.state.usage = { apps: {}, categories: {} };
                    changed = true;
                } else {
                    if (!this.state.usage.apps || typeof this.state.usage.apps !== 'object') {
                        this.state.usage.apps = {};
                        changed = true;
                    }
                    if (!this.state.usage.categories || typeof this.state.usage.categories !== 'object') {
                        this.state.usage.categories = {};
                        changed = true;
                    }
                }

                if (changed) this.persist();
            }

            persist() {
                const payload = {
                    categories: this.state.categories,
                    assignments: this.state.assignments,
                    order: this.state.order,
                    suggestions: this.state.suggestions,
                    usage: this.state.usage
                };
                localStorage.setItem(this.storageKey, JSON.stringify(payload));
                this.emit('change', this.state);
            }

            registerDescriptors(descriptors = []) {
                let changed = false;
                descriptors.forEach(descriptor => {
                    if (!descriptor?.id) return;
                    if (!this.state.assignments[descriptor.id]) {
                        const target = this.ensureCategoryExists(this.autoCategorize(descriptor));
                        this.state.assignments[descriptor.id] = target;
                        changed = true;
                    }
                    const suggestions = this.suggestCategories(descriptor);
                    if (suggestions.length) {
                        this.state.suggestions[descriptor.id] = suggestions;
                        changed = true;
                    } else if (this.state.suggestions[descriptor.id]) {
                        delete this.state.suggestions[descriptor.id];
                        changed = true;
                    }
                });
                if (changed) this.persist();
            }

            ensureCategoryExists(categoryId) {
                if (!categoryId) return 'uncategorized';
                const existing = this.getCategoryById(categoryId);
                if (existing) return existing.id;
                const fallback = DEFAULT_CATEGORY_DEFS.find(cat => cat.id === categoryId);
                if (fallback) {
                    const normalized = this.normalizeCategory({ ...fallback, custom: Boolean(fallback.custom), expanded: true });
                    this.state.categories.push(normalized);
                    if (!normalized.parentId) {
                        this.state.order = reconcileOrder(this.state.order, [...this.state.order, normalized.id]);
                    } else {
                        const parent = this.getCategoryById(normalized.parentId);
                        if (parent) parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, normalized.id]);
                    }
                    this.persist();
                    return normalized.id;
                }
                return 'uncategorized';
            }

            autoCategorize(descriptor) {
                if (!descriptor) return 'uncategorized';
                const explicit = DEFAULT_APP_CATEGORY_ASSIGNMENTS[descriptor.id];
                if (explicit) return explicit;
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                for (const rule of CATEGORY_KEYWORD_RULES) {
                    if (rule.keywords.some(keyword => haystack.includes(keyword))) {
                        return this.ensureCategoryExists(rule.category);
                    }
                }
                return 'uncategorized';
            }

            suggestCategories(descriptor) {
                if (!descriptor) return [];
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                const matches = new Set();
                CATEGORY_KEYWORD_RULES.forEach(rule => {
                    if (rule.keywords.some(keyword => haystack.includes(keyword))) {
                        matches.add(this.ensureCategoryExists(rule.category));
                    }
                });
                return Array.from(matches);
            }

            listCategories(options = {}) {
                const { includeRoot = true } = options;
                const output = [];
                const visit = (id, depth = 0) => {
                    const category = this.getCategoryById(id);
                    if (!category) return;
                    if (includeRoot || depth > 0 || category.parentId) {
                        output.push({ ...category, depth, path: this.getCategoryPath(id) });
                    }
                    const childOrder = category.childrenOrder || [];
                    childOrder.forEach(childId => visit(childId, depth + 1));
                };
                (this.state.order || []).forEach(rootId => visit(rootId, 0));
                return output;
            }

            getCategoryTree() {
                const build = (id) => {
                    const category = this.getCategoryById(id);
                    if (!category) return null;
                    const children = (category.childrenOrder || []).map(childId => build(childId)).filter(Boolean);
                    return { category, children };
                };
                return (this.state.order || []).map(rootId => build(rootId)).filter(Boolean);
            }

            getCategoryById(id) {
                return this.state.categories.find(cat => cat.id === id) || null;
            }

            getCategoryPath(id) {
                const path = [];
                let current = this.getCategoryById(id);
                while (current) {
                    path.unshift(current);
                    if (!current.parentId) break;
                    current = this.getCategoryById(current.parentId);
                }
                return path;
            }

            getChildOrder(parentId) {
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    return parent ? parent.childrenOrder.slice() : [];
                }
                return (this.state.order || []).slice();
            }

            getCategoryForApp(appId) {
                if (this.state.assignments[appId]) return this.state.assignments[appId];
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const inferred = this.autoCategorize(descriptor);
                this.state.assignments[appId] = inferred;
                this.persist();
                return inferred;
            }

            getSmartMatches(descriptor) {
                const matches = [];
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                this.state.categories.forEach(cat => {
                    if (cat.type === 'smart' && cat.filters?.keywords?.some(keyword => haystack.includes(keyword))) {
                        matches.push(cat.id);
                    }
                });
                return matches;
            }

            recordAppUsage(appId) {
                if (!appId) return;
                if (!this.state.usage) this.state.usage = { apps: {}, categories: {} };
                const now = Date.now();
                if (!this.state.usage.apps[appId]) this.state.usage.apps[appId] = { count: 0, lastUsed: 0 };
                this.state.usage.apps[appId].count += 1;
                this.state.usage.apps[appId].lastUsed = now;
                let categoryId = this.state.assignments[appId];
                if (!categoryId) {
                    const descriptor = APP_CATALOG.find(app => app.id === appId);
                    categoryId = this.autoCategorize(descriptor);
                    this.state.assignments[appId] = categoryId;
                }
                categoryId = this.ensureCategoryExists(categoryId);
                if (!this.state.usage.categories[categoryId]) this.state.usage.categories[categoryId] = { count: 0, lastUsed: 0 };
                this.state.usage.categories[categoryId].count += 1;
                this.state.usage.categories[categoryId].lastUsed = now;
                this.persist();
            }

            getAppUsage(appId) {
                const usage = this.state.usage?.apps?.[appId];
                return usage ? { ...usage } : { count: 0, lastUsed: null };
            }

            getCategoryUsage(categoryId) {
                const usage = this.state.usage?.categories?.[categoryId];
                return usage ? { ...usage } : { count: 0, lastUsed: null };
            }

            getSuggestedCategoriesForApp(appId, limit = 3) {
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                if (!descriptor) return [];
                const suggestions = new Set();
                (this.state.suggestions?.[appId] || []).forEach(id => suggestions.add(id));
                this.suggestCategories(descriptor).forEach(id => suggestions.add(id));
                const ranked = Array.from(suggestions)
                    .map(id => {
                        const category = this.getCategoryById(id);
                        if (!category) return null;
                        const usage = this.getCategoryUsage(id);
                        return { category, usage };
                    })
                    .filter(Boolean)
                    .sort((a, b) => (b.usage.count - a.usage.count) || ((b.usage.lastUsed || 0) - (a.usage.lastUsed || 0)));
                return ranked.slice(0, limit).map(entry => entry.category);
            }

            getUsageInsights(limit = 3) {
                const trending = Object.entries(this.state.usage?.categories || {})
                    .map(([categoryId, data]) => ({
                        category: this.getCategoryById(categoryId),
                        count: data?.count || 0,
                        lastUsed: data?.lastUsed || 0
                    }))
                    .filter(item => item.category)
                    .sort((a, b) => (b.count - a.count) || (b.lastUsed - a.lastUsed))
                    .slice(0, limit);

                const suggestedMoves = Object.entries(this.state.usage?.apps || {})
                    .filter(([, data]) => (data?.count || 0) >= 3)
                    .map(([appId, data]) => {
                        const descriptor = APP_CATALOG.find(app => app.id === appId);
                        if (!descriptor) return null;
                        const currentCategoryId = this.state.assignments[appId] || 'uncategorized';
                        const currentCategory = this.getCategoryById(currentCategoryId);
                        const suggestions = this.getSuggestedCategoriesForApp(appId, limit);
                        return {
                            appId,
                            descriptor,
                            usage: { count: data.count, lastUsed: data.lastUsed },
                            currentCategory,
                            suggestions
                        };
                    })
                    .filter(item => item && item.suggestions.length && (!item.currentCategory || item.currentCategory.id === 'uncategorized'))
                    .slice(0, limit);

                return { trending, suggestedMoves };
            }

            dismissSuggestionsForApp(appId) {
                if (!appId || !this.state.suggestions?.[appId]) return;
                delete this.state.suggestions[appId];
                this.persist();
            }

            expandPath(id) {
                const path = this.getCategoryPath(id);
                let changed = false;
                path.forEach(cat => {
                    if (cat && !cat.expanded) {
                        cat.expanded = true;
                        changed = true;
                    }
                });
                if (changed) this.persist();
            }

            createCategory(name, icon = '🗂️', options = {}) {
                const trimmed = (name || '').trim();
                if (!trimmed) throw new Error('Category name is required');
                const base = trimmed.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || `category-${Math.random().toString(16).slice(2, 6)}`;
                const accent = options.accent || CATEGORY_ACCENTS[Math.floor(Math.random() * CATEGORY_ACCENTS.length)];
                let id = base;
                let counter = 2;
                while (this.getCategoryById(id)) id = `${base}-${counter++}`;
                const parentId = options.parentId || null;
                if (parentId && !this.getCategoryById(parentId)) throw new Error('Parent category not found');
                const category = this.normalizeCategory({
                    id,
                    name: trimmed,
                    icon: icon || '🗂️',
                    accent,
                    custom: true,
                    expanded: true,
                    parentId,
                    type: options.type || 'standard',
                    filters: options.filters || null
                });
                this.state.categories.push(category);
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, id]);
                } else {
                    this.state.order = reconcileOrder(this.state.order, [...this.state.order, id]);
                }
                if (this.state.usage && !this.state.usage.categories[id]) {
                    this.state.usage.categories[id] = { count: 0, lastUsed: 0 };
                }
                this.persist();
                return id;
            }

            renameCategory(id, name) {
                const category = this.getCategoryById(id);
                if (!category) return;
                if (!category.custom && DEFAULT_CATEGORY_DEFS.some(cat => cat.id === id)) {
                    throw new Error('System categories cannot be renamed');
                }
                category.name = name.trim();
                this.persist();
            }

            setCategoryIcon(id, icon) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.icon = icon || '🗂️';
                this.persist();
            }

            setCategoryAccent(id, accent) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.accent = accent || category.accent;
                this.persist();
            }

            setCategoryTheme(id, theme) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.theme = theme || 'default';
                this.persist();
            }

            setCategoryFilters(id, filters) {
                const category = this.getCategoryById(id);
                if (!category) return;
                const keywords = Array.isArray(filters)
                    ? filters.map(word => word.trim()).filter(Boolean)
                    : String(filters || '')
                        .split(',')
                        .map(word => word.trim())
                        .filter(Boolean);
                if (keywords.length) {
                    category.type = 'smart';
                    category.filters = { keywords };
                } else {
                    category.type = 'standard';
                    category.filters = null;
                }
                this.persist();
            }

            deleteCategory(id) {
                if (DEFAULT_CATEGORY_DEFS.some(cat => cat.id === id)) throw new Error('Cannot delete default categories');
                const category = this.getCategoryById(id);
                if (!category) return;
                const parentId = category.parentId;
                if (this.state.usage?.categories?.[id]) delete this.state.usage.categories[id];
                (category.childrenOrder || []).forEach(childId => {
                    const child = this.getCategoryById(childId);
                    if (!child) return;
                    child.parentId = parentId || null;
                    if (parentId) {
                        const parent = this.getCategoryById(parentId);
                        parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, childId]);
                    } else {
                        this.state.order = reconcileOrder(this.state.order, [...this.state.order, childId]);
                    }
                });
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    parent.childrenOrder = parent.childrenOrder.filter(child => child !== id);
                } else {
                    this.state.order = this.state.order.filter(rootId => rootId !== id);
                }
                this.state.categories = this.state.categories.filter(cat => cat.id !== id);
                Object.entries(this.state.assignments).forEach(([appId, catId]) => {
                    if (catId === id) this.state.assignments[appId] = 'uncategorized';
                });
                Object.entries(this.state.suggestions || {}).forEach(([key, list]) => {
                    const filtered = Array.isArray(list) ? list.filter(catId => catId !== id) : [];
                    if (filtered.length) this.state.suggestions[key] = filtered; else delete this.state.suggestions[key];
                });
                this.persist();
            }

            assignApp(appId, categoryId) {
                const target = this.ensureCategoryExists(categoryId);
                this.state.assignments[appId] = target;
                if (this.state.usage && !this.state.usage.categories[target]) {
                    this.state.usage.categories[target] = { count: 0, lastUsed: 0 };
                }
                this.persist();
            }

            toggleExpanded(id) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.expanded = !category.expanded;
                this.persist();
            }

            setExpanded(id, value) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.expanded = Boolean(value);
                this.persist();
            }

            reorderCategory(sourceId, targetParentId, targetIndex = Infinity) {
                const category = this.getCategoryById(sourceId);
                if (!category) return;
                if (targetParentId === sourceId) return;
                if (this.isAncestor(sourceId, targetParentId)) return;

                if (category.parentId) {
                    const parent = this.getCategoryById(category.parentId);
                    if (parent) parent.childrenOrder = parent.childrenOrder.filter(id => id !== sourceId);
                } else {
                    this.state.order = this.state.order.filter(id => id !== sourceId);
                }

                category.parentId = targetParentId || null;

                if (category.parentId) {
                    const parent = this.getCategoryById(category.parentId);
                    if (!parent) {
                        category.parentId = null;
                        this.state.order = this.insertAt(this.state.order, sourceId, targetIndex);
                    } else {
                        parent.childrenOrder = this.insertAt(parent.childrenOrder, sourceId, targetIndex);
                    }
                } else {
                    this.state.order = this.insertAt(this.state.order, sourceId, targetIndex);
                }
                this.persist();
            }

            isAncestor(ancestorId, childId) {
                if (!ancestorId || !childId) return false;
                let cursor = this.getCategoryById(childId);
                while (cursor) {
                    if (cursor.parentId === ancestorId) return true;
                    cursor = this.getCategoryById(cursor.parentId);
                }
                return false;
            }

            insertAt(list, id, index) {
                const clone = (list || []).filter(item => item !== id);
                const safeIndex = Number.isFinite(index) ? Math.max(0, Math.min(index, clone.length)) : clone.length;
                clone.splice(safeIndex, 0, id);
                return clone;
            }
        }

        class StartMenu {
            constructor({ appManager, categoryManager, dockManager = null, notifications, modals }) {
                this.appManager = appManager;
                this.categoryManager = categoryManager;
                this.dockManager = dockManager;
                this.notifications = notifications;
                this.modals = modals;
                this.element = document.getElementById('start-menu');
                this.categoriesEl = document.getElementById('start-menu-categories');
                this.searchInput = document.getElementById('start-menu-search');
                this.addCategoryButton = document.getElementById('start-menu-add-category');
                this.manageCategoriesButton = document.getElementById('start-menu-manage-categories');
                this.countEl = document.getElementById('start-menu-app-count');
                this.startButton = document.getElementById('start-button');
                this.contextMenu = document.getElementById('start-menu-menu');
                this.pinButton = document.getElementById('start-menu-pin');
                this.suggestionStrip = utils.createEl('div', 'start-menu-suggestions hidden');
                this.categoriesEl?.parentElement?.insertBefore(this.suggestionStrip, this.categoriesEl);
                this.visible = false;
                this.searchTerm = '';
                this.contextTarget = null;
                this.animationStates = new Map();
                this.draggingCategoryId = null;
                this.interacting = false;
                this.interactionTimer = null;
                this.pinned = localStorage.getItem('webos.startMenuPinned') === 'true';
                if ('IntersectionObserver' in window) {
                    this.categoryObserver = new IntersectionObserver(entries => {
                        entries.forEach(entry => {
                            if (!entry.isIntersecting) return;
                            entry.target.classList.add('visible');
                            this.categoryObserver.unobserve(entry.target);
                        });
                    }, { root: this.categoriesEl, threshold: 0.12 });
                } else {
                    this.categoryObserver = null;
                }

                this.startButton.addEventListener('click', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.toggle();
                });

                document.addEventListener('click', event => {
                    if (!this.visible) return;
                    if (this.element.contains(event.target) || event.target === this.startButton) {
                        this.releaseInteractionGuard();
                        return;
                    }
                    if (this.interacting || this.pinned) return;
                    this.hide();
                });

                document.addEventListener('keydown', event => {
                    if (!this.visible) return;
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.hide(true);
                    }
                });

                this.searchInput.addEventListener('input', utils.debounce(event => {
                    this.searchTerm = event.target.value.trim().toLowerCase();
                    this.render();
                }, 120));

                this.addCategoryButton.addEventListener('click', () => this.promptCreateCategory());
                this.manageCategoriesButton.addEventListener('click', () => this.openManageCategories());

                this.categoriesEl.addEventListener('scroll', () => {
                    // lazy placeholder for future use
                });

                this.categoriesEl.addEventListener('dragover', event => {
                    if (!this.draggingCategoryId) return;
                    if (event.target.closest('.start-menu-category')) return;
                    event.preventDefault();
                });
                this.categoriesEl.addEventListener('drop', event => {
                    if (!this.draggingCategoryId) return;
                    if (event.target.closest('.start-menu-category')) return;
                    event.preventDefault();
                    this.categoryManager.reorderCategory(this.draggingCategoryId, null, Infinity);
                    this.draggingCategoryId = null;
                });

                this.element.addEventListener('pointerdown', () => this.setInteractionGuard(true));
                this.element.addEventListener('pointerup', () => this.releaseInteractionGuard());
                this.element.addEventListener('pointerleave', () => this.releaseInteractionGuard(160));
                this.element.addEventListener('pointercancel', () => this.releaseInteractionGuard());

                if (this.pinButton) {
                    this.pinButton.addEventListener('click', () => this.setPinned(!this.pinned));
                    this.updatePinButton();
                }

                this.contextMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button || !this.contextTarget) return;
                    const action = button.dataset.action;
                    this.hideContextMenu();
                    switch (action) {
                        case 'start-open':
                            this.openApp(this.contextTarget);
                            break;
                        case 'start-pin':
                            this.pinApp(this.contextTarget);
                            break;
                        case 'start-move':
                            this.promptMoveApp(this.contextTarget);
                            break;
                    }
                });

                document.addEventListener('click', event => {
                    if (!this.contextMenu.contains(event.target)) this.hideContextMenu();
                });

                this.categoryManager.on('change', () => this.render());
                this.render();
            }

            setDockManager(manager) {
                this.dockManager = manager;
            }

            setInteractionGuard(active) {
                if (active) {
                    this.interacting = true;
                    if (this.interactionTimer) {
                        clearTimeout(this.interactionTimer);
                        this.interactionTimer = null;
                    }
                } else {
                    this.releaseInteractionGuard();
                }
            }

            releaseInteractionGuard(delay = 0) {
                if (this.interactionTimer) {
                    clearTimeout(this.interactionTimer);
                    this.interactionTimer = null;
                }
                if (delay > 0) {
                    this.interactionTimer = setTimeout(() => {
                        this.interacting = false;
                        this.interactionTimer = null;
                    }, delay);
                } else {
                    this.interacting = false;
                }
            }

            setPinned(pinned) {
                this.pinned = Boolean(pinned);
                localStorage.setItem('webos.startMenuPinned', this.pinned ? 'true' : 'false');
                this.updatePinButton();
                if (this.pinned && !this.visible) this.show();
            }

            updatePinButton() {
                if (!this.pinButton) return;
                this.pinButton.setAttribute('aria-pressed', this.pinned ? 'true' : 'false');
                this.pinButton.textContent = this.pinned ? '📌 Pinned' : '📌 Pin';
            }

            handleExternalFocus(state) {
                if (!this.visible) return;
                if (this.pinned || this.interacting) return;
                if (state?.appId === 'start-menu') return;
                this.hide();
            }

            toggle() {
                if (this.visible) this.hide(true); else this.show();
            }

            show() {
                if (this.visible) return;
                this.visible = true;
                this.element.setAttribute('aria-hidden', 'false');
                this.startButton.setAttribute('aria-expanded', 'true');
                this.startButton.classList.add('active');
                this.render();
                setTimeout(() => this.searchInput.focus({ preventScroll: true }), 120);
            }

            hide(force = false) {
                if (!this.visible) return;
                if (this.pinned && !force) return;
                this.visible = false;
                this.element.setAttribute('aria-hidden', 'true');
                this.startButton.setAttribute('aria-expanded', 'false');
                this.startButton.classList.remove('active');
                this.hideContextMenu();
                if (this.searchTerm) {
                    this.searchTerm = '';
                    this.searchInput.value = '';
                }
            }

            hideContextMenu() {
                this.contextMenu.setAttribute('aria-hidden', 'true');
                this.contextTarget = null;
            }

            showContextMenu(appId, x, y) {
                this.contextTarget = appId;
                const menuWidth = 220;
                const menuHeight = 150;
                this.contextMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.contextMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.contextMenu.setAttribute('aria-hidden', 'false');
            }

            getAppDescriptors() {
                return this.appManager.listDescriptors?.() || APP_CATALOG.slice();
            }

            buildAppMap() {
                const descriptors = this.getAppDescriptors();
                const map = new Map();
                const add = (categoryId, descriptor) => {
                    if (!categoryId) return;
                    if (!map.has(categoryId)) map.set(categoryId, []);
                    const bucket = map.get(categoryId);
                    if (!bucket.some(item => item.id === descriptor.id)) bucket.push(descriptor);
                };
                descriptors.forEach(descriptor => {
                    add(this.categoryManager.getCategoryForApp(descriptor.id), descriptor);
                    this.categoryManager.getSmartMatches(descriptor).forEach(id => add(id, descriptor));
                });
                return map;
            }

            render() {
                const categories = this.categoryManager.listCategories({ includeRoot: true });
                const appMap = this.buildAppMap();
                const term = (this.searchTerm || '').toLowerCase();
                const totalApps = this.getAppDescriptors().length;
                this.countEl.textContent = `${totalApps} apps installed`;
                const insights = this.categoryManager.getUsageInsights?.(6) || { trending: [], suggestedMoves: [] };
                this.renderSuggestions(insights);
                this.categoriesEl.innerHTML = '';

                const matchesTerm = (value) => (value || '').toLowerCase().includes(term);

                let visibleCategoryCount = 0;

                categories.forEach(category => {
                    const apps = (appMap.get(category.id) || []).slice().sort((a, b) => a.name.localeCompare(b.name));
                    const matchesCategory = term && matchesTerm(category.name);
                    const filteredApps = term
                        ? apps.filter(app => matchesTerm(app.name) || matchesTerm(app.hint) || matchesTerm(app.id))
                        : apps;
                    const appsForDisplay = matchesCategory ? apps : filteredApps;
                    if (!appsForDisplay.length && term && !matchesCategory && category.type !== 'smart') return;

                    visibleCategoryCount += 1;
                    const categoryEl = utils.createEl('div', 'start-menu-category');
                    categoryEl.dataset.categoryId = category.id;
                    categoryEl.dataset.depth = String(category.depth || 0);
                    categoryEl.setAttribute('role', 'treeitem');
                    categoryEl.setAttribute('aria-expanded', category.expanded ? 'true' : 'false');
                    categoryEl.style.setProperty('--category-depth', String(category.depth || 0));
                    if (category.accent) categoryEl.style.setProperty('--category-accent', category.accent);
                    if (category.type === 'smart') categoryEl.classList.add('category-smart');

                    const header = utils.createEl('div', 'start-menu-category-header');
                    const meta = utils.createEl('div', 'start-menu-category-meta');
                    meta.innerHTML = `<span class="glyph">${category.icon || '🗂️'}</span>`;
                    const text = utils.createEl('div');
                    text.innerHTML = `<strong>${category.name}</strong><span>${apps.length} app${apps.length === 1 ? '' : 's'}</span>`;

                    const usage = this.categoryManager.getCategoryUsage(category.id);
                    const usageBits = [];
                    if (usage.count) usageBits.push(`${usage.count} launch${usage.count === 1 ? '' : 'es'}`);
                    if (usage.lastUsed) usageBits.push(`Last ${utils.relativeTime(new Date(usage.lastUsed))}`);
                    const crumb = (category.path || []).slice(0, -1).map(node => node.name).join(' › ');
                    const infoLine = [crumb, usageBits.join(' • ')].filter(Boolean).join(' · ');
                    if (infoLine) {
                        const small = document.createElement('small');
                        small.textContent = infoLine;
                        text.appendChild(small);
                    }
                    meta.appendChild(text);

                    const controls = utils.createEl('div', 'start-menu-category-controls');
                    const toggleBtn = utils.createEl('button', '', { title: category.expanded ? 'Collapse' : 'Expand' });
                    toggleBtn.textContent = category.expanded ? '▾' : '▸';
                    controls.appendChild(toggleBtn);
                    if (category.custom) {
                        const editBtn = utils.createEl('button', '', { title: 'Edit category' });
                        editBtn.textContent = '✎';
                        controls.appendChild(editBtn);
                        editBtn.addEventListener('click', event => {
                            event.stopPropagation();
                            this.promptEditCategory(category.id);
                        });
                    }

                    header.append(meta, controls);
                    header.addEventListener('click', () => {
                        this.toggleCategory(category.id, categoryEl);
                        const newState = categoryEl.getAttribute('aria-expanded') === 'true';
                        toggleBtn.textContent = newState ? '▾' : '▸';
                    });
                    header.setAttribute('draggable', 'true');
                    header.addEventListener('dragstart', event => {
                        this.draggingCategoryId = category.id;
                        event.dataTransfer?.setData('text/plain', category.id);
                        event.dataTransfer?.setDragImage?.(categoryEl, 0, 0);
                        event.dataTransfer.effectAllowed = 'move';
                        categoryEl.classList.add('drag-source');
                    });
                    header.addEventListener('dragend', () => {
                        this.draggingCategoryId = null;
                        categoryEl.classList.remove('drag-source');
                        categoryEl.classList.remove('drag-over');
                    });

                    categoryEl.addEventListener('dragover', event => {
                        if (!this.draggingCategoryId || this.draggingCategoryId === category.id) return;
                        event.preventDefault();
                        categoryEl.classList.add('drag-over');
                    });
                    categoryEl.addEventListener('dragleave', event => {
                        if (event.relatedTarget && categoryEl.contains(event.relatedTarget)) return;
                        categoryEl.classList.remove('drag-over');
                    });
                    categoryEl.addEventListener('drop', event => {
                        if (!this.draggingCategoryId || this.draggingCategoryId === category.id) return;
                        event.preventDefault();
                        categoryEl.classList.remove('drag-over');
                        const rect = categoryEl.getBoundingClientRect();
                        const offset = event.clientY - rect.top;
                        const height = rect.height || 1;
                        const centerZone = offset > height * 0.35 && offset < height * 0.65;
                        const siblings = this.categoryManager.getChildOrder(category.parentId || null);
                        const currentIndex = siblings.indexOf(category.id);
                        let targetParent = category.parentId || null;
                        let targetIndex;
                        if (event.ctrlKey || event.metaKey || centerZone) {
                            targetParent = category.id;
                            targetIndex = 0;
                        } else if (offset < height * 0.5) {
                            targetIndex = Math.max(0, currentIndex);
                        } else {
                            targetIndex = currentIndex + 1;
                        }
                        this.categoryManager.reorderCategory(this.draggingCategoryId, targetParent, targetIndex);
                        this.draggingCategoryId = null;
                    });

                    const wrapper = utils.createEl('div', 'start-menu-app-wrapper');
                    const grid = utils.createEl('div', 'start-menu-app-grid');
                    if (!appsForDisplay.length) {
                        const empty = utils.createEl('button', 'start-menu-app empty');
                        const subtitle = category.type === 'smart' ? 'Smart category will populate automatically.' : 'Nothing in this category yet.';
                        empty.innerHTML = `<span class="glyph">—</span><div class="app-info"><strong>No apps</strong><span>${subtitle}</span></div>`;
                        empty.style.opacity = '1';
                        empty.style.transform = 'none';
                        grid.appendChild(empty);
                    } else {
                        appsForDisplay.forEach((app, index) => {
                            const card = utils.createEl('button', 'start-menu-app');
                            card.dataset.appId = app.id;
                            card.style.setProperty('--item-index', String(index));
                            card.innerHTML = `<span class="glyph">${app.icon || '🪟'}</span><div class="app-info"><strong>${app.name}</strong><span>${app.hint || 'Open application'}</span></div>`;
                            card.addEventListener('click', () => this.openApp(app.id));
                            card.addEventListener('contextmenu', event => {
                                event.preventDefault();
                                this.showContextMenu(app.id, event.clientX, event.clientY);
                            });
                            grid.appendChild(card);
                        });
                    }
                    wrapper.appendChild(grid);

                    categoryEl.append(header, wrapper);
                    this.categoriesEl.appendChild(categoryEl);
                    this.applyWrapperHeight(categoryEl, category.expanded);
                    this.observeCategory(categoryEl);
                });

                if (!visibleCategoryCount) {
                    const emptyState = utils.createEl('div', 'start-menu-category');
                    emptyState.innerHTML = '<div class="start-menu-category-header"><div class="start-menu-category-meta"><span class="glyph">🔍</span><div><strong>No matches</strong><span>Try a different search.</span></div></div></div>';
                    this.categoriesEl.appendChild(emptyState);
                    this.observeCategory(emptyState);
                }
            }

            observeCategory(element) {
                if (!element) return;
                element.classList.remove('visible');
                if (this.categoryObserver) {
                    this.categoryObserver.observe(element);
                } else {
                    requestAnimationFrame(() => element.classList.add('visible'));
                }
            }

            renderSuggestions(insights) {
                if (!this.suggestionStrip) return;
                const trending = insights?.trending || [];
                const suggestedMoves = insights?.suggestedMoves || [];
                if (!trending.length && !suggestedMoves.length) {
                    this.suggestionStrip.classList.add('hidden');
                    this.suggestionStrip.innerHTML = '';
                    return;
                }
                this.suggestionStrip.classList.remove('hidden');
                this.suggestionStrip.innerHTML = '';

                if (trending.length) {
                    const group = utils.createEl('div', 'suggestion-group');
                    const header = document.createElement('header');
                    header.textContent = 'Trending Categories';
                    const row = utils.createEl('div', 'suggestion-chip-row');
                    trending.forEach(entry => {
                        const color = entry.category?.accent || 'var(--accent)';
                        const chip = utils.createEl('button', 'suggestion-chip');
                        chip.dataset.accent = color;
                        chip.style.setProperty('--chip-accent', color);
                        chip.style.color = color;
                        chip.innerHTML = `<span class="dot"></span><span>${entry.category?.name || 'Category'}</span>`;
                        chip.title = `${entry.count || 0} launches`;
                        chip.addEventListener('click', () => {
                            if (entry.category?.id) this.focusOnCategory(entry.category.id);
                        });
                        row.appendChild(chip);
                    });
                    group.append(header, row);
                    this.suggestionStrip.appendChild(group);
                }

                if (suggestedMoves.length) {
                    const group = utils.createEl('div', 'suggestion-group');
                    const header = document.createElement('header');
                    header.textContent = 'Suggested Moves';
                    group.appendChild(header);
                    suggestedMoves.forEach(item => {
                        const card = utils.createEl('div', 'suggestion-card');
                        const strong = document.createElement('strong');
                        strong.textContent = item.descriptor?.name || item.appId;
                        const info = document.createElement('p');
                        info.style.margin = '0';
                        const currentName = item.currentCategory?.name || 'Uncategorized';
                        info.textContent = `Frequently opened (${item.usage.count}) · currently in ${currentName}`;
                        const footer = document.createElement('footer');
                        item.suggestions.forEach(category => {
                            const btn = utils.createEl('button', 'primary', { text: category.name });
                            if (category.accent) {
                                btn.style.background = category.accent;
                                btn.style.color = '#fff';
                            }
                            btn.addEventListener('click', () => this.handleSuggestionAssign(item.appId, category.id));
                            footer.appendChild(btn);
                        });
                        const skip = utils.createEl('button', '', { text: 'Dismiss' });
                        skip.addEventListener('click', () => {
                            this.categoryManager.dismissSuggestionsForApp(item.appId);
                            this.renderSuggestions(this.categoryManager.getUsageInsights?.(6));
                        });
                        footer.appendChild(skip);
                        card.append(strong, info, footer);
                        group.appendChild(card);
                    });
                    this.suggestionStrip.appendChild(group);
                }
            }

            handleSuggestionAssign(appId, categoryId) {
                this.categoryManager.assignApp(appId, categoryId);
                this.categoryManager.dismissSuggestionsForApp(appId);
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const category = this.categoryManager.getCategoryById(categoryId);
                this.notifications?.notify('Start Menu', `${descriptor?.name || 'App'} moved to ${category?.name || 'category'}.`);
                this.render();
            }

            applyWrapperHeight(categoryEl, expanded) {
                const wrapper = categoryEl.querySelector('.start-menu-app-wrapper');
                if (!wrapper) return;
                const grid = wrapper.firstElementChild;
                requestAnimationFrame(() => {
                    if (expanded) {
                        wrapper.style.height = 'auto';
                        const target = grid.getBoundingClientRect().height + 18;
                        wrapper.style.height = '0px';
                        requestAnimationFrame(() => {
                            wrapper.style.height = `${target}px`;
                            wrapper.addEventListener('transitionend', function handler() {
                                wrapper.style.height = 'auto';
                                wrapper.removeEventListener('transitionend', handler);
                            });
                        });
                    } else {
                        const current = grid.getBoundingClientRect().height + 18;
                        wrapper.style.height = `${current}px`;
                        requestAnimationFrame(() => {
                            wrapper.style.height = '0px';
                        });
                    }
                });
            }

            toggleCategory(id, categoryEl) {
                const expanded = categoryEl.getAttribute('aria-expanded') === 'true';
                categoryEl.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                this.applyWrapperHeight(categoryEl, !expanded);
                this.categoryManager.setExpanded(id, !expanded);
            }

            promptCreateCategory() {
                try {
                    const name = prompt('Category name');
                    if (!name) return;
                    const icon = prompt('Category icon (emoji)', '🗂️');
                    const id = this.categoryManager.createCategory(name, icon || '🗂️');
                    this.notifications?.notify('Categories', `${name} created`);
                    this.render();
                    this.focusOnCategory(id);
                } catch (error) {
                    this.notifications?.notify('Categories', error.message || 'Unable to create category');
                }
            }

            focusOnCategory(id) {
                this.categoryManager.expandPath?.(id);
                requestAnimationFrame(() => {
                    const element = this.categoriesEl.querySelector(`[data-category-id="${id}"]`);
                    if (!element) return;
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 600);
                });
            }

            promptEditCategory(id) {
                const category = this.categoryManager.getCategoryById(id);
                if (!category) return;
                const name = prompt('Rename category', category.name);
                if (name && name.trim()) {
                    try {
                        this.categoryManager.renameCategory(id, name);
                        const icon = prompt('Update icon', category.icon || '🗂️');
                        if (icon) this.categoryManager.setCategoryIcon(id, icon);
                        const accent = prompt('Accent color (hex)', category.accent || '#7b8bff');
                        if (accent) this.categoryManager.setCategoryAccent(id, accent);
                        const smartChoice = confirm('Configure smart filters for this category?');
                        if (smartChoice) {
                            const keywords = prompt('Enter comma-separated keywords for auto-categorization', category.filters?.keywords?.join(', ') || '');
                            this.categoryManager.setCategoryFilters(id, keywords || []);
                        }
                        this.notifications?.notify('Categories', 'Category updated');
                    } catch (error) {
                        this.notifications?.notify('Categories', error.message || 'Unable to update category');
                    }
                }
            }

            openManageCategories() {
                if (!this.modals) return;
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '12px';
                const list = document.createElement('div');
                list.style.display = 'flex';
                list.style.flexDirection = 'column';
                list.style.gap = '10px';
                this.categoryManager.listCategories().forEach(category => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.gap = '12px';
                    const label = document.createElement('span');
                    label.textContent = `${category.icon || '🗂️'}  ${category.name}`;
                    label.style.flex = '1';
                    row.appendChild(label);
                    const toggleBtn = utils.createEl('button', 'btn-secondary', { text: category.expanded ? 'Collapse' : 'Expand' });
                    toggleBtn.addEventListener('click', () => {
                        this.categoryManager.toggleExpanded(category.id);
                        toggleBtn.textContent = this.categoryManager.getCategoryById(category.id).expanded ? 'Collapse' : 'Expand';
                        this.render();
                    });
                    row.appendChild(toggleBtn);
                    if (category.custom) {
                        const renameBtn = utils.createEl('button', 'btn-secondary', { text: 'Rename' });
                        renameBtn.addEventListener('click', () => {
                            this.modals.close();
                            this.promptEditCategory(category.id);
                        });
                        row.appendChild(renameBtn);
                        const deleteBtn = utils.createEl('button', 'btn-secondary', { text: 'Delete' });
                        deleteBtn.addEventListener('click', () => {
                            if (confirm(`Remove category "${category.name}"? Apps will move to Uncategorized.`)) {
                                try {
                                    this.categoryManager.deleteCategory(category.id);
                                    this.notifications?.notify('Categories', 'Category removed');
                                    this.render();
                                    this.modals.close();
                                } catch (error) {
                                    this.notifications?.notify('Categories', error.message || 'Unable to delete category');
                                }
                            }
                        });
                        row.appendChild(deleteBtn);
                    }
                    list.appendChild(row);
                });
                container.appendChild(list);
                this.modals.open({
                    title: 'Manage Categories',
                    body: container,
                    actions: [{ label: 'Close', primary: true }]
                });
            }

            openApp(appId) {
                this.hide();
                try {
                    this.appManager.open(appId);
                } catch (error) {
                    this.notifications?.notify('Start Menu', error.message || 'Unable to launch app');
                }
            }

            pinApp(appId) {
                if (!this.dockManager) return;
                this.dockManager.pin(appId);
            }

            promptMoveApp(appId) {
                const categories = this.categoryManager.listCategories();
                const options = categories.map(cat => `${cat.icon || '🗂️'} ${cat.name}`).join('\n');
                const choice = prompt(`Move app to category:\n${options}\n\nEnter category name or leave blank to cancel.`);
                if (!choice) return;
                const match = categories.find(cat => cat.name.toLowerCase() === choice.trim().toLowerCase());
                if (!match) {
                    this.notifications?.notify('Categories', 'Category not found');
                    return;
                }
                this.categoryManager.assignApp(appId, match.id);
                this.notifications?.notify('Categories', 'App moved');
                this.render();
            }
        }

        class ShortcutManager {
            constructor(windowManager, appManager, settings) {
                this.windowManager = windowManager;
                this.appManager = appManager;
                this.settings = settings;
                this.register();
            }

            register() {
                document.addEventListener('keydown', event => {
                    if (event.altKey && event.key.toLowerCase() === 'tab') {
                        event.preventDefault();
                        this.windowManager.cycle();
                    }
                    if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.key.toLowerCase() === 'n') {
                        event.preventDefault();
                        this.appManager.open('text-editor');
                    }
                    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'b') {
                        event.preventDefault();
                        this.appManager.open('browser');
                    }
                    if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.key.toLowerCase() === 'd') {
                        event.preventDefault();
                        this.windowManager.windows.forEach((state, id) => this.windowManager.minimize(id));
                    }
                    if (event.key === 'F11') {
                        event.preventDefault();
                        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                        else document.exitFullscreen();
                    }
                });
            }
        }
        class AppManager {
            constructor(windowManager, fileSystem, notifications, settings, modals, categoryManager = null) {
                this.windowManager = windowManager;
                this.fileSystem = fileSystem;
                this.notifications = notifications;
                this.settings = settings;
                this.modals = modals;
                this.registry = new Map();
                this.categoryManager = categoryManager;
                this.dockManager = null;
            }

            register(id, descriptor) {
                this.registry.set(id, descriptor);
                if (this.categoryManager) this.categoryManager.registerDescriptors([descriptor]);
            }

            setDockManager(dockManager) {
                this.dockManager = dockManager;
            }

            open(id, context = {}) {
                const descriptor = this.registry.get(id);
                if (!descriptor) throw new Error(`App not registered: ${id}`);
                const instance = descriptor.launch({
                    context,
                    fileSystem: this.fileSystem,
                    windowManager: this.windowManager,
                    notifications: this.notifications,
                    settings: this.settings,
                    modals: this.modals,
                    appManager: this
                });
                const state = this.windowManager.create(id, {
                    title: instance.title || descriptor.name,
                    icon: descriptor.icon,
                    content: instance.element,
                    width: instance.width,
                    height: instance.height,
                    onClose: instance.onClose,
                    onFocus: instance.onFocus,
                    onBlur: instance.onBlur
                });
                instance.onMount?.(state);
                this.categoryManager?.recordAppUsage?.(id);
                this.dockManager?.handleAppUsage?.(id);
                return state;
            }

            openByFile(path, mime) {
                const ext = utils.ext(path);
                const lowerMime = (mime || '').toLowerCase();
                if (APP_ASSOCIATIONS.text.includes(ext) || lowerMime.startsWith('text')) {
                    this.open('text-editor', { path });
                } else if (APP_ASSOCIATIONS.image.includes(ext) || lowerMime.startsWith('image')) {
                    this.open('image-viewer', { path });
                } else if (APP_ASSOCIATIONS.audio.includes(ext) || APP_ASSOCIATIONS.video.includes(ext) || lowerMime.startsWith('audio') || lowerMime.startsWith('video')) {
                    this.open('media-player', { path });
                } else {
                    this.notifications.notify('Unsupported', `No application associated with ${ext || mime}`);
                }
            }

            listDescriptors() {
                return Array.from(this.registry.values()).map(descriptor => ({
                    id: descriptor.id,
                    name: descriptor.name,
                    icon: descriptor.icon,
                    hint: descriptor.hint
                }));
            }
        }
        function createToastSearcherApp(desktopManager) {
            return {
                id: 'toastsearcher',
                name: 'ToastSearcher',
                icon: '🍞',
                launch({ context, fileSystem, notifications, appManager }) {
                    const state = {
                        currentPath: context.path || '/Documents',
                        selection: new Set(),
                        clipboard: null,
                        searchTerm: '',
                        selectMode: context.selectMode || null
                    };

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="up">⬆️ Up</button>
                        <button data-action="new-file">➕ File</button>
                        <button data-action="new-folder">📁 Folder</button>
                        <button data-action="upload">⬆️ Upload</button>
                        <button data-action="copy">📋 Copy</button>
                        <button data-action="cut">✂️ Cut</button>
                        <button data-action="paste">📥 Paste</button>
                        <button data-action="rename">✏️ Rename</button>
                        <button data-action="delete">🗑️ Delete</button>
                        <label for="toastsearcher-search" class="visually-hidden">Search files</label>
                        <input id="toastsearcher-search" name="toastsearcher-search" type="search" placeholder="Search" style="margin-left:auto; min-width:180px;" />
                    `;
                    const searchInput = toolbar.querySelector('#toastsearcher-search');
                    const uploadInput = utils.createEl('input', '', { type: 'file', style: 'display:none', multiple: 'true' });
                    const layout = utils.createEl('div', 'file-explorer');
                    const treePane = utils.createEl('section', 'file-tree');
                    const listPane = utils.createEl('section', 'file-list');
                    const previewPane = utils.createEl('section', 'file-preview');
                    previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                    layout.append(treePane, listPane, previewPane);
                    shell.append(toolbar, layout, uploadInput);

                    function renderTree() {
                        treePane.innerHTML = '';
                        const walk = (path, level = 0) => {
                            const entries = fileSystem.listDirectory(path);
                            entries.filter(entry => entry.type === 'directory').forEach(entry => {
                                const item = utils.createEl('div', 'tree-item', { text: `${' '.repeat(level * 2)}${entry.name}` });
                                item.dataset.path = entry.path;
                                if (entry.path === state.currentPath) item.classList.add('active');
                                item.addEventListener('click', () => {
                                    state.currentPath = entry.path;
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                });
                                treePane.appendChild(item);
                                walk(entry.path, level + 1);
                            });
                        };
                        fileSystem.listDirectory('/').filter(entry => entry.type === 'directory').forEach(entry => {
                            const rootItem = utils.createEl('div', 'tree-item', { text: entry.name });
                            rootItem.dataset.path = entry.path;
                            if (entry.path === state.currentPath) rootItem.classList.add('active');
                            rootItem.addEventListener('click', () => {
                                state.currentPath = entry.path;
                                state.selection.clear();
                                renderList();
                                renderTree();
                            });
                            treePane.appendChild(rootItem);
                            walk(entry.path, 1);
                        });
                    }

                    function renderList() {
                        listPane.innerHTML = '';
                        const table = utils.createEl('table', 'file-table');
                        table.innerHTML = '<thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th></tr></thead><tbody></tbody>';
                        const tbody = table.querySelector('tbody');
                        const entries = fileSystem.listDirectory(state.currentPath).filter(entry => entry.name.toLowerCase().includes(state.searchTerm));
                        entries.forEach(entry => {
                            const row = utils.createEl('tr', 'file-row');
                            row.dataset.path = entry.path;
                            row.dataset.type = entry.type;
                            row.innerHTML = `
                                <td>${entry.name}</td>
                                <td>${entry.type === 'directory' ? 'Folder' : entry.mime}</td>
                                <td>${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size)}</td>
                                <td>${utils.humanDate(entry.updatedAt)}</td>
                            `;
                            row.addEventListener('click', event => {
                                if (event.shiftKey || event.metaKey || event.ctrlKey) {
                                    if (state.selection.has(entry.path)) state.selection.delete(entry.path); else state.selection.add(entry.path);
                                } else {
                                    state.selection.clear();
                                    state.selection.add(entry.path);
                                }
                                updateSelection();
                            });
                            row.addEventListener('dblclick', () => {
                                if (entry.type === 'directory') {
                                    state.currentPath = entry.path;
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                } else if (state.selectMode) {
                                    state.selectMode(entry.path);
                                    state.selection.clear();
                                } else {
                                    appManager.openByFile(entry.path, entry.mime);
                                }
                            });
                            tbody.appendChild(row);
                        });
                        listPane.appendChild(table);
                        updateSelection();
                    }

                    function updateSelection() {
                        listPane.querySelectorAll('.file-row').forEach(row => {
                            row.classList.toggle('active', state.selection.has(row.dataset.path));
                        });
                        const first = [...state.selection][0];
                        if (!first) {
                            previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                            return;
                        }
                        try {
                            const meta = fileSystem.readFileMeta(first);
                            const card = utils.createEl('div', 'preview-card');
                            card.innerHTML = `
                                <div>
                                    <strong>${meta.name}</strong>
                                    <div>${meta.mime || 'Unknown'} · ${utils.formatBytes(meta.size || 0)}</div>
                                    <div>${utils.humanDate(meta.updatedAt)}</div>
                                </div>
                                <div class="preview-body"></div>
                            `;
                            const body = card.querySelector('.preview-body');
                            if (meta.mime?.startsWith('text')) {
                                body.textContent = fileSystem.readFile(first);
                            } else if (meta.mime?.startsWith('image')) {
                                const img = new Image();
                                img.src = `data:${meta.mime};base64,${meta.data}`;
                                body.appendChild(img);
                            } else {
                                body.textContent = 'Preview not available for this file type.';
                            }
                            previewPane.innerHTML = '';
                            previewPane.appendChild(card);
                        } catch (error) {
                            previewPane.innerHTML = `<div class="preview-card"><strong>Error</strong><div class="preview-body">${error.message}</div></div>`;
                        }
                    }

                    toolbar.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const action = button.dataset.action;
                        try {
                            switch (action) {
                                case 'up':
                                    if (state.currentPath !== '/') {
                                        state.currentPath = utils.dirname(state.currentPath);
                                        renderList();
                                        renderTree();
                                    }
                                    break;
                                case 'new-file': {
                                    const name = prompt('File name', 'Untitled.txt');
                                    if (!name) break;
                                    fileSystem.createFile(utils.join(state.currentPath, name), '');
                                    renderList();
                                    break;
                                }
                                case 'new-folder': {
                                    const name = prompt('Folder name', 'New Folder');
                                    if (!name) break;
                                    fileSystem.createDirectory(utils.join(state.currentPath, name));
                                    renderList();
                                    renderTree();
                                    break;
                                }
                                case 'upload':
                                    uploadInput.click();
                                    break;
                                case 'copy':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'copy', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'copy');
                                    notifications.notify('Copied', `${state.selection.size} item(s) ready to paste`);
                                    break;
                                case 'cut':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'cut', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'cut');
                                    notifications.notify('Cut', `${state.selection.size} item(s) ready to move`);
                                    break;
                                case 'paste':
                                    if (state.clipboard) {
                                        state.clipboard.paths.forEach(path => {
                                            if (state.clipboard.mode === 'copy') fileSystem.copy(path, state.currentPath);
                                            if (state.clipboard.mode === 'cut') fileSystem.move(path, state.currentPath);
                                        });
                                        if (state.clipboard.mode === 'cut') state.clipboard = null;
                                        renderList();
                                        renderTree();
                                        break;
                                    }
                                    desktopManager?.pasteClipboard(state.currentPath);
                                    renderList();
                                    renderTree();
                                    break;
                                case 'rename': {
                                    if (state.selection.size !== 1) break;
                                    const path = [...state.selection][0];
                                    const currentName = path.split('/').pop();
                                    const name = prompt('Rename to', currentName);
                                    if (!name) break;
                                    fileSystem.rename(path, name);
                                    state.selection = new Set([utils.join(utils.dirname(path), name)]);
                                    renderList();
                                    renderTree();
                                    break;
                                }
                                case 'delete':
                                    if (!state.selection.size) break;
                                    if (!confirm(`Delete ${state.selection.size} item(s)?`)) break;
                                    state.selection.forEach(path => fileSystem.delete(path));
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                    break;
                            }
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    });

                    searchInput.addEventListener('input', utils.debounce(event => {
                        state.searchTerm = event.target.value.toLowerCase();
                        renderList();
                    }, 160));

                    uploadInput.addEventListener('change', () => {
                        const files = Array.from(uploadInput.files || []);
                        Promise.all(files.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${files.length} file(s) uploaded`);
                            uploadInput.value = '';
                            renderList();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    listPane.addEventListener('dragover', event => event.preventDefault());
                    listPane.addEventListener('drop', event => {
                        event.preventDefault();
                        const items = event.dataTransfer?.items;
                        if (!items) return;
                        const uploads = [];
                        for (const item of items) if (item.kind === 'file') uploads.push(item.getAsFile());
                        Promise.all(uploads.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${uploads.length} file(s) uploaded`);
                            renderList();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    renderTree();
                    renderList();

                    return {
                        element: shell,
                        title: `ToastSearcher — ${state.currentPath}`,
                        width: '940px',
                        height: '600px',
                        onFocus: win => {
                            win.element.querySelector('.window-title span:last-child').textContent = `ToastSearcher — ${state.currentPath}`;
                        }
                    };
                }
            };
        }
        function createAssistantApp() {
            return {
                id: 'assistant',
                name: 'AI Assistant',
                icon: '🤖',
                hint: 'Chat & automate',
                launch({ appManager, notifications, fileSystem, modals, settings }) {
                    const cfgKey = STORAGE_KEYS.AI_SETTINGS;
                    let cfg = { baseUrl: 'https://api.openai.com/v1', model: 'gpt-4o-mini', apiKey: '' };
                    try { cfg = { ...cfg, ...(JSON.parse(localStorage.getItem(cfgKey) || '{}')) }; } catch {}

                    const root = utils.createEl('div', 'assistant');
                    const toolbar = utils.createEl('div', 'assistant-toolbar');
                    toolbar.innerHTML = `
                        <details>
                          <summary>Connection</summary>
                          <div class="assistant-settings">
                            <label>Base URL <input id="ai-base" type="url" placeholder="https://api.openai.com/v1"/></label>
                            <label>Model <input id="ai-model" type="text" placeholder="gpt-4o-mini"/></label>
                            <label>API Key <input id="ai-key" type="password" placeholder="sk-..."/></label>
                            <button id="ai-save">Save</button>
                          </div>
                        </details>
                        <div class="assistant-hint">Type /help for commands. Writes require confirmation and are restricted to /Documents or /Downloads.</div>
                    `;
                    const chat = utils.createEl('div', 'assistant-chat');
                    const list = utils.createEl('div', 'assistant-messages');
                    chat.appendChild(list);
                    const composer = utils.createEl('div', 'assistant-composer');
                    composer.innerHTML = `
                        <textarea id="assistant-input" rows="2" placeholder="Ask me anything..."></textarea>
                        <button id="assistant-send" title="Send">Send</button>
                    `;
                    root.append(toolbar, chat, composer);

                    // Apply config to inputs
                    toolbar.querySelector('#ai-base').value = cfg.baseUrl || '';
                    toolbar.querySelector('#ai-model').value = cfg.model || '';
                    toolbar.querySelector('#ai-key').value = cfg.apiKey || '';

                    const saveCfg = () => {
                        cfg.baseUrl = toolbar.querySelector('#ai-base').value.trim() || cfg.baseUrl;
                        cfg.model = toolbar.querySelector('#ai-model').value.trim() || cfg.model;
                        cfg.apiKey = toolbar.querySelector('#ai-key').value.trim();
                        localStorage.setItem(cfgKey, JSON.stringify(cfg));
                        notifications?.notify('AI Assistant', 'Connection settings saved.');
                    };
                    toolbar.querySelector('#ai-save').addEventListener('click', saveCfg);

                    const addMessage = (role, content) => {
                        const row = utils.createEl('div', `assistant-msg ${role}`);
                        row.innerHTML = `<div class="bubble"><pre>${content.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}</pre></div>`;
                        list.appendChild(row);
                        list.scrollTop = list.scrollHeight;
                    };

                    const messages = [];

                    const limitText = (text, max = 16384) => text.length > max ? text.slice(0, max) + `\n... [truncated ${text.length - max} bytes]` : text;
                    const isSafeWritePath = (path) => {
                        const p = utils.normalize(path);
                        return p.startsWith('/Documents/') || p === '/Documents' || p.startsWith('/Downloads/') || p === '/Downloads';
                    };
                    const confirmWrite = (title, preview, onConfirm) => {
                        const body = document.createElement('div');
                        const pre = document.createElement('pre');
                        pre.textContent = limitText(preview, 4096);
                        body.appendChild(pre);
                        modals.open({
                            title,
                            body,
                            actions: [
                                { label: 'Cancel', onClick: () => true },
                                { label: 'Confirm', primary: true, onClick: () => { onConfirm(); return true; } }
                            ]
                        });
                    };

                    const handleCommand = (text) => {
                        const [, cmd, rest] = text.match(/^\/(\w+)(?:\s+(.+))?$/) || [];
                        if (!cmd) return false;
                        if (cmd === 'open') {
                            const appId = (rest || '').trim();
                            if (!appId) { notifications?.notify('AI Assistant', 'Usage: /open <appId>'); return true; }
                            appManager.open(appId);
                            notifications?.notify('AI Assistant', `Opening ${appId}...`);
                            return true;
                        }
                        if (cmd === 'openurl') {
                            const url = (rest || '').trim();
                            if (!url) { notifications?.notify('AI Assistant', 'Usage: /openurl <url>'); return true; }
                            appManager.open('browser', { url });
                            notifications?.notify('AI Assistant', 'Opening URL in Browser...');
                            return true;
                        }
                        if (cmd === 'search') {
                            const term = (rest || '').trim();
                            if (!term) { notifications?.notify('AI Assistant', 'Usage: /search <term>'); return true; }
                            try {
                                const results = fileSystem.search(term).slice(0, 50);
                                const lines = results.map(r => `${r.type === 'directory' ? '📁' : '📄'} ${r.path}`);
                                addMessage('assistant', lines.length ? lines.join('\n') : 'No matches.');
                            } catch (e) {
                                addMessage('assistant', `Search error: ${e.message}`);
                            }
                            return true;
                        }
                        if (cmd === 'read') {
                            const path = (rest || '').trim();
                            if (!path) { notifications?.notify('AI Assistant', 'Usage: /read <path>'); return true; }
                            try {
                                const meta = fileSystem.readFileMeta(path);
                                const isText = /^text\//.test(meta.mime) || /json|xml|javascript|markdown|css|csv/.test(meta.mime);
                                if (!isText) {
                                    addMessage('assistant', `Not a text file (mime=${meta.mime}, size=${meta.size} bytes).`);
                                    return true;
                                }
                                const content = utils.base64ToText(meta.data);
                                addMessage('assistant', limitText(content, 16384));
                            } catch (e) {
                                addMessage('assistant', `Read error: ${e.message}`);
                            }
                            return true;
                        }
                        if (cmd === 'write' || cmd === 'append') {
                            const m = (rest || '').match(/^(\S+)\s+([\s\S]+)$/);
                            if (!m) { notifications?.notify('AI Assistant', `Usage: /${cmd} <path> <text>`); return true; }
                            const path = utils.normalize(m[1]);
                            const text = m[2];
                            if (!isSafeWritePath(path)) { addMessage('assistant', 'Write blocked: Only /Documents or /Downloads are allowed.'); return true; }
                            const doWrite = () => {
                                try {
                                    if (cmd === 'append') {
                                        let prev = '';
                                        try { prev = fileSystem.readFile(path); } catch {}
                                        fileSystem.writeFile(path, prev + text);
                                    } else {
                                        fileSystem.writeFile(path, text);
                                    }
                                    notifications?.notify('AI Assistant', `${cmd === 'append' ? 'Appended to' : 'Wrote'} ${path}`);
                                } catch (e) {
                                    addMessage('assistant', `Write error: ${e.message}`);
                                }
                            };
                            confirmWrite(`${cmd === 'append' ? 'Append to' : 'Write to'} ${path}?`, text, doWrite);
                            return true;
                        }
                        if (cmd === 'help') {
                            addMessage('assistant', [
                                'Commands:',
                                '/open <appId> — open an app (e.g., browser, text-editor, terminal, tasks, settings)',
                                '/openurl <url> — open a URL in the Browser app',
                                '/search <term> — search files/folders',
                                '/read <path> — read a text file (limited to ~16 KB output)',
                                '/write <path> <text> — write text to a file (only /Documents or /Downloads, confirmation required)',
                                '/append <path> <text> — append text to a file (same restrictions)',
                                '/help — show this help'
                            ].join('\n'));
                            return true;
                        }
                        notifications?.notify('AI Assistant', `Unknown command: /${cmd}`);
                        return true;
                    };

                    const send = async () => {
                        const input = composer.querySelector('#assistant-input');
                        const text = (input.value || '').trim();
                        if (!text) return;
                        input.value = '';

                        // Commands
                        if (text.startsWith('/')) {
                            if (handleCommand(text)) return;
                        }

                        addMessage('user', text);
                        messages.push({ role: 'user', content: text });

                        // Validate config
                        if (!cfg.apiKey) { notifications?.notify('AI Assistant', 'Please set your API key.'); return; }
                        const url = `${cfg.baseUrl.replace(/\/$/, '')}/chat/completions`;
                        try {
                            const res = await fetch(url, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${cfg.apiKey}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    model: cfg.model,
                                    messages
                                })
                            });
                            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
                            const data = await res.json();
                            const reply = data.choices?.[0]?.message?.content || '(no response)';
                            messages.push({ role: 'assistant', content: reply });
                            addMessage('assistant', reply);
                        } catch (error) {
                            addMessage('assistant', `Error: ${error.message}`);
                        }
                    };

                    composer.querySelector('#assistant-send').addEventListener('click', send);
                    composer.querySelector('#assistant-input').addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); }
                    });

                    // Basic styles
                    const style = document.createElement('style');
                    style.textContent = `
                      .assistant { display: flex; flex-direction: column; height: 100%; gap: 10px; }
                      .assistant-toolbar { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
                      .assistant-settings { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; padding: 8px 0; }
                      .assistant-settings label { display:flex; flex-direction: column; font-size: 12px; gap:4px; }
                      .assistant-hint { color: var(--text-muted); font-size: 12px; }
                      .assistant-chat { flex: 1; overflow: auto; border: var(--border-soft); border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.06); }
                      [data-theme="light"] .assistant-chat { background: rgba(0,0,0,0.04); }
                      .assistant-messages { display: flex; flex-direction: column; gap: 10px; }
                      .assistant-msg { display:flex; }
                      .assistant-msg.user { justify-content: flex-end; }
                      .assistant-msg .bubble { max-width: 70%; padding: 10px 12px; border-radius: 12px; white-space: pre-wrap; background: rgba(10,132,255,0.15); border: 1px solid rgba(10,132,255,0.25); }
                      .assistant-msg.user .bubble { background: rgba(88,110,255,0.18); border-color: rgba(88,110,255,0.28); }
                      .assistant-composer { display:flex; gap: 8px; }
                      .assistant-composer textarea { flex:1; resize: vertical; min-height: 42px; border-radius: 10px; border: var(--border-soft); padding: 8px; font-family: inherit; }
                    `;
                    root.appendChild(style);

                    return { element: root, width: '780px', height: '560px' };
                }
            };
        }
        function createTasksApp() {
            return {
                id: 'tasks',
                name: 'Task Command',
                icon: '✅',
                launch({ context = {}, fileSystem, notifications }) {
                    const TASKS_FILE = '/System/tasks.json';
                    const DEFAULT_PROJECTS = [
                        { id: 'inbox', name: 'Inbox', color: '#7b8bff', builtIn: true }
                    ];
                    const PRIORITIES = [
                        { id: 'low', label: 'Low' },
                        { id: 'normal', label: 'Normal' },
                        { id: 'high', label: 'High' },
                        { id: 'urgent', label: 'Urgent' }
                    ];
                    const priorityWeight = { low: 0, normal: 1, high: 2, urgent: 3 };

                    const load = () => {
                        try {
                            const raw = localStorage.getItem(STORAGE_KEYS.TASKS);
                            if (raw) return JSON.parse(raw);
                        } catch (error) {
                            console.warn('Failed to parse stored tasks', error);
                        }
                        try {
                            if (fileSystem.exists(TASKS_FILE)) {
                                const text = fileSystem.readFile(TASKS_FILE, { encoding: 'utf-8' });
                                const parsed = JSON.parse(text);
                                localStorage.setItem(STORAGE_KEYS.TASKS, JSON.stringify(parsed));
                                return parsed;
                            }
                        } catch (error) {
                            console.warn('Failed to load tasks from file system', error);
                        }
                        return { projects: DEFAULT_PROJECTS.map(project => ({ ...project })), tasks: [] };
                    };

                    const normalize = (raw) => {
                        const result = { projects: [], tasks: [] };
                        const seen = new Map();
                        const ensureProject = (project, forceBuiltIn = false) => {
                            if (!project || !project.id) return;
                            if (seen.has(project.id)) {
                                const existing = seen.get(project.id);
                                existing.name = project.name || existing.name;
                                if (project.color) existing.color = project.color;
                                if (forceBuiltIn || project.builtIn) existing.builtIn = true;
                                return;
                            }
                            const entry = {
                                id: project.id,
                                name: project.name || 'Untitled',
                                color: project.color || '#7b8bff',
                                builtIn: Boolean(project.builtIn || forceBuiltIn)
                            };
                            seen.set(entry.id, entry);
                            result.projects.push(entry);
                        };
                        DEFAULT_PROJECTS.forEach(project => ensureProject(project, true));
                        (raw?.projects || []).forEach(project => ensureProject(project));
                        const projectSet = new Set(result.projects.map(project => project.id));
                        (raw?.tasks || []).forEach(task => {
                            if (!task) return;
                            const id = task.id || utils.uuid();
                            const title = (task.title ? String(task.title).trim() : '') || 'Untitled Task';
                            const dueValid = task.dueAt && !Number.isNaN(new Date(task.dueAt).getTime()) ? task.dueAt : null;
                            const completedValid = task.completedAt && !Number.isNaN(new Date(task.completedAt).getTime()) ? task.completedAt : null;
                            result.tasks.push({
                                id,
                                title,
                                notes: task.notes ? String(task.notes) : '',
                                projectId: projectSet.has(task.projectId) ? task.projectId : 'inbox',
                                dueAt: dueValid,
                                priority: PRIORITIES.some(entry => entry.id === task.priority) ? task.priority : 'normal',
                                focus: Boolean(task.focus),
                                createdAt: task.createdAt || utils.nowISO(),
                                updatedAt: task.updatedAt || utils.nowISO(),
                                completedAt: completedValid
                            });
                        });
                        return result;
                    };

                    const state = {
                        data: normalize(load()),
                        filter: { type: 'smart', value: 'all' },
                        search: '',
                        selectedTaskId: null,
                        focusSessionActive: false,
                        focusSkipped: new Set()
                    };

                    const initial = state.data.tasks.find(task => !task.completedAt) || state.data.tasks[0];
                    state.selectedTaskId = initial ? initial.id : null;

                    const shell = utils.createEl('div', 'app-shell task-app');
                    const sidebar = utils.createEl('aside', 'task-sidebar');
                    const main = utils.createEl('section', 'task-main');
                    const detail = utils.createEl('aside', 'task-detail');
                    shell.append(sidebar, main, detail);

                    const sidebarHeader = document.createElement('header');
                    const sidebarTitle = document.createElement('h3');
                    sidebarTitle.textContent = 'Navigator';
                    const captureButton = utils.createEl('button', '', { type: 'button', text: 'New Task' });
                    sidebarHeader.append(sidebarTitle, captureButton);
                    const filterList = utils.createEl('ul', 'task-filter-list');
                    const projectsTitle = document.createElement('h3');
                    projectsTitle.textContent = 'Projects';
                    const projectList = utils.createEl('ul', 'task-project-list');
                    const projectForm = utils.createEl('form', 'task-new-project');
                    const projectNameInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-project-name',
                        name: 'project-name',
                        placeholder: 'Project name',
                        required: 'true'
                    });
                    const projectNameLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-project-name',
                        text: 'Project name'
                    });
                    const projectColorInput = utils.createEl('input', '', {
                        type: 'color',
                        id: 'task-project-colour',
                        name: 'project-colour',
                        value: '#64b5ff'
                    });
                    const projectColorLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-project-colour',
                        text: 'Project colour'
                    });
                    const projectAddButton = utils.createEl('button', '', { type: 'submit', text: 'Add' });
                    projectForm.append(projectNameLabel, projectNameInput, projectColorLabel, projectColorInput, projectAddButton);
                    sidebar.append(sidebarHeader, filterList, projectsTitle, projectList, projectForm);

                    const toolbar = utils.createEl('div', 'task-toolbar');
                    const quickAddInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-quick-add',
                        name: 'task-quick-add',
                        placeholder: 'Capture a task and press Enter',
                        autocomplete: 'off'
                    });
                    const quickAddLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-quick-add',
                        text: 'Quick add task'
                    });
                    const focusButton = utils.createEl('button', '', { type: 'button', text: 'Start Focus' });
                    const searchInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-search',
                        name: 'task-search',
                        placeholder: 'Search tasks'
                    });
                    const searchLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-search',
                        text: 'Search tasks'
                    });
                    searchInput.style.flex = '0 0 220px';
                    searchInput.value = state.search;
                    toolbar.append(quickAddLabel, quickAddInput, focusButton, searchLabel, searchInput);
                    const taskList = utils.createEl('div', 'task-list');
                    const focusPanel = utils.createEl('div', 'task-focus-panel');
                    main.append(toolbar, taskList, focusPanel);

                    const detailHeader = document.createElement('h3');
                    detailHeader.textContent = 'Task Detail';
                    const detailEmpty = utils.createEl('div', 'task-detail-empty', { text: 'Select a task or capture a new one to get started.' });
                    const detailForm = utils.createEl('div', 'task-detail-form');
                    const titleInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-detail-title',
                        name: 'task-title'
                    });
                    const projectSelect = document.createElement('select');
                    projectSelect.id = 'task-detail-project';
                    projectSelect.name = 'task-project';
                    const prioritySelect = document.createElement('select');
                    prioritySelect.id = 'task-detail-priority';
                    prioritySelect.name = 'task-priority';
                    PRIORITIES.forEach(priority => {
                        const option = document.createElement('option');
                        option.value = priority.id;
                        option.textContent = priority.label;
                        prioritySelect.appendChild(option);
                    });
                    const dueInput = utils.createEl('input', '', {
                        type: 'datetime-local',
                        id: 'task-detail-due',
                        name: 'task-due'
                    });
                    const focusToggleRow = utils.createEl('div', 'task-detail-row');
                    const focusLabel = document.createElement('label');
                    focusLabel.setAttribute('for', 'task-detail-focus');
                    const focusInput = document.createElement('input');
                    focusInput.type = 'checkbox';
                    focusInput.id = 'task-detail-focus';
                    focusInput.name = 'task-focus';
                    focusLabel.append(focusInput, document.createTextNode(' Add to focus queue'));
                    focusToggleRow.append(focusLabel);
                    const notesInput = document.createElement('textarea');
                    notesInput.id = 'task-detail-notes';
                    notesInput.name = 'task-notes';
                    const metaBlock = utils.createEl('div', 'task-meta');
                    const footer = document.createElement('footer');
                    const completeButton = document.createElement('button');
                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('danger');
                    deleteButton.textContent = 'Delete';
                    completeButton.type = 'button';
                    deleteButton.type = 'button';
                    footer.append(completeButton, deleteButton);

                    const createRow = (labelText, control) => {
                        const row = utils.createEl('div', 'task-detail-row');
                        const label = document.createElement('label');
                        label.textContent = labelText;
                        if (control.id) label.setAttribute('for', control.id);
                        row.append(label, control);
                        return row;
                    };

                    detailForm.append(
                        createRow('Title', titleInput),
                        createRow('Project', projectSelect),
                        createRow('Priority', prioritySelect),
                        createRow('Due', dueInput),
                        focusToggleRow,
                        createRow('Notes', notesInput),
                        metaBlock,
                        footer
                    );
                    detail.append(detailHeader, detailEmpty, detailForm);

                    const getProjectById = (id) => state.data.projects.find(project => project.id === id) || null;

                    function getDateBounds() {
                        const now = new Date();
                        const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                        const endOfToday = new Date(startOfToday.getTime() + 86_400_000);
                        const upcomingLimit = new Date(startOfToday.getTime() + 8 * 86_400_000);
                        return { startOfToday, endOfToday, upcomingLimit };
                    }

                    function sortTasks(tasks) {
                        return tasks.sort((a, b) => {
                            const completedDiff = (a.completedAt ? 1 : 0) - (b.completedAt ? 1 : 0);
                            if (completedDiff !== 0) return completedDiff;
                            const aDue = a.dueAt ? new Date(a.dueAt).getTime() : Infinity;
                            const bDue = b.dueAt ? new Date(b.dueAt).getTime() : Infinity;
                            if (aDue !== bDue) return aDue - bDue;
                            const priorityDiff = priorityWeight[b.priority] - priorityWeight[a.priority];
                            if (priorityDiff !== 0) return priorityDiff;
                            const updatedDiff = new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
                            if (updatedDiff !== 0) return updatedDiff;
                            return a.title.localeCompare(b.title);
                        });
                    }

                    function getDueInfo(task) {
                        if (!task.dueAt) return null;
                        const due = new Date(task.dueAt);
                        if (Number.isNaN(due.getTime())) return null;
                        const diff = due.getTime() - Date.now();
                        if (Math.abs(diff) < 60_000) return { label: 'Due now', className: 'due-soon' };
                        if (diff < -60_000) return { label: utils.relativeTime(due), className: 'overdue' };
                        if (diff < 3 * 86_400_000) return { label: utils.relativeTime(due), className: 'due-soon' };
                        return { label: due.toLocaleDateString(), className: '' };
                    }

                    function countForFilter(id) {
                        const { endOfToday, upcomingLimit } = getDateBounds();
                        switch (id) {
                            case 'all':
                                return state.data.tasks.filter(task => !task.completedAt).length;
                            case 'today':
                                return state.data.tasks.filter(task => {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due < endOfToday;
                                }).length;
                            case 'upcoming':
                                return state.data.tasks.filter(task => {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due >= endOfToday && due < upcomingLimit;
                                }).length;
                            case 'focus':
                                return state.data.tasks.filter(task => task.focus && !task.completedAt).length;
                            case 'completed':
                                return state.data.tasks.filter(task => task.completedAt).length;
                            default:
                                return 0;
                        }
                    }

                    function getFilteredTasks() {
                        const { endOfToday, upcomingLimit } = getDateBounds();
                        const query = state.search.trim().toLowerCase();
                        return state.data.tasks.filter(task => {
                            const matchesQuery = !query || task.title.toLowerCase().includes(query) || task.notes.toLowerCase().includes(query);
                            if (!matchesQuery) return false;
                            if (state.filter.type === 'project') {
                                if (task.projectId !== state.filter.value) return false;
                                return !task.completedAt;
                            }
                            switch (state.filter.value) {
                                case 'all':
                                    return !task.completedAt;
                                case 'today': {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due < endOfToday;
                                }
                                case 'upcoming': {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due >= endOfToday && due < upcomingLimit;
                                }
                                case 'focus':
                                    return task.focus && !task.completedAt;
                                case 'completed':
                                    return Boolean(task.completedAt);
                                default:
                                    return !task.completedAt;
                            }
                        });
                    }

                    function renderFilters() {
                        const filters = [
                            { id: 'all', label: 'All tasks', icon: '📋' },
                            { id: 'today', label: 'Today', icon: '🗓️' },
                            { id: 'upcoming', label: 'Upcoming', icon: '📅' },
                            { id: 'focus', label: 'Focus', icon: '🎯' },
                            { id: 'completed', label: 'Completed', icon: '✅' }
                        ];
                        filterList.innerHTML = '';
                        filters.forEach(filter => {
                            const item = utils.createEl('li', 'task-filter-item');
                            if (state.filter.type === 'smart' && state.filter.value === filter.id) item.classList.add('active');
                            const icon = document.createElement('span');
                            icon.textContent = filter.icon;
                            const label = document.createElement('strong');
                            label.textContent = filter.label;
                            const count = utils.createEl('span', 'count', { text: String(countForFilter(filter.id)) });
                            item.append(icon, label, count);
                            item.addEventListener('click', () => {
                                if (state.filter.type === 'smart' && state.filter.value === filter.id) return;
                                setFilter('smart', filter.id);
                            });
                            filterList.appendChild(item);
                        });
                    }

                    function renderProjects() {
                        projectList.innerHTML = '';
                        state.data.projects.forEach(project => {
                            const item = utils.createEl('li', 'task-project-item');
                            if (state.filter.type === 'project' && state.filter.value === project.id) item.classList.add('active');
                            const colorDot = utils.createEl('span', 'task-project-color');
                            colorDot.style.background = project.color;
                            const label = document.createElement('strong');
                            label.textContent = project.name;
                            const count = utils.createEl('span', 'count', { text: String(state.data.tasks.filter(task => task.projectId === project.id && !task.completedAt).length) });
                            item.append(colorDot, label, count);
                            if (!project.builtIn) {
                                const remove = document.createElement('button');
                                remove.type = 'button';
                                remove.textContent = '✕';
                                remove.title = 'Delete project';
                                remove.addEventListener('click', event => {
                                    event.stopPropagation();
                                    if (confirm(`Remove project "${project.name}"? Tasks will move to Inbox.`)) {
                                        deleteProject(project.id);
                                    }
                                });
                                item.appendChild(remove);
                            }
                            item.addEventListener('click', () => setFilter('project', project.id));
                            projectList.appendChild(item);
                        });
                    }

                    function renderTaskList() {
                        const visibleTasks = sortTasks(getFilteredTasks().slice());
                        taskList.innerHTML = '';
                        taskList.style.display = state.focusSessionActive ? 'none' : 'flex';
                        if (state.focusSessionActive) return;
                        if (!visibleTasks.some(task => task.id === state.selectedTaskId)) {
                            state.selectedTaskId = visibleTasks[0]?.id || null;
                        }
                        if (!visibleTasks.length) {
                            const emptyMessage = state.search ? 'No tasks match your filters yet.' : 'No tasks here yet. Capture something above.';
                            taskList.appendChild(utils.createEl('div', 'task-detail-empty', { text: emptyMessage }));
                            return;
                        }
                        visibleTasks.forEach(task => {
                            const card = utils.createEl('div', 'task-card');
                            card.dataset.id = task.id;
                            if (task.id === state.selectedTaskId) card.classList.add('active');
                            if (task.completedAt) card.classList.add('completed');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = Boolean(task.completedAt);
                            card.appendChild(checkbox);
                            const body = document.createElement('div');
                            const title = document.createElement('h4');
                            title.textContent = task.title;
                            body.appendChild(title);
                            const meta = utils.createEl('div', 'task-meta');
                            const project = getProjectById(task.projectId);
                            if (project) meta.appendChild(utils.createEl('span', 'task-chip', { text: project.name }));
                            const dueInfo = getDueInfo(task);
                            if (dueInfo) {
                                const chip = utils.createEl('span', 'task-chip', { text: dueInfo.label });
                                if (dueInfo.className) chip.classList.add(dueInfo.className);
                                meta.appendChild(chip);
                            }
                            if (task.priority === 'high' || task.priority === 'urgent') {
                                const chip = utils.createEl('span', 'task-chip', { text: task.priority === 'high' ? 'High priority' : 'Urgent' });
                                chip.classList.add(task.priority === 'high' ? 'priority-high' : 'priority-urgent');
                                meta.appendChild(chip);
                            }
                            if (task.focus && !task.completedAt) meta.appendChild(utils.createEl('span', 'task-chip', { text: 'Focus' }));
                            body.appendChild(meta);
                            card.appendChild(body);
                            const actions = utils.createEl('div', 'task-actions');
                            const focusToggle = document.createElement('button');
                            focusToggle.title = task.focus ? 'Remove from focus queue' : 'Add to focus queue';
                            focusToggle.textContent = task.focus ? '★' : '☆';
                            actions.appendChild(focusToggle);
                            card.appendChild(actions);
                            checkbox.addEventListener('click', event => {
                                event.stopPropagation();
                                softSync.flush?.();
                                setTaskCompleted(task.id, checkbox.checked);
                            });
                            focusToggle.addEventListener('click', event => {
                                event.stopPropagation();
                                softSync.flush?.();
                                task.focus = !task.focus;
                                if (task.focus) task.completedAt = null;
                                task.updatedAt = utils.nowISO();
                                state.focusSkipped.delete(task.id);
                                persist();
                                syncUI();
                            });
                            card.addEventListener('click', () => {
                                if (state.selectedTaskId !== task.id) {
                                    state.selectedTaskId = task.id;
                                    renderTaskList();
                                    renderDetail();
                                }
                            });
                            taskList.appendChild(card);
                        });
                    }

                    function getSelectedTask() {
                        return state.data.tasks.find(task => task.id === state.selectedTaskId) || null;
                    }

                    function formatDateInput(iso) {
                        if (!iso) return '';
                        const date = new Date(iso);
                        if (Number.isNaN(date.getTime())) return '';
                        const pad = (value) => String(value).padStart(2, '0');
                        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
                    }

                    function buildMetaLine(task) {
                        const parts = [];
                        if (task.createdAt) parts.push(`Created ${utils.relativeTime(task.createdAt)}`);
                        if (task.updatedAt) parts.push(`Updated ${utils.relativeTime(task.updatedAt)}`);
                        if (task.completedAt) parts.push(`Completed ${utils.relativeTime(task.completedAt)}`);
                        return parts.filter(Boolean).join(' · ');
                    }

                    function renderDetail() {
                        const task = getSelectedTask();
                        if (!task) {
                            detailEmpty.style.display = 'block';
                            detailForm.style.display = 'none';
                            [titleInput, projectSelect, prioritySelect, dueInput, focusInput, notesInput, completeButton, deleteButton].forEach(control => control.disabled = true);
                            metaBlock.textContent = '';
                            return;
                        }
                        detailEmpty.style.display = 'none';
                        detailForm.style.display = 'flex';
                        [titleInput, projectSelect, prioritySelect, dueInput, focusInput, notesInput, completeButton, deleteButton].forEach(control => control.disabled = false);
                        if (document.activeElement !== titleInput) titleInput.value = task.title;
                        if (projectSelect.value !== task.projectId) projectSelect.value = task.projectId;
                        prioritySelect.value = task.priority;
                        dueInput.value = formatDateInput(task.dueAt);
                        focusInput.checked = Boolean(task.focus);
                        if (document.activeElement !== notesInput) notesInput.value = task.notes || '';
                        metaBlock.textContent = buildMetaLine(task);
                        completeButton.textContent = task.completedAt ? 'Reopen Task' : 'Mark Complete';
                        completeButton.dataset.complete = task.completedAt ? 'true' : 'false';
                    }

                    function getNextFocusTask() {
                        const pool = state.data.tasks.filter(task => task.focus && !task.completedAt && !state.focusSkipped.has(task.id));
                        if (!pool.length) return null;
                        return sortTasks(pool).shift() || null;
                    }

                    function renderFocusPanel() {
                        focusPanel.innerHTML = '';
                        focusPanel.classList.toggle('active', state.focusSessionActive);
                        if (!state.focusSessionActive) return;
                        const next = getNextFocusTask();
                        if (!next) {
                            const empty = utils.createEl('div', 'task-focus-card');
                            empty.innerHTML = '<h2>Focus queue is clear</h2><p>Flag tasks with ★ to prepare your next focus sprint.</p>';
                            focusPanel.appendChild(empty);
                            return;
                        }
                        state.selectedTaskId = next.id;
                        const card = utils.createEl('div', 'task-focus-card');
                        const title = document.createElement('h2');
                        title.textContent = next.title;
                        card.appendChild(title);
                        const meta = utils.createEl('div', 'task-meta');
                        const project = getProjectById(next.projectId);
                        if (project) meta.appendChild(utils.createEl('span', 'task-chip', { text: project.name }));
                        const dueInfo = getDueInfo(next);
                        if (dueInfo) {
                            const chip = utils.createEl('span', 'task-chip', { text: dueInfo.label });
                            if (dueInfo.className) chip.classList.add(dueInfo.className);
                            meta.appendChild(chip);
                        }
                        if (next.priority === 'high' || next.priority === 'urgent') {
                            const chip = utils.createEl('span', 'task-chip', { text: next.priority === 'high' ? 'High priority' : 'Urgent' });
                            chip.classList.add(next.priority === 'high' ? 'priority-high' : 'priority-urgent');
                            meta.appendChild(chip);
                        }
                        card.appendChild(meta);
                        const notes = document.createElement('p');
                        notes.textContent = next.notes ? next.notes : 'No notes for this task yet.';
                        notes.style.opacity = next.notes ? '1' : '0.6';
                        card.appendChild(notes);
                        const actions = utils.createEl('div', 'task-focus-actions');
                        const completeBtn = document.createElement('button');
                        completeBtn.textContent = 'Complete';
                        const skipBtn = document.createElement('button');
                        skipBtn.classList.add('secondary');
                        skipBtn.textContent = 'Skip';
                        actions.append(completeBtn, skipBtn);
                        card.appendChild(actions);
                        focusPanel.appendChild(card);
                        completeBtn.addEventListener('click', () => {
                            softSync.flush?.();
                            setTaskCompleted(next.id, true);
                        });
                        skipBtn.addEventListener('click', () => {
                            state.focusSkipped.add(next.id);
                            renderFocusPanel();
                        });
                    }

                    function updateFocusButton() {
                        focusButton.textContent = state.focusSessionActive ? 'End Focus' : 'Start Focus';
                        focusButton.classList.toggle('active', state.focusSessionActive);
                    }

                    function syncUI() {
                        renderFilters();
                        renderProjects();
                        renderTaskList();
                        renderFocusPanel();
                        renderDetail();
                        updateFocusButton();
                    }

                    function persist() {
                        const payload = JSON.stringify(state.data, null, 2);
                        localStorage.setItem(STORAGE_KEYS.TASKS, payload);
                        try {
                            if (!fileSystem.exists('/System')) fileSystem.createDirectory('/System');
                        } catch (error) {}
                        try {
                            if (fileSystem.exists(TASKS_FILE)) {
                                fileSystem.writeFile(TASKS_FILE, payload, { encoding: 'utf-8', mime: 'application/json' });
                            } else {
                                fileSystem.createFile(TASKS_FILE, payload, { encoding: 'utf-8', mime: 'application/json' });
                            }
                        } catch (error) {
                            console.warn('Failed to persist tasks file', error);
                        }
                    }

                    function setFilter(type, value) {
                        state.filter = { type, value };
                        if (type !== 'smart' || value !== 'focus') {
                            state.focusSessionActive = false;
                            state.focusSkipped.clear();
                        }
                        syncUI();
                    }

                    function populateProjectSelect() {
                        projectSelect.innerHTML = '';
                        state.data.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.name;
                            projectSelect.appendChild(option);
                        });
                    }

                    function createProject(name, color) {
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        const base = trimmed.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                        let id = base || `project-${Math.random().toString(16).slice(2, 6)}`;
                        while (state.data.projects.some(project => project.id === id)) {
                            id = `${base || 'project'}-${Math.random().toString(16).slice(2, 6)}`;
                        }
                        state.data.projects.push({ id, name: trimmed, color, builtIn: false });
                        softSync.cancel?.();
                        persist();
                        populateProjectSelect();
                        notifications.notify('Project added', trimmed);
                        setFilter('project', id);
                    }

                    function deleteProject(projectId) {
                        const project = state.data.projects.find(entry => entry.id === projectId);
                        if (!project || project.builtIn) return;
                        state.data.tasks.forEach(task => {
                            if (task.projectId === projectId) {
                                task.projectId = 'inbox';
                                task.updatedAt = utils.nowISO();
                            }
                        });
                        state.data.projects = state.data.projects.filter(entry => entry.id !== projectId);
                        softSync.cancel?.();
                        persist();
                        populateProjectSelect();
                        notifications.notify('Project removed', `${project.name} archived`);
                        if (state.filter.type === 'project' && state.filter.value === projectId) {
                            setFilter('smart', 'all');
                        } else {
                            syncUI();
                        }
                    }

                    function createTask({ title, projectId }) {
                        const trimmed = title.trim();
                        if (!trimmed) return;
                        softSync.flush?.();
                        const projectExists = state.data.projects.some(project => project.id === projectId);
                        const now = utils.nowISO();
                        const task = {
                            id: utils.uuid(),
                            title: trimmed,
                            notes: '',
                            projectId: projectExists ? projectId : 'inbox',
                            dueAt: null,
                            priority: 'normal',
                            focus: false,
                            createdAt: now,
                            updatedAt: now,
                            completedAt: null
                        };
                        state.data.tasks.unshift(task);
                        state.selectedTaskId = task.id;
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task captured', trimmed);
                        syncUI();
                    }

                    function setTaskCompleted(taskId, completed) {
                        const task = state.data.tasks.find(entry => entry.id === taskId);
                        if (!task) return;
                        if (completed) {
                            task.completedAt = utils.nowISO();
                            task.focus = false;
                        } else {
                            task.completedAt = null;
                        }
                        task.updatedAt = utils.nowISO();
                        state.focusSkipped.delete(taskId);
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task updated', completed ? `${task.title} completed` : `${task.title} reopened`);
                        syncUI();
                    }

                    function deleteTask(taskId) {
                        const index = state.data.tasks.findIndex(entry => entry.id === taskId);
                        if (index === -1) return;
                        softSync.flush?.();
                        const [removed] = state.data.tasks.splice(index, 1);
                        state.focusSkipped.delete(taskId);
                        if (state.selectedTaskId === taskId) {
                            const replacement = state.data.tasks.find(task => !task.completedAt) || state.data.tasks[0];
                            state.selectedTaskId = replacement ? replacement.id : null;
                        }
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task deleted', removed.title);
                        syncUI();
                    }

                    const softSync = utils.debounce(() => {
                        persist();
                        syncUI();
                    }, 260);

                    captureButton.addEventListener('click', () => quickAddInput.focus());
                    projectForm.addEventListener('submit', event => {
                        event.preventDefault();
                        createProject(projectNameInput.value, projectColorInput.value || '#7b8bff');
                        projectNameInput.value = '';
                    });
                    quickAddInput.addEventListener('keydown', event => {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            const targetProject = state.filter.type === 'project' ? state.filter.value : 'inbox';
                            createTask({ title: quickAddInput.value, projectId: targetProject });
                            quickAddInput.value = '';
                        }
                    });
                    searchInput.addEventListener('input', () => {
                        state.search = searchInput.value;
                        renderTaskList();
                        if (!state.focusSessionActive) renderDetail();
                    });
                    focusButton.addEventListener('click', () => {
                        softSync.flush?.();
                        state.focusSessionActive = !state.focusSessionActive;
                        if (state.focusSessionActive) {
                            state.focusSkipped.clear();
                            if (!getNextFocusTask()) notifications.notify('Focus', 'No tasks flagged for focus yet.');
                        } else {
                            state.focusSkipped.clear();
                        }
                        syncUI();
                    });

                    titleInput.addEventListener('input', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.title = titleInput.value;
                        task.updatedAt = utils.nowISO();
                        softSync();
                    });
                    titleInput.addEventListener('blur', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        const trimmed = titleInput.value.trim();
                        if (!trimmed) {
                            task.title = 'Untitled Task';
                            titleInput.value = task.title;
                        } else if (task.title !== trimmed) {
                            task.title = trimmed;
                            titleInput.value = trimmed;
                        }
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    notesInput.addEventListener('input', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.notes = notesInput.value;
                        task.updatedAt = utils.nowISO();
                        softSync();
                    });
                    prioritySelect.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.priority = prioritySelect.value;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    projectSelect.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.projectId = projectSelect.value;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    dueInput.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.dueAt = dueInput.value ? new Date(dueInput.value).toISOString() : null;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    focusInput.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.focus = focusInput.checked;
                        if (task.focus) task.completedAt = null;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    completeButton.addEventListener('click', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        setTaskCompleted(task.id, !task.completedAt);
                    });
                    deleteButton.addEventListener('click', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        if (confirm(`Delete "${task.title}"? This cannot be undone.`)) {
                            deleteTask(task.id);
                        }
                    });

                    populateProjectSelect();
                    if (context?.projectId && state.data.projects.some(project => project.id === context.projectId)) {
                        state.filter = { type: 'project', value: context.projectId };
                    } else if (context?.showCompleted) {
                        state.filter = { type: 'smart', value: 'completed' };
                    }
                    if (context?.focus) state.focusSessionActive = true;

                    syncUI();

                    return {
                        element: shell,
                        title: 'Task Command',
                        width: '960px',
                        height: '640px',
                        onClose: () => {
                            softSync.flush?.();
                            persist();
                        }
                    };
                }
            };
        }
        function createTextEditorApp() {
            return {
                id: 'text-editor',
                name: 'Text Studio',
                icon: '📝',
                launch({ context, fileSystem, notifications, appManager }) {
                    const state = {
                        path: context.path || null,
                        dirty: false,
                        encoding: 'utf-8'
                    };

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="new">🆕 New</button>
                        <button data-action="open">📂 Open</button>
                        <button data-action="save">💾 Save</button>
                        <button data-action="save-as">📝 Save As</button>
                        <button data-action="find">🔍 Find</button>
                        <button data-action="print">🖨️ Print</button>
                        <select data-role="encoding">
                            <option value="utf-8">UTF-8</option>
                        </select>
                        <span style="margin-left:auto">${state.path || 'New document'}</span>
                    `;
                    const encodingSelect = toolbar.querySelector('select');
                    const statusLabel = toolbar.querySelector('span:last-child');
                    const editor = utils.createEl('textarea', 'editor-area');
                    const status = utils.createEl('div', 'editor-status');
                    status.innerHTML = '<span>Ln 1, Col 1</span><span>UTF-8</span>';
                    shell.append(toolbar, editor, status);

                    const updateCursor = () => {
                        const pos = editor.selectionStart;
                        const text = editor.value.slice(0, pos);
                        const lines = text.split('\n');
                        const line = lines.length;
                        const column = lines[lines.length - 1].length + 1;
                        status.firstChild.textContent = `Ln ${line}, Col ${column}`;
                    };

                    editor.addEventListener('input', () => {
                        state.dirty = true;
                        updateCursor();
                    });
                    editor.addEventListener('click', updateCursor);
                    editor.addEventListener('keyup', updateCursor);

                    function loadFile(path) {
                        try {
                            const content = fileSystem.readFile(path, { encoding: state.encoding });
                            editor.value = content;
                            state.path = path;
                            state.dirty = false;
                            statusLabel.textContent = path;
                            notifications.notify('File opened', path);
                            updateCursor();
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    if (state.path) loadFile(state.path);

                    function saveFile() {
                        if (!state.path) return saveAs();
                        try {
                            fileSystem.writeFile(state.path, editor.value, { encoding: state.encoding });
                            state.dirty = false;
                            notifications.notify('Saved', state.path);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    function saveAs() {
                        const name = prompt('Save as', state.path ? state.path.split('/').pop() : 'New file.txt');
                        if (!name) return;
                        const target = `/Documents/${name}`;
                        try {
                            if (fileSystem.exists(target)) {
                                if (!confirm('Overwrite existing file?')) return;
                                fileSystem.writeFile(target, editor.value, { encoding: state.encoding });
                            } else {
                                fileSystem.createFile(target, editor.value, { encoding: state.encoding, mime: utils.mimeFromName(name) });
                            }
                            state.path = target;
                            state.dirty = false;
                            statusLabel.textContent = target;
                            notifications.notify('Saved', target);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    function openFileDialog() {
                        appManager.open('toastsearcher', {
                            path: '/Documents',
                            selectMode: selectedPath => {
                                loadFile(selectedPath);
                            }
                        });
                    }

                    function findDialog() {
                        const query = prompt('Find text');
                        if (!query) return;
                        const start = editor.selectionEnd;
                        const index = editor.value.indexOf(query, start);
                        if (index !== -1) {
                            editor.focus();
                            editor.setSelectionRange(index, index + query.length);
                        } else {
                            notifications.notify('Find', 'No more matches found.');
                        }
                    }

                    toolbar.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'new':
                                if (state.dirty && !confirm('Discard unsaved changes?')) return;
                                editor.value = '';
                                state.path = null;
                                state.dirty = false;
                                statusLabel.textContent = 'New document';
                                break;
                            case 'open':
                                openFileDialog();
                                break;
                            case 'save':
                                saveFile();
                                break;
                            case 'save-as':
                                saveAs();
                                break;
                            case 'find':
                                findDialog();
                                break;
                            case 'print':
                                window.print();
                                break;
                        }
                    });

                    encodingSelect.addEventListener('change', () => {
                        state.encoding = encodingSelect.value;
                        status.lastChild.textContent = state.encoding.toUpperCase();
                        if (state.path) loadFile(state.path);
                    });

                    return {
                        element: shell,
                        title: state.path ? `Text Studio — ${state.path.split('/').pop()}` : 'Text Studio',
                        width: '840px',
                        height: '580px',
                        onClose: () => {
                            if (state.dirty && !confirm('Close without saving?')) return false;
                        }
                    };
                }
            };
        }
        function createCalculatorApp() {
            const keys = [
                'MC','MR','M+','M-','C',
                '7','8','9','/','sin',
                '4','5','6','*','cos',
                '1','2','3','-','tan',
                '0','.','=','+','√',
                '(',')','log','^','π'
            ];
            return {
                id: 'calculator',
                name: 'ScientiCalc',
                icon: '🧮',
                launch({ notifications }) {
                    let memory = 0;
                    let expression = '0';
                    const history = [];

                    const container = utils.createEl('div', 'calculator');
                    const display = utils.createEl('div', 'calc-display', { text: expression });
                    const grid = utils.createEl('div', 'calc-grid');
                    const historyPanel = utils.createEl('div', 'preview-card');
                    historyPanel.style.maxHeight = '140px';
                    historyPanel.style.overflow = 'auto';
                    historyPanel.innerHTML = '<strong>History</strong><div class="preview-body"></div>';
                    const historyBody = historyPanel.querySelector('.preview-body');

                    const updateDisplay = value => { expression = value; display.textContent = value || '0'; };

                    const commitHistory = (expr, result) => {
                        history.unshift({ expr, result });
                        historyBody.innerHTML = history.slice(0, 12).map(item => `<div><strong>${item.expr}</strong><br>${item.result}</div>`).join('');
                    };

                    const evaluate = () => {
                        try {
                            const expr = expression
                                .replace(/π/g, Math.PI.toString())
                                .replace(/√/g, 'Math.sqrt')
                                .replace(/sin/g, 'Math.sin')
                                .replace(/cos/g, 'Math.cos')
                                .replace(/tan/g, 'Math.tan')
                                .replace(/log/g, 'Math.log10')
                                .replace(/\^/g, '**');
                            const result = Function(`"use strict"; return (${expr});`)();
                            commitHistory(expression, result);
                            updateDisplay(String(result));
                        } catch (error) {
                            notifications.notify('Calculator', 'Invalid expression');
                            updateDisplay('0');
                        }
                    };

                    keys.forEach(key => {
                        const button = utils.createEl('button', '', { text: key });
                        button.addEventListener('click', () => {
                            switch (key) {
                                case 'C':
                                    updateDisplay('0');
                                    break;
                                case '=':
                                    evaluate();
                                    break;
                                case 'MC':
                                    memory = 0;
                                    notifications.notify('Memory', 'Cleared');
                                    break;
                                case 'MR':
                                    updateDisplay(memory.toString());
                                    break;
                                case 'M+':
                                    memory += Number(expression || 0);
                                    notifications.notify('Memory', `Stored ${memory}`);
                                    break;
                                case 'M-':
                                    memory -= Number(expression || 0);
                                    notifications.notify('Memory', `Stored ${memory}`);
                                    break;
                                default:
                                    if (expression === '0' && !isNaN(Number(key))) updateDisplay(key);
                                    else updateDisplay(expression + key);
                                    break;
                            }
                        });
                        grid.appendChild(button);
                    });

                    container.append(display, grid, historyPanel);
                    return {
                        element: container,
                        width: '420px',
                        height: '520px'
                    };
                }
            };
        }
        function createTerminalApp(desktopManager) {
            return {
                id: 'terminal',
                name: 'Terminal',
                icon: '💻',
                launch({ context, fileSystem, notifications, settings, appManager }) {
                    const terminal = utils.createEl('div', 'terminal');
                    const output = utils.createEl('div', 'terminal-output');
                    const inputBar = utils.createEl('div', 'terminal-input');
                    const promptLabel = utils.createEl('span', '', { text: 'webos> ', style: 'color:#6ff76f;font-weight:600;' });
                    const input = utils.createEl('input', '', { type: 'text', autocomplete: 'off' });
                    inputBar.append(promptLabel, input);
                    terminal.append(output, inputBar);

                    const history = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMINAL_HISTORY) || '[]');
                    let historyIndex = history.length;
                    const env = {
                        PWD: context.path || '/Documents',
                        USER: 'user',
                        HOME: '/Documents'
                    };

                    function writeLine(line = '') {
                        const div = utils.createEl('div');
                        div.innerHTML = line;
                        output.appendChild(div);
                        output.scrollTop = output.scrollHeight;
                    }

                    writeLine('WebOS Terminal — type \"help\" for available commands.');

                    const commands = {
                        help() {
                            return 'Commands: help, clear, pwd, ls, cd, mkdir, rm, cat, touch, write, date, about, theme, open, exportfs, importfs';
                        },
                        clear() {
                            output.innerHTML = '';
                            return '';
                        },
                        pwd() {
                            return env.PWD;
                        },
                        ls(args) {
                            const target = args[0] ? utils.join(env.PWD, args[0]) : env.PWD;
                            try {
                                const entries = fileSystem.listDirectory(target);
                                return entries.map(entry => entry.type === 'directory' ? `<span style="color:#6fa7ff">${entry.name}/</span>` : entry.name).join('  ');
                            } catch (error) {
                                return error.message;
                            }
                        },
                        cd(args) {
                            const target = args[0] ? utils.join(env.PWD, args[0]) : env.HOME;
                            try {
                                fileSystem.ensureDirectory(target);
                                env.PWD = target;
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        mkdir(args) {
                            if (!args[0]) return 'Usage: mkdir <name>';
                            try {
                                fileSystem.createDirectory(utils.join(env.PWD, args[0]));
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        rm(args) {
                            if (!args[0]) return 'Usage: rm <path>';
                            try {
                                fileSystem.delete(utils.join(env.PWD, args[0]));
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        cat(args) {
                            if (!args[0]) return 'Usage: cat <file>';
                            try {
                                return `<pre>${fileSystem.readFile(utils.join(env.PWD, args[0]))}</pre>`;
                            } catch (error) {
                                return error.message;
                            }
                        },
                        touch(args) {
                            if (!args[0]) return 'Usage: touch <file>';
                            const target = utils.join(env.PWD, args[0]);
                            try {
                                if (fileSystem.exists(target)) fileSystem.writeFile(target, fileSystem.readFile(target));
                                else fileSystem.createFile(target, '');
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        write(args) {
                            if (!args[0]) return 'Usage: write <file>';
                            const target = utils.join(env.PWD, args[0]);
                            const content = args.slice(1).join(' ');
                            try {
                                if (fileSystem.exists(target)) fileSystem.writeFile(target, content);
                                else fileSystem.createFile(target, content);
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        date() {
                            return new Date().toString();
                        },
                        about() {
                            return 'WebOS Terminal v1.0 — simulated environment.';
                        },
                        theme(args) {
                            const mode = args[0];
                            if (!['dark', 'light', 'auto'].includes(mode)) return 'Usage: theme <dark|light|auto>';
                            settings.update({ theme: mode });
                            return `Theme set to ${mode}`;
                        },
                        open(args) {
                            if (!args[0]) return 'Usage: open <file>';
                            const target = utils.join(env.PWD, args[0]);
                            try {
                                const meta = fileSystem.readFileMeta(target);
                                appManager.openByFile(target, meta.mime);
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        exportfs() {
                            const data = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM);
                            const blob = new Blob([data], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const anchor = document.createElement('a');
                            anchor.href = url;
                            anchor.download = 'webos-filesystem.json';
                            anchor.click();
                            URL.revokeObjectURL(url);
                            return 'File system exported.';
                        },
                        importfs() {
                            const picker = document.createElement('input');
                            picker.type = 'file';
                            picker.accept = 'application/json';
                            picker.onchange = async () => {
                                const file = picker.files[0];
                                const text = await file.text();
                                localStorage.setItem(STORAGE_KEYS.FILE_SYSTEM, text);
                                fileSystem.load();
                                notifications.notify('File system', 'Imported from backup');
                            };
                            picker.click();
                            return 'Import started (choose file).';
                        }
                    };

                    function runCommand(line) {
                        if (!line.trim()) return;
                        writeLine(`<span style="color:#7bdcff">${env.USER}@webos</span>:<span style="color:#c5b7ff">${env.PWD}</span>$ ${line}`);
                        const parts = line.split('|').map(part => part.trim());
                        let previous = '';
                        for (const part of parts) {
                            const tokens = part.split(' ').filter(Boolean);
                            const command = tokens.shift();
                            if (!command) continue;
                            const handler = commands[command];
                            if (!handler) {
                                previous = `Command not found: ${command}`;
                                break;
                            }
                            previous = handler(tokens, previous) ?? '';
                            if (previous) writeLine(previous);
                        }
                    }

                    input.addEventListener('keydown', event => {
                        if (event.key === 'Enter') {
                            const line = input.value;
                            runCommand(line);
                            history.push(line);
                            localStorage.setItem(STORAGE_KEYS.TERMINAL_HISTORY, JSON.stringify(history.slice(-200)));
                            historyIndex = history.length;
                            input.value = '';
                        } else if (event.key === 'ArrowUp') {
                            if (historyIndex > 0) historyIndex--;
                            input.value = history[historyIndex] || '';
                            setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            event.preventDefault();
                        } else if (event.key === 'ArrowDown') {
                            if (historyIndex < history.length - 1) historyIndex++;
                            else historyIndex = history.length;
                            input.value = history[historyIndex] || '';
                            event.preventDefault();
                        } else if (event.key === 'Tab') {
                            event.preventDefault();
                            const partial = input.value;
                            const entries = fileSystem.listDirectory(env.PWD).map(entry => entry.name);
                            const matches = entries.filter(name => name.startsWith(partial));
                            if (matches.length === 1) input.value = matches[0];
                        }
                    });

                    setTimeout(() => input.focus(), 120);

                    return {
                        element: terminal,
                        width: '760px',
                        height: '540px'
                    };
                }
            };
        }
        function createBrowserApp() {
            return {
                id: 'browser',
                name: 'Web Navigator',
                icon: '🌐',
                launch({ context = {}, fileSystem, notifications, settings }) {
                    const state = {
                        history: [],
                        index: -1,
                        bookmarks: [],
                        downloads: [],
                        currentUrl: '',
                        useProxy: settings.state.useBrowserProxy !== false
                    };

                    const bookmarksFile = '/System/bookmarks.json';

                    const loadBookmarks = () => {
                        try {
                            state.bookmarks = JSON.parse(fileSystem.readFile(bookmarksFile));
                        } catch (error) {
                            state.bookmarks = [];
                        }
                    };

                    const saveBookmarks = () => {
                        try {
                            fileSystem.writeFile(bookmarksFile, JSON.stringify(state.bookmarks, null, 2));
                        } catch (error) {
                            notifications.notify('Bookmarks', `Unable to save bookmarks: ${error.message}`);
                        }
                    };

                    loadBookmarks();

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="back" title="Back">⬅️</button>
                        <button data-action="forward" title="Forward">➡️</button>
                        <button data-action="reload" title="Reload">🔄</button>
                        <button data-action="home" title="Home">🏠</button>
                        <label for="browser-url-input" class="visually-hidden">Address bar</label>
                        <input id="browser-url-input" name="browser-url" type="url" placeholder="Enter address" style="flex:1" />
                        <button data-action="go">Go</button>
                        <button data-action="bookmark" title="Add bookmark">⭐</button>
                        <button data-action="download" title="Save to downloads">⬇️</button>
                        <button data-action="toggle-proxy" title="Toggle proxy"></button>
                        <button data-action="external" title="Open in new tab">↗️</button>
                    `;
                    const urlInput = toolbar.querySelector('#browser-url-input');
                    const proxyButton = toolbar.querySelector('[data-action="toggle-proxy"]');
                    const layout = utils.createEl('div', 'browser-layout');
                    const viewport = utils.createEl('div', 'browser-viewport');
                    const iframe = utils.createEl('iframe');
                    iframe.setAttribute('allow', 'fullscreen; geolocation *; microphone *; camera *');
                    iframe.referrerPolicy = 'no-referrer';
                    viewport.appendChild(iframe);

                    const sidebar = utils.createEl('aside', 'browser-sidebar');
                    sidebar.innerHTML = `
                        <div class="browser-panel">
                            <h3>Bookmarks</h3>
                            <ul class="browser-list" id="browser-bookmarks"></ul>
                        </div>
                        <div class="browser-panel">
                            <h3>History</h3>
                            <ul class="browser-list" id="browser-history"></ul>
                        </div>
                        <div class="browser-panel">
                            <h3>Downloads</h3>
                            <ul class="browser-list" id="browser-downloads"></ul>
                        </div>
                        <div class="browser-status" id="browser-status"></div>
                    `;

                    layout.append(viewport, sidebar);
                    shell.append(toolbar, layout);

                    const bookmarksList = sidebar.querySelector('#browser-bookmarks');
                    const historyList = sidebar.querySelector('#browser-history');
                    const downloadsList = sidebar.querySelector('#browser-downloads');
                    const statusLabel = sidebar.querySelector('#browser-status');

                    const ensureProtocol = (url) => {
                        if (!url) return '';
                        return /^https?:\/\//i.test(url) ? url : `https://${url}`;
                    };

                    const proxiedUrl = (url) => state.useProxy ? `https://r.jina.ai/${url}` : url;

                    const updateProxyButton = () => {
                        proxyButton.textContent = state.useProxy ? '🔒 Proxy' : '🌐 Direct';
                        statusLabel.textContent = state.useProxy ? 'Proxy mode: Improved compatibility for embedded sites.' : 'Direct mode: Sites that block embeds may not load.';
                    };

                    const updateToolbarState = () => {
                        toolbar.querySelector('[data-action="back"]').disabled = state.index <= 0;
                        toolbar.querySelector('[data-action="forward"]').disabled = state.index >= state.history.length - 1;
                        toolbar.querySelector('[data-action="reload"]').disabled = !state.history.length;
                        toolbar.querySelector('[data-action="external"]').disabled = !state.currentUrl;
                        toolbar.querySelector('[data-action="download"]').disabled = !state.currentUrl;
                    };

                    const renderBookmarks = () => {
                        bookmarksList.innerHTML = '';
                        if (!state.bookmarks.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No bookmarks yet</span>';
                            li.style.opacity = '0.7';
                            bookmarksList.appendChild(li);
                            return;
                        }
                        state.bookmarks.forEach((bookmark, index) => {
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = bookmark.title;
                            li.appendChild(span);
                            const openBtn = document.createElement('button');
                            openBtn.dataset.role = 'open-bookmark';
                            openBtn.dataset.index = index;
                            openBtn.textContent = 'Open';
                            const removeBtn = document.createElement('button');
                            removeBtn.dataset.role = 'remove-bookmark';
                            removeBtn.dataset.index = index;
                            removeBtn.textContent = '✕';
                            li.append(openBtn, removeBtn);
                            bookmarksList.appendChild(li);
                        });
                    };

                    const renderHistory = () => {
                        historyList.innerHTML = '';
                        if (!state.history.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No history yet</span>';
                            li.style.opacity = '0.7';
                            historyList.appendChild(li);
                            return;
                        }
                        state.history.slice().reverse().slice(0, 30).forEach((entry, offset) => {
                            const actualIndex = state.history.length - 1 - offset;
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = entry.title || entry.url;
                            li.appendChild(span);
                            const button = document.createElement('button');
                            button.dataset.role = 'open-history';
                            button.dataset.index = actualIndex;
                            button.textContent = 'Open';
                            li.appendChild(button);
                            historyList.appendChild(li);
                        });
                    };

                    const renderDownloads = () => {
                        downloadsList.innerHTML = '';
                        if (!state.downloads.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No downloads yet</span>';
                            li.style.opacity = '0.7';
                            downloadsList.appendChild(li);
                            return;
                        }
                        state.downloads.forEach((item, index) => {
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = `${item.name} · ${new Date(item.time).toLocaleTimeString()}`;
                            li.appendChild(span);
                            const button = document.createElement('button');
                            button.dataset.role = 'open-download';
                            button.dataset.index = index;
                            button.textContent = 'Open';
                            li.appendChild(button);
                            downloadsList.appendChild(li);
                        });
                    };

                    const recordHistory = (url, title) => {
                        state.history = state.history.slice(0, state.index + 1);
                        state.history.push({ url, title, timestamp: Date.now() });
                        state.index = state.history.length - 1;
                        renderHistory();
                    };

                    const navigate = (inputUrl, { push = true } = {}) => {
                        const normalized = ensureProtocol(inputUrl.trim());
                        if (!normalized) return;
                        state.currentUrl = normalized;
                        urlInput.value = normalized;
                        iframe.src = proxiedUrl(normalized);
                        if (push) recordHistory(normalized, normalized);
                        updateToolbarState();
                    };

                    toolbar.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const action = button.dataset.action;
                        switch (action) {
                            case 'back':
                                if (state.index > 0) {
                                    state.index--;
                                    const entry = state.history[state.index];
                                    iframe.src = proxiedUrl(entry.url);
                                    state.currentUrl = entry.url;
                                    urlInput.value = entry.url;
                                }
                                break;
                            case 'forward':
                                if (state.index < state.history.length - 1) {
                                    state.index++;
                                    const entry = state.history[state.index];
                                    iframe.src = proxiedUrl(entry.url);
                                    state.currentUrl = entry.url;
                                    urlInput.value = entry.url;
                                }
                                break;
                            case 'reload':
                                if (state.currentUrl) iframe.src = proxiedUrl(state.currentUrl);
                                break;
                            case 'home':
                                navigate('https://www.example.com');
                                break;
                            case 'go':
                                navigate(urlInput.value);
                                break;
                            case 'bookmark':
                                if (!state.currentUrl) break;
                                const title = prompt('Bookmark title', state.currentUrl) || state.currentUrl;
                                state.bookmarks.push({ title, url: state.currentUrl });
                                saveBookmarks();
                                renderBookmarks();
                                notifications.notify('Bookmark added', title);
                                break;
                            case 'download':
                                if (!state.currentUrl) break;
                                let name;
                                try {
                                    name = new URL(state.currentUrl).hostname || state.currentUrl;
                                } catch {
                                    name = state.currentUrl;
                                }
                                state.downloads.unshift({ name, url: state.currentUrl, time: Date.now() });
                                renderDownloads();
                                notifications.notify('Download saved', name);
                                break;
                            case 'toggle-proxy':
                                settings.update({ useBrowserProxy: !state.useProxy });
                                break;
                            case 'external':
                                if (state.currentUrl) window.open(state.currentUrl, '_blank', 'noopener');
                                break;
                        }
                        updateToolbarState();
                    });

                    urlInput.addEventListener('keydown', event => {
                        if (event.key === 'Enter') navigate(urlInput.value);
                    });

                    bookmarksList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const index = Number(button.dataset.index);
                        if (button.dataset.role === 'open-bookmark') {
                            const bookmark = state.bookmarks[index];
                            if (bookmark) navigate(bookmark.url);
                        } else if (button.dataset.role === 'remove-bookmark') {
                            const [removed] = state.bookmarks.splice(index, 1);
                            saveBookmarks();
                            renderBookmarks();
                            notifications.notify('Bookmark removed', removed?.title || 'Bookmark');
                        }
                    });

                    historyList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button || button.dataset.role !== 'open-history') return;
                        const entry = state.history[Number(button.dataset.index)];
                        if (entry) navigate(entry.url);
                    });

                    downloadsList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button || button.dataset.role !== 'open-download') return;
                        const item = state.downloads[Number(button.dataset.index)];
                        if (item) window.open(item.url, '_blank', 'noopener');
                    });

                    const unsubscribe = settings.on('change', newState => {
                        if (newState.useBrowserProxy !== state.useProxy) {
                            state.useProxy = newState.useBrowserProxy !== false;
                            updateProxyButton();
                            if (state.currentUrl) iframe.src = proxiedUrl(state.currentUrl);
                        }
                    });

                    iframe.addEventListener('load', () => {
                        try {
                            const doc = iframe.contentDocument;
                            const title = doc?.title?.trim();
                            if (title && state.history[state.index]) {
                                state.history[state.index].title = title;
                                renderHistory();
                            }
                        } catch {}
                    });

                    updateProxyButton();
                    renderBookmarks();
                    renderHistory();
                    renderDownloads();
                    const initialUrl = context.url || 'https://www.example.com';
                    navigate(initialUrl, { push: true });

                    return {
                        element: shell,
                        width: '980px',
                        height: '640px',
                        onClose: () => unsubscribe()
                    };
                }
            };
        }
        function createMediaPlayerApp() {
            return {
                id: 'media-player',
                name: 'Media Player',
                icon: '🎵',
                launch({ context, fileSystem, notifications }) {
                    const state = {
                        playlist: JSON.parse(localStorage.getItem(STORAGE_KEYS.MEDIA_PLAYLIST) || '[]'),
                        currentIndex: -1
                    };

                    const container = utils.createEl('div', 'media-player');
                    const stage = utils.createEl('div', 'media-stage');
                    const screen = utils.createEl('div', 'media-screen');
                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.style.width = '100%';
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.maxHeight = '100%';
                    screen.appendChild(audio);
                    const controls = utils.createEl('div', 'app-toolbar');
                    controls.innerHTML = '<button data-action="add">➕ Add</button><button data-action="remove">🗑️ Remove</button><button data-action="clear">Clear Playlist</button>';
                    stage.append(screen, controls);
                    const playlistPane = utils.createEl('div', 'playlist');
                    playlistPane.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center"><strong>Playlist</strong><button data-action="save">💾 Save</button></div><div id="playlist-items"></div>';
                    const playlistItems = playlistPane.querySelector('#playlist-items');
                    container.append(stage, playlistPane);

                    function renderPlaylist() {
                        playlistItems.innerHTML = '';
                        state.playlist.forEach((item, index) => {
                            const row = utils.createEl('div', 'playlist-item');
                            row.innerHTML = `<span>${item.name}</span><button data-index="${index}" data-role="delete">✕</button>`;
                            if (index === state.currentIndex) row.classList.add('active');
                            row.addEventListener('click', event => {
                                if (event.target.dataset.role === 'delete') return;
                                playIndex(index);
                            });
                            playlistItems.appendChild(row);
                        });
                        localStorage.setItem(STORAGE_KEYS.MEDIA_PLAYLIST, JSON.stringify(state.playlist));
                    }

                    function playIndex(index) {
                        const item = state.playlist[index];
                        if (!item) return;
                        state.currentIndex = index;
                        const meta = fileSystem.readFileMeta(item.path);
                        const source = `data:${meta.mime};base64,${meta.data}`;
                        if (meta.mime.startsWith('video')) {
                            screen.innerHTML = '';
                            const player = video.cloneNode();
                            player.src = source;
                            player.play();
                            screen.appendChild(player);
                        } else {
                            screen.innerHTML = '';
                            const player = audio.cloneNode();
                            player.src = source;
                            player.play();
                            screen.appendChild(player);
                        }
                        renderPlaylist();
                    }

                    controls.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'add': {
                                const path = prompt('Enter media path (e.g. /Music/song.mp3)');
                                if (!path) break;
                                try {
                                    const meta = fileSystem.readFileMeta(path);
                                    state.playlist.push({ path, name: meta.name });
                                    renderPlaylist();
                                    notifications.notify('Playlist', `${meta.name} added`);
                                } catch (error) {
                                    notifications.notify('Error', error.message);
                                }
                                break;
                            }
                            case 'remove':
                                if (state.currentIndex >= 0) {
                                    state.playlist.splice(state.currentIndex, 1);
                                    state.currentIndex = -1;
                                    screen.innerHTML = '';
                                    renderPlaylist();
                                }
                                break;
                            case 'clear':
                                state.playlist = [];
                                state.currentIndex = -1;
                                screen.innerHTML = '';
                                renderPlaylist();
                                break;
                        }
                    });

                    playlistPane.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        if (button.dataset.role === 'delete') {
                            const index = Number(button.dataset.index);
                            state.playlist.splice(index, 1);
                            if (state.currentIndex === index) {
                                state.currentIndex = -1;
                                screen.innerHTML = '';
                            }
                            renderPlaylist();
                        } else if (button.dataset.action === 'save') {
                            localStorage.setItem(STORAGE_KEYS.MEDIA_PLAYLIST, JSON.stringify(state.playlist));
                            notifications.notify('Playlist', 'Saved');
                        }
                    });

                    if (context.path) {
                        try {
                            const meta = fileSystem.readFileMeta(context.path);
                            state.playlist.unshift({ path: context.path, name: meta.name });
                            playIndex(0);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    container.addEventListener('dragover', event => event.preventDefault());
                    container.addEventListener('drop', event => {
                        event.preventDefault();
                        const path = event.dataTransfer?.getData('text/plain');
                        if (path && fileSystem.exists(path)) {
                            const meta = fileSystem.readFileMeta(path);
                            state.playlist.push({ path, name: meta.name });
                            renderPlaylist();
                        }
                    });

                    renderPlaylist();
                    return {
                        element: container,
                        width: '900px',
                        height: '580px'
                    };
                }
            };
        }
        function createWebShortcutApp(shortcut) {
            return {
                id: shortcut.id,
                name: shortcut.name,
                icon: shortcut.icon,
                launch({ appManager, notifications }) {
                    const wrapper = utils.createEl('div', 'shortcut-app');
                    const header = utils.createEl('div', 'shortcut-header');
                    const title = document.createElement('h2');
                    title.textContent = shortcut.name;
                    const url = utils.createEl('span', 'shortcut-url', { text: shortcut.url });
                    header.append(title, url);

                    const body = utils.createEl('div', 'shortcut-body', { text: shortcut.description || '' });

                    if (shortcut.availability) {
                        const note = document.createElement('div');
                        note.style.marginTop = '8px';
                        note.style.fontSize = '0.8rem';
                        note.style.opacity = '0.8';
                        note.textContent = shortcut.availability;
                        body.appendChild(note);
                    }

                    let tagsRow = null;
                    if (shortcut.categories?.length) {
                        tagsRow = utils.createEl('div', 'shortcut-tags');
                        shortcut.categories.forEach(label => {
                            tagsRow.appendChild(utils.createEl('span', 'shortcut-tag', { text: label }));
                        });
                    }

                    const actions = utils.createEl('div', 'shortcut-actions');
                    const launchBtn = utils.createEl('button', 'primary', { type: 'button', text: 'Open in Web Navigator' });
                    launchBtn.addEventListener('click', () => {
                        appManager.open('browser', { url: shortcut.url });
                        notifications.notify(shortcut.name, 'Opening in Web Navigator…');
                    });
                    const tabBtn = utils.createEl('button', '', { type: 'button', text: 'Open in New Tab' });
                    tabBtn.addEventListener('click', () => window.open(shortcut.url, '_blank', 'noopener'));
                    const copyBtn = utils.createEl('button', '', { type: 'button', text: 'Copy Link' });
                    copyBtn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard?.writeText(shortcut.url);
                            notifications.notify(shortcut.name, 'Link copied to clipboard.');
                        } catch (error) {
                            notifications.notify(shortcut.name, 'Unable to copy link automatically.');
                        }
                    });
                    actions.append(launchBtn, tabBtn, copyBtn);

                    wrapper.append(header, body);
                    if (tagsRow) wrapper.append(tagsRow);
                    wrapper.append(actions);

                    return {
                        element: wrapper,
                        width: '520px',
                        height: '420px'
                    };
                }
            };
        }
        function createImageViewerApp() {
            return {
                id: 'image-viewer',
                name: 'Image Viewer',
                icon: '🖼️',
                launch({ context, fileSystem, notifications }) {
                    const container = utils.createEl('div', 'image-viewer');
                    const img = new Image();
                    img.alt = 'Image';
                    container.appendChild(img);
                    const controls = utils.createEl('div', 'image-controls');
                    controls.innerHTML = '<button data-action="zoom-in">➕</button><button data-action="zoom-out">➖</button><button data-action="rotate">🔄</button><button data-action="fullscreen">⤢</button>';
                    container.appendChild(controls);

                    const state = { scale: 1, rotation: 0 };
                    const applyTransform = () => {
                        img.style.transform = `scale(${state.scale}) rotate(${state.rotation}deg)`;
                    };

                    controls.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'zoom-in':
                                state.scale = utils.clamp(state.scale + 0.1, 0.2, 3);
                                break;
                            case 'zoom-out':
                                state.scale = utils.clamp(state.scale - 0.1, 0.2, 3);
                                break;
                            case 'rotate':
                                state.rotation = (state.rotation + 90) % 360;
                                break;
                            case 'fullscreen':
                                if (!document.fullscreenElement) container.requestFullscreen();
                                else document.exitFullscreen();
                                break;
                        }
                        applyTransform();
                    });

                    if (context.path) {
                        try {
                            const meta = fileSystem.readFileMeta(context.path);
                            img.src = `data:${meta.mime};base64,${meta.data}`;
                            notifications.notify('Image Viewer', meta.name);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    } else {
                        container.innerHTML = '<div class="preview-card"><strong>No image loaded</strong><div class="preview-body">Open an image from ToastSearcher to view it here.</div></div>';
                    }

                    return {
                        element: container,
                        width: '720px',
                        height: '540px'
                    };
                }
            };
        }
        function createSettingsApp(fileSystem, settings, notifications, desktopManager, appManager, modals) {
            return {
                id: 'settings',
                name: 'System Settings',
                icon: '⚙️',
                launch() {
                    const container = utils.createEl('div', 'settings');
                    const nav = utils.createEl('div', 'settings-nav');
                    const content = utils.createEl('div', 'settings-content');
                    container.append(nav, content);

                    const sections = [
                        { id: 'appearance', label: 'Appearance' },
                        { id: 'desktop', label: 'Desktop' },
                        { id: 'system', label: 'System' },
                        { id: 'storage', label: 'Storage' },
                        { id: 'about', label: 'About' }
                    ];

                    function renderSection(id) {
                        content.innerHTML = '';
                        if (id === 'appearance') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Theme</h3>
                                <div class="settings-row">
                                    <label>Theme mode</label>
                                    <select id="theme-mode">
                                        <option value="dark">Dark</option>
                                        <option value="light">Light</option>
                                        <option value="auto">Auto</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Accent color</label>
                                    <input type="color" id="accent-color" />
                                </div>
                                <div class="settings-row">
                                    <label>Font scale</label>
                                    <input type="range" id="font-scale" min="0.8" max="1.4" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label>Wallpaper</label>
                                    <select id="wallpaper-style">
                                        <option value="aurora">Aurora</option>
                                        <option value="nebula">Nebula</option>
                                        <option value="sunset">Sunset</option>
                                        <option value="minimal">Minimal</option>
                                        <option value="galaxy">Galaxy</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Custom wallpaper</label>
                                    <div class="settings-controls">
                                        <button id="wallpaper-upload">Upload image</button>
                                        <button id="wallpaper-reset">Reset to theme</button>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <label>Blur intensity</label>
                                    <input type="range" id="wallpaper-blur" min="0" max="30" step="1" />
                                </div>
                                <div class="settings-row">
                                    <label>Brightness</label>
                                    <input type="range" id="wallpaper-brightness" min="0.5" max="1.5" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label>Transparency</label>
                                    <input type="range" id="wallpaper-opacity" min="0.3" max="1" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label><input type="checkbox" id="show-seconds"> Show seconds in clock</label>
                                </div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#theme-mode').value = settings.state.theme;
                            section.querySelector('#accent-color').value = settings.state.accent;
                            section.querySelector('#font-scale').value = settings.state.fontScale;
                            section.querySelector('#wallpaper-style').value = settings.state.wallpaper;
                            section.querySelector('#show-seconds').checked = settings.state.showSeconds;

                            const wallpaperSelect = section.querySelector('#wallpaper-style');
                            const uploadBtn = section.querySelector('#wallpaper-upload');
                            const resetBtn = section.querySelector('#wallpaper-reset');
                            const blurInput = section.querySelector('#wallpaper-blur');
                            const brightnessInput = section.querySelector('#wallpaper-brightness');
                            const opacityInput = section.querySelector('#wallpaper-opacity');

                            blurInput.value = settings.state.wallpaperBlur ?? 0;
                            brightnessInput.value = settings.state.wallpaperBrightness ?? 1;
                            opacityInput.value = settings.state.wallpaperOpacity ?? 1;

                            section.querySelector('#theme-mode').addEventListener('change', event => settings.update({ theme: event.target.value }));
                            section.querySelector('#accent-color').addEventListener('input', event => settings.update({ accent: event.target.value }));
                            section.querySelector('#font-scale').addEventListener('input', event => settings.update({ fontScale: Number(event.target.value) }));
                            section.querySelector('#show-seconds').addEventListener('change', event => settings.update({ showSeconds: event.target.checked }));

                            wallpaperSelect.addEventListener('change', event => {
                                const value = event.target.value;
                                if (value === 'custom') {
                                    if (!settings.state.wallpaperCustom) {
                                        uploadBtn.click();
                                    } else {
                                        settings.update({ wallpaper: 'custom' });
                                    }
                                } else {
                                    settings.update({ wallpaper: value });
                                }
                            });

                            uploadBtn.addEventListener('click', event => {
                                event.preventDefault();
                                const picker = document.createElement('input');
                                picker.type = 'file';
                                picker.accept = 'image/*';
                                picker.onchange = () => {
                                    const file = picker.files?.[0];
                                    if (!file) return;
                                    const reader = new FileReader();
                                    reader.onload = () => {
                                        settings.update({ wallpaper: 'custom', wallpaperCustom: reader.result });
                                        wallpaperSelect.value = 'custom';
                                    };
                                    reader.readAsDataURL(file);
                                };
                                picker.click();
                            });

                            resetBtn.addEventListener('click', event => {
                                event.preventDefault();
                                settings.update({ wallpaper: 'aurora', wallpaperCustom: null });
                                wallpaperSelect.value = 'aurora';
                            });

                            blurInput.addEventListener('input', event => settings.update({ wallpaperBlur: Number(event.target.value) }));
                            brightnessInput.addEventListener('input', event => settings.update({ wallpaperBrightness: Number(event.target.value) }));
                            opacityInput.addEventListener('input', event => settings.update({ wallpaperOpacity: Number(event.target.value) }));
                        } else if (id === 'desktop') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Desktop Layout</h3>
                                <div class="settings-row">
                                    <label>Taskbar position</label>
                                    <select id="taskbar-position">
                                        <option value="bottom">Bottom</option>
                                        <option value="top">Top</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Icon density</label>
                                    <select id="desktop-density">
                                        <option value="compact">Compact</option>
                                        <option value="comfortable">Comfortable</option>
                                        <option value="spacious">Spacious</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label><input type="checkbox" id="particles-toggle"> Animated background particles</label>
                                </div>
                                <div class="settings-row">
                                    <button id="open-desktop-folder">Open desktop folder</button>
                                </div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#taskbar-position').value = settings.state.taskbarPosition;
                            section.querySelector('#desktop-density').value = settings.state.desktopDensity;
                            section.querySelector('#particles-toggle').checked = settings.state.showParticles;
                            section.querySelector('#taskbar-position').addEventListener('change', event => settings.update({ taskbarPosition: event.target.value }));
                            section.querySelector('#desktop-density').addEventListener('change', event => settings.update({ desktopDensity: event.target.value }));
                            section.querySelector('#particles-toggle').addEventListener('change', event => settings.update({ showParticles: event.target.checked }));
                            section.querySelector('#open-desktop-folder').addEventListener('click', () => appManager.open('toastsearcher', { path: '/Desktop' }));
                        } else if (id === 'system') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Preferences</h3>
                                <div class="settings-row"><label><input type="checkbox" id="notifications-toggle"> Enable notifications</label></div>
                                <div class="settings-row"><label><input type="checkbox" id="autosave-toggle"> Auto-save documents</label></div>
                                <div class="settings-row"><label><input type="checkbox" id="proxy-toggle"> Use compatibility proxy in browser</label></div>
                                <div class="settings-row"><button id="reset-files">Reset file system</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#notifications-toggle').checked = settings.state.notifications;
                            section.querySelector('#autosave-toggle').checked = settings.state.autoSave;
                            section.querySelector('#proxy-toggle').checked = settings.state.useBrowserProxy !== false;
                            section.querySelector('#notifications-toggle').addEventListener('change', event => settings.update({ notifications: event.target.checked }));
                            section.querySelector('#autosave-toggle').addEventListener('change', event => settings.update({ autoSave: event.target.checked }));
                            section.querySelector('#proxy-toggle').addEventListener('change', event => settings.update({ useBrowserProxy: event.target.checked }));
                            section.querySelector('#reset-files').addEventListener('click', () => {
                                if (!confirm('Reset file system to defaults? This will erase your data.')) return;
                                localStorage.removeItem(STORAGE_KEYS.FILE_SYSTEM);
                                fileSystem.load();
                                desktopManager.render();
                                notifications.notify('File system', 'Restored to defaults');
                            });
                        } else if (id === 'storage') {
                            const section = utils.createEl('div', 'settings-section');
                            const fsData = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM) || '[]';
                            const approxBytes = new TextEncoder().encode(fsData).length;
                            section.innerHTML = `
                                <h3>Storage</h3>
                                <p>Export or import your WebOS virtual file system.</p>
                                <div class="settings-row"><span>Approximate size: ${(approxBytes / 1024).toFixed(1)} KB</span></div>
                                <div class="settings-row"><button id="export-fs">Export file system</button></div>
                                <div class="settings-row"><button id="import-fs">Import file system</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#export-fs').addEventListener('click', () => {
                                const data = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM);
                                const blob = new Blob([data], { type: 'application/json' });
                                const url = URL.createObjectURL(blob);
                                const anchor = document.createElement('a');
                                anchor.href = url;
                                anchor.download = 'webos-filesystem.json';
                                anchor.click();
                                URL.revokeObjectURL(url);
                            });
                            section.querySelector('#import-fs').addEventListener('click', () => {
                                const picker = document.createElement('input');
                                picker.type = 'file';
                                picker.accept = 'application/json';
                                picker.onchange = async () => {
                                    const file = picker.files[0];
                                    const text = await file.text();
                                    localStorage.setItem(STORAGE_KEYS.FILE_SYSTEM, text);
                                    fileSystem.load();
                                    desktopManager.render();
                                    notifications.notify('Storage', 'File system imported');
                                    renderSection('storage');
                                };
                                picker.click();
                            });
                        } else if (id === 'about') {
                            const section = utils.createEl('div', 'settings-section');
                            const stats = { files: 0, folders: 0 };
                            const scan = (entry) => {
                                if (!entry) return;
                                if (entry.type === 'directory') {
                                    if (entry !== fileSystem.root) stats.folders += 1;
                                    Object.values(entry.children || {}).forEach(scan);
                                } else if (entry.type === 'file') {
                                    stats.files += 1;
                                }
                            };
                            scan(fileSystem.root);
                            section.innerHTML = `
                                <h3>About WebOS</h3>
                                <p>Version 1.0 · Browser-based operating system.</p>
                                <div class="settings-row"><span>Creator: Jared Sanford (Slighty.Toasted)</span></div>
                                <div class="settings-row"><span>Total files: ${stats.files}</span></div>
                                <div class="settings-row"><span>Total folders: ${stats.folders}</span></div>
                                <div class="settings-row"><button id="view-shortcuts">View keyboard shortcuts</button></div>
                                <div class="settings-row"><button id="support-link">Visit support page</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#view-shortcuts').addEventListener('click', () => {
                                modals.open({
                                    title: 'Keyboard Shortcuts',
                                    body: `<ul style="padding-left:18px; line-height:1.6;">
                                        <li><strong>Alt + Tab</strong> — Cycle windows</li>
                                        <li><strong>Ctrl/⌘ + Shift + N</strong> — New editor window</li>
                                        <li><strong>Ctrl/⌘ + Shift + D</strong> — Show desktop</li>
                                        <li><strong>F11</strong> — Toggle fullscreen</li>
                                    </ul>`,
                                    actions: [{ label: 'Close', primary: true }]
                                });
                            });
                            section.querySelector('#support-link').addEventListener('click', () => window.open('https://cascade.cool', '_blank', 'noopener'));
                        }
                    }

                    sections.forEach((section, index) => {
                        const button = utils.createEl('button', index === 0 ? 'active' : '', { text: section.label });
                        button.addEventListener('click', () => {
                            nav.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            renderSection(section.id);
                        });
                        nav.appendChild(button);
                    });

                    nav.querySelector('button').classList.add('active');
                    renderSection(sections[0].id);

                    return {
                        element: container,
                        width: '720px',
                        height: '560px'
                    };
                }
            };
        }
        function startBackgroundAnimation(canvas) {
            const ctx = canvas.getContext('2d');
            let enabled = true;
            let mode = document.body.dataset.wallpaper || 'aurora';
            let particles = [];
            let pixelRatio = window.devicePixelRatio || 1;

            const resize = () => {
                pixelRatio = window.devicePixelRatio || 1;
                canvas.width = Math.floor(window.innerWidth * pixelRatio);
                canvas.height = Math.floor(window.innerHeight * pixelRatio);
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                spawnParticles();
            };

            const createAmbientParticle = () => ({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                radius: Math.random() * 1.6 + 0.5,
                speedX: (Math.random() - 0.5) * 0.25,
                speedY: (Math.random() - 0.5) * 0.25,
                hue: 200 + Math.random() * 80,
                alpha: 0.35 + Math.random() * 0.3
            });

            const createGalaxyParticle = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const maxDistance = Math.min(width, height) * 0.55;
                const distance = (Math.random() ** 0.35) * maxDistance * (0.4 + Math.random() * 0.6);
                const spiral = distance / maxDistance * 1.45;
                const base = Math.random() * Math.PI * 2;
                const arm = Math.random() < 0.5 ? 1 : -1;
                return {
                    distance,
                    angle: base + spiral * arm,
                    speed: 0.0008 + (1 - distance / maxDistance) * 0.0018,
                    size: 1.2 + Math.random() * 1.6,
                    eccentricity: 0.55 + Math.random() * 0.35,
                    hue: 200 + Math.random() * 160,
                    twinkle: Math.random() * Math.PI * 2,
                    drift: (Math.random() - 0.5) * 0.0005
                };
            };

            const spawnParticles = () => {
                if (mode === 'galaxy') {
                    particles = Array.from({ length: 240 }, createGalaxyParticle);
                } else {
                    particles = Array.from({ length: 140 }, createAmbientParticle);
                }
            };

            const drawAmbient = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                particles.forEach(particle => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    if (particle.x < -80) particle.x = width + 80;
                    if (particle.x > width + 80) particle.x = -80;
                    if (particle.y < -80) particle.y = height + 80;
                    if (particle.y > height + 80) particle.y = -80;
                    const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.radius * 32);
                    gradient.addColorStop(0, `hsla(${particle.hue}, 80%, 70%, ${particle.alpha})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius * 32, 0, Math.PI * 2);
                    ctx.fill();
                });
            };

            const drawGalaxy = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const cx = width / 2;
                const cy = height / 2;
                particles.forEach(particle => {
                    particle.angle += particle.speed;
                    particle.angle += particle.drift;
                    particle.twinkle += 0.02;
                    const wobble = 1 + Math.sin(particle.twinkle) * 0.03;
                    const x = cx + Math.cos(particle.angle) * particle.distance * wobble;
                    const y = cy + Math.sin(particle.angle) * particle.distance * particle.eccentricity * wobble;
                    const radius = particle.size * (1 + Math.sin(particle.twinkle) * 0.3);
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 18);
                    gradient.addColorStop(0, `hsla(${particle.hue}, 100%, 82%, 0.7)`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 18, 0, Math.PI * 2);
                    ctx.fill();
                });
            };

            const draw = () => {
                if (!enabled) {
                    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                    requestAnimationFrame(draw);
                    return;
                }
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                if (mode === 'galaxy') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    drawGalaxy();
                    ctx.restore();
                } else {
                    drawAmbient();
                }
                requestAnimationFrame(draw);
            };

            resize();
            window.addEventListener('resize', utils.debounce(resize, 120));
            draw();

            return {
                setEnabled(value) {
                    enabled = Boolean(value);
                    if (!enabled) {
                        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                    } else {
                        spawnParticles();
                    }
                },
                setMode(nextMode) {
                    mode = nextMode || 'aurora';
                    spawnParticles();
                }
            };
        }

        function updateClock(settings) {
            const clockEl = document.getElementById('tray-clock');
            const tick = () => {
                const options = settings.state.showSeconds ? { hour: '2-digit', minute: '2-digit', second: '2-digit' } : { hour: '2-digit', minute: '2-digit' };
                clockEl.textContent = new Date().toLocaleTimeString([], options);
            };
            tick();
            setInterval(tick, 1000);
        }

        function registerPWA() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js').catch(() => {});
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('desktop-bg');
            const settings = new SettingsManager();
            const particles = startBackgroundAnimation(canvas);
            settings.setBackgroundController(particles);

            const notifications = new NotificationCenter(settings);
            const modals = new ModalManager();
            const fileSystem = new FileSystem();
            const windowManager = new WindowManager();
            const categoryManager = new AppCategoryManager(APP_CATALOG);
            const appManager = new AppManager(windowManager, fileSystem, notifications, settings, modals, categoryManager);
            const desktopManager = new DesktopManager(fileSystem, appManager, notifications);
            const dockManager = new DockManager(appManager, windowManager, notifications, settings, categoryManager);
            desktopManager.setDockManager(dockManager);
            appManager.setDockManager(dockManager);

            const apps = [
                createTasksApp(),
                createToastSearcherApp(desktopManager),
                createTextEditorApp(),
                createCalculatorApp(),
                createTerminalApp(desktopManager),
                createBrowserApp(),
                createMediaPlayerApp(),
                createImageViewerApp(),
                createAssistantApp(),
                createSettingsApp(fileSystem, settings, notifications, desktopManager, appManager, modals)
            ];
            WEB_PORTAL_APPS.forEach(shortcut => apps.push(createWebShortcutApp(shortcut)));
            apps.forEach(app => appManager.register(app.id, app));

            const startMenu = new StartMenu({ appManager, categoryManager, dockManager, notifications, modals });

            const shortcuts = new ShortcutManager(windowManager, appManager, settings);
            const menuManager = new MenuManager({ desktopManager, windowManager, appManager, settings, notifications, modals, fileSystem, startMenu });
            document.querySelectorAll('#menu-items [data-menu]').forEach(button => menuManager.attach(button, button.dataset.menu));
            menuManager.attach(document.getElementById('menu-apple'), 'finder');

            document.getElementById('theme-toggle').addEventListener('click', () => {
                const next = settings.state.theme === 'dark' ? 'light' : settings.state.theme === 'light' ? 'auto' : 'dark';
                settings.update({ theme: next });
                notifications.notify('Theme', `Theme switched to ${next}`);
            });

            document.getElementById('notification-button').addEventListener('click', () => {
                notifications.notify('Notifications', 'This is a sample notification.');
            });

            settings.on('change', () => desktopManager.render());

            startMenu.setDockManager(dockManager);

            windowManager.on('focus', state => startMenu.handleExternalFocus(state));

            updateClock(settings);
            registerPWA();
            notifications.notify('Welcome to WebOS', 'All core services initialized.');

            window.webOS = { fileSystem, settings, notifications, windowManager, appManager, desktopManager, menuManager, dockManager, categoryManager, startMenu };
        });
    })();
    </script>
</body>
</html>

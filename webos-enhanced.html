<!DOCTYPE html>
<!-- Crafted by Jared Sanford (Slighty.Toasted) with love. -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>WebOS • Browser Operating System</title>
    <meta name="theme-color" content="#111426">
    <link rel="manifest" href="./manifest.json">
    <style>
        :root {
            color-scheme: dark;
            --background-desktop: radial-gradient(circle at 20% 18%, rgba(73, 92, 142, 0.35), transparent 58%),
                                   radial-gradient(circle at 82% 80%, rgba(34, 44, 88, 0.5), transparent 60%),
                                   #070c1a;
            --panel: rgba(22, 28, 46, 0.8);
            --panel-strong: rgba(14, 18, 30, 0.92);
            --border-soft: 1px solid rgba(255, 255, 255, 0.08);
            --border-strong: 1px solid rgba(255, 255, 255, 0.16);
            --shadow: 0 20px 48px rgba(4, 8, 20, 0.55);
            --shadow-soft: 0 14px 32px rgba(4, 8, 20, 0.35);
            --accent: #0a84ff;
            --accent-strong: #4aa3ff;
            --accent-gradient: linear-gradient(135deg, #0a84ff 0%, #4aa3ff 100%);
            --danger: #ff6058;
            --warning: #ffbd2e;
            --success: #28c941;
            --text-primary: #f4f7ff;
            --text-muted: rgba(200, 210, 240, 0.6);
            --taskbar-height: 76px;
            --base-font-size: 14px;
            --desktop-column-width: 260px;
            --desktop-stack-gap: 18px;
            --desktop-icon-size: 60px;
            --wallpaper-blur: 0px;
            --wallpaper-brightness: 1;
            --wallpaper-opacity: 1;
            --dock-icon-size: 56px;
            --window-backdrop: rgba(13, 18, 32, 0.62);
            --window-backdrop-border: rgba(255, 255, 255, 0.08);
            --window-glow: 0 24px 60px rgba(5, 12, 32, 0.5);
            --glass-blur: 22px;
            --app-toolbar-glass: rgba(255, 255, 255, 0.04);
            --animation-speed: 1;
            /* Stable viewport height for mobile browsers */
            --viewport-h: 100svh;
        }

        [data-theme="light"] {
            color-scheme: light;
            --background-desktop: radial-gradient(circle at 28% 18%, rgba(255, 255, 255, 0.75), transparent 55%),
                                   radial-gradient(circle at 80% 82%, rgba(209, 225, 255, 0.85), transparent 60%),
                                   #e7ebf8;
            --panel: rgba(255, 255, 255, 0.72);
            --panel-strong: rgba(255, 255, 255, 0.9);
            --border-soft: 1px solid rgba(26, 36, 78, 0.12);
            --border-strong: 1px solid rgba(26, 36, 78, 0.18);
            --shadow: 0 24px 60px rgba(18, 31, 68, 0.18);
            --shadow-soft: 0 16px 36px rgba(18, 31, 68, 0.14);
            --text-primary: #1d2336;
            --text-muted: rgba(29, 35, 54, 0.54);
        }

        body[data-contrast="high"] {
            --panel: rgba(0, 0, 0, 0.82);
            --panel-strong: rgba(0, 0, 0, 0.94);
            --border-soft: 2px solid rgba(255, 255, 255, 0.85);
            --border-strong: 2px solid rgba(255, 255, 255, 0.95);
            --text-primary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.8);
            --accent: #ffb100;
            --accent-strong: #ffd75f;
            --accent-gradient: linear-gradient(135deg, #ffb100 0%, #ffd75f 100%);
        }

        body[data-wallpaper="aurora"] {
            --background-desktop: radial-gradient(circle at 18% 16%, rgba(74, 104, 172, 0.45), transparent 55%),
                                   radial-gradient(circle at 82% 84%, rgba(56, 90, 160, 0.52), transparent 60%),
                                   #080d1d;
        }
        body[data-wallpaper="nebula"] {
            --background-desktop: radial-gradient(circle at 25% 78%, rgba(138, 78, 150, 0.45), transparent 58%),
                                   radial-gradient(circle at 78% 24%, rgba(64, 94, 168, 0.5), transparent 60%),
                                   #0b0f26;
        }
        body[data-wallpaper="sunset"] {
            --background-desktop: radial-gradient(circle at 42% 0%, rgba(166, 82, 106, 0.45), transparent 55%),
                                   radial-gradient(circle at 80% 88%, rgba(255, 134, 98, 0.42), transparent 60%),
                                   #120c1c;
        }
        body[data-wallpaper="minimal"] {
            --background-desktop: linear-gradient(135deg, #080c16 0%, #121a2a 100%);
        }
        body[data-wallpaper="galaxy"] {
            --background-desktop: radial-gradient(circle at 48% 52%, rgba(125, 110, 255, 0.1), transparent 62%),
                                   radial-gradient(circle at 18% 22%, rgba(255, 142, 226, 0.18), transparent 58%),
                                   radial-gradient(circle at 78% 78%, rgba(76, 158, 255, 0.16), transparent 60%),
                                   #030312;
        }
        body[data-wallpaper="galaxy"] #desktop-bg {
            mix-blend-mode: screen;
            opacity: 0.92;
        }

        body[data-taskbar="top"] #taskbar {
            top: 64px;
            bottom: auto;
        }
        body[data-taskbar="top"] #desktop {
            padding-top: calc(var(--taskbar-height) + 96px);
            padding-bottom: 48px;
        }

        body[data-particles="off"] #desktop-bg {
            opacity: 0;
        }

        #wallpaper-layer {
            position: fixed;
            inset: 0;
            z-index: -2;
            background: var(--background-desktop);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            filter: blur(var(--wallpaper-blur, 0px)) brightness(var(--wallpaper-brightness, 1));
            opacity: var(--wallpaper-opacity, 1);
            transition: filter 0.4s ease, opacity 0.4s ease, background-image 0.4s ease;
        }

        body[data-wallpaper="custom"] #wallpaper-layer {
            background: var(--wallpaper-image, #000) center/cover no-repeat fixed;
        }

        *, *::before, *::after { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; height: 100%; }
        body {
            font-family: "SF Pro Text", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: var(--background-desktop);
            color: var(--text-primary);
            overflow: hidden;
            font-size: var(--base-font-size);
            user-select: none;
            letter-spacing: -0.01em;
        }

        body[data-transparency="off"] .window,
        body[data-transparency="off"] #menu-bar,
        body[data-transparency="off"] #taskbar,
        body[data-transparency="off"] .context-menu,
        body[data-transparency="off"] .start-menu-category,
        body[data-transparency="off"] .menu-dropdown,
        body[data-transparency="off"] .app-toolbar,
        body[data-transparency="off"] .preview-card,
        body[data-transparency="off"] .assistant-chat,
        body[data-transparency="off"] .notes-sidebar,
        body[data-transparency="off"] .notes-editor {
            backdrop-filter: none !important;
            background: rgba(18, 24, 40, 0.98) !important;
        }

        /* Clean desktop: hide all desktop icons (apps and files) */
        #desktop-apps,
        #desktop-files {
            display: none !important;
        }

        button, input, select, textarea { font-family: inherit; }

        /* Mobile responsiveness adjustments */
        @media (max-width: 1024px) {
            .mail-layout {
                grid-template-columns: 220px 1fr;
            }
        }

        @media (max-width: 768px) {
            :root {
                --taskbar-height: 64px;
                --base-font-size: 15px;
                --desktop-icon-size: 48px;
                --dock-icon-size: 48px;
                --mobile-window-top: calc(60px + env(safe-area-inset-top));
            }

            html, body {
                height: auto;
                min-height: var(--viewport-h);
            }

            body {
                overflow: auto; /* allow scrolling on small screens */
                -webkit-overflow-scrolling: touch;
                touch-action: manipulation;
                padding-bottom: env(safe-area-inset-bottom);
            }

            .menu-left {
                gap: 8px;
            }

            #menu-bar {
                height: 44px;
                padding: 0 12px;
            }

            #menu-items,
            .menu-center {
                display: none;
            }

            #desktop {
                padding: calc(44px + 12px) 12px calc(var(--taskbar-height) + env(safe-area-inset-bottom) + 12px);
                overflow: visible; /* avoid clipping content */
                flex-direction: column;
            }

            #desktop-apps {
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 14px;
            }

            #desktop-files {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .desktop-icon .icon-label strong { font-size: 0.9rem; }
            .desktop-icon .icon-label span { font-size: 0.75rem; }

            #menu-bar {
                height: 48px;
                padding: 0 14px;
            }

            .menu-right button {
                width: 34px;
                height: 34px;
            }

            #taskbar {
                width: calc(100vw - 24px);
                min-width: unset;
                left: 50%;
                transform: translate(-50%, var(--taskbar-offset, 0));
                bottom: calc(env(safe-area-inset-bottom) + 16px);
                padding: 10px 16px;
                gap: 16px;
            }

            #start-button {
                width: 52px;
                height: 52px;
                font-size: 1.2rem;
            }

            #dock {
                justify-content: flex-start;
                gap: 12px;
                flex-wrap: nowrap;
                overflow-x: auto;
                padding: 0 6px;
            }

            #taskbar-apps {
                gap: 12px;
                overflow-x: auto;
                padding: 0 2px;
                justify-content: flex-start;
            }

            #start-menu {
                width: calc(100vw - 24px);
                max-height: calc(100svh - 130px);
                bottom: calc(var(--taskbar-height) + env(safe-area-inset-bottom) + 18px);
                left: 50%;
                transform: translate(-50%, 6%) scale(0.96);
                border-radius: 22px;
            }

            .start-menu-header {
                padding: 20px 20px 0;
            }

            .start-menu-actions {
                flex-wrap: wrap;
                gap: 10px;
            }

            .start-menu-actions > * {
                flex: 1 1 48%;
            }

            #start-menu-search {
                width: 100%;
            }

            .start-menu-body {
                padding: 16px 20px;
            }

            .start-menu-footer {
                padding: 12px 20px 20px;
            }

            .start-menu-app-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }

            .start-menu-category {
                margin-left: 0;
            }

            .window {
                position: fixed !important;
                left: 50% !important;
                top: var(--mobile-window-top) !important;
                transform: translateX(-50%);
                width: calc(100vw - 24px) !important;
                height: calc(100svh - var(--mobile-window-top) - var(--taskbar-height) - env(safe-area-inset-bottom) - 32px) !important;
                animation: none !important;
                border-radius: 18px;
            }

            .window-header {
                cursor: default;
                padding: 12px 16px;
            }

            .window-controls {
                gap: 10px;
            }

            .window-control {
                width: 16px;
                height: 16px;
            }

            .window-content {
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }

            .resize-handle {
                display: none !important;
            }

            .context-menu {
                inset: auto 12px auto 12px;
                max-width: calc(100vw - 24px);
            }

            .calendar-body {
                grid-template-columns: 1fr;
            }

            .calendar-sidebar {
                order: -1;
            }

            .mail-layout {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 540px) {
            :root {
                --mobile-window-top: calc(52px + env(safe-area-inset-top));
            }

            #menu-bar {
                height: 44px;
                padding: 0 10px;
            }

            .menu-right button {
                width: 32px;
                height: 32px;
            }

            #start-button {
                width: 48px;
                height: 48px;
            }

            #taskbar {
                padding: 8px 14px;
                gap: 12px;
            }

            #dock {
                gap: 10px;
            }

            .start-menu-actions > * {
                flex-basis: 100%;
            }

            .start-menu-app-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .window {
                height: calc(100svh - var(--mobile-window-top) - var(--taskbar-height) - env(safe-area-inset-bottom) - 24px) !important;
            }
        }

        #desktop-bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        #menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 18px;
            backdrop-filter: blur(24px);
            background: rgba(255, 255, 255, 0.6);
            border-bottom: var(--border-soft);
            z-index: 1200;
            color: var(--text-primary);
        }

        [data-theme="dark"] #menu-bar {
            background: rgba(16, 20, 32, 0.72);
        }

        .menu-left,
        .menu-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #menu-items {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        #menu-apple {
            font-size: 1.2rem;
            border: none;
            background: transparent;
            color: inherit;
            cursor: pointer;
            padding: 4px 6px;
        }

        #menu-items button {
            border: none;
            background: transparent;
            color: inherit;
            font-size: 0.78rem;
            padding: 4px 6px;
            border-radius: 6px;
            cursor: pointer;
        }

        #menu-items button:hover,
        #menu-items button:focus-visible {
            background: rgba(255, 255, 255, 0.32);
            outline: none;
        }

        [data-theme="dark"] #menu-items button:hover,
        [data-theme="dark"] #menu-items button:focus-visible {
            background: rgba(255, 255, 255, 0.18);
        }

        .menu-center {
            font-size: 0.75rem;
            color: var(--text-muted);
            pointer-events: none;
        }

        .menu-right button {
            border: none;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            width: 30px;
            height: 30px;
            display: grid;
            place-items: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: var(--text-primary);
        }

        [data-theme="dark"] .menu-right button {
            background: rgba(30, 36, 52, 0.6);
            color: #f6f7ff;
        }

        .menu-right button:hover {
            filter: brightness(1.05);
        }

        #tray-clock {
            font-variant-numeric: tabular-nums;
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        .menu-dropdown {
            position: fixed;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 12px;
            border: 1px solid rgba(182, 194, 221, 0.45);
            box-shadow: 0 18px 34px rgba(26, 32, 68, 0.2);
            backdrop-filter: blur(22px);
            padding: 6px;
            display: none;
            flex-direction: column;
            z-index: 2000;
        }

        [data-theme="dark"] .menu-dropdown {
            background: rgba(22, 28, 46, 0.9);
            border: 1px solid rgba(90, 110, 160, 0.35);
            box-shadow: var(--shadow);
        }

        .menu-dropdown[aria-hidden="false"] {
            display: flex;
            animation: menu-in 0.16s ease;
        }

        .menu-dropdown button {
            border: none;
            background: transparent;
            color: inherit;
            font-size: 0.82rem;
            padding: 8px 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .menu-dropdown button:hover,
        .menu-dropdown button:focus-visible {
            background: rgba(10, 132, 255, 0.12);
            outline: none;
        }

        .menu-dropdown button[disabled] {
            opacity: 0.4;
            cursor: default;
        }

        .menu-dropdown .menu-shortcut {
            margin-left: 18px;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        .menu-separator {
            height: 1px;
            background: rgba(120, 130, 150, 0.22);
            margin: 5px 2px;
        }

        #desktop {
            position: relative;
            z-index: 1;
            height: 100%;
            padding: 80px 48px calc(var(--taskbar-height) + 96px);
            display: flex;
            overflow: hidden;
        }

        #desktop-canvas {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 32px;
        }

        #desktop-apps {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 18px;
            align-content: flex-start;
        }

        #desktop-files {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 16px;
            align-content: flex-start;
        }

        .desktop-icon {
            display: flex;
            align-items: center;
            gap: 14px;
            border-radius: 18px;
            padding: 12px 14px;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(182, 194, 221, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        [data-theme="dark"] .desktop-icon {
            background: rgba(24, 30, 48, 0.72);
            border: 1px solid rgba(110, 120, 150, 0.3);
        }

        .desktop-icon:hover { transform: translateY(-3px); box-shadow: 0 12px 28px rgba(26, 32, 68, 0.18); }
        .desktop-icon.active { box-shadow: 0 16px 30px rgba(26, 32, 68, 0.26); }
        .desktop-icon.pinned { box-shadow: 0 18px 36px rgba(10, 132, 255, 0.18); }

        .desktop-icon .glyph {
            width: var(--desktop-icon-size);
            height: var(--desktop-icon-size);
            border-radius: 18px;
            display: grid;
            place-items: center;
            font-size: calc(var(--desktop-icon-size) * 0.48);
            background: var(--accent-gradient);
            box-shadow: 0 14px 24px rgba(88, 110, 255, 0.28);
        }

        .desktop-icon .icon-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .desktop-icon .icon-label strong { font-weight: 600; font-size: 0.92rem; }
        .desktop-icon .icon-label span { font-size: 0.78rem; color: var(--text-muted); }

        .desktop-file {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px 14px;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.72);
            border: 1px solid rgba(190, 200, 226, 0.45);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        [data-theme="dark"] .desktop-file {
            background: rgba(22, 28, 46, 0.75);
            border: 1px solid rgba(110, 120, 150, 0.32);
        }

        .desktop-file:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 28px rgba(26, 32, 68, 0.18);
        }

        .desktop-file.active {
            box-shadow: 0 18px 32px rgba(26, 32, 68, 0.22);
            border: 1px solid rgba(10, 132, 255, 0.45);
        }

        .desktop-file .file-glyph {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.75);
            font-size: 1.1rem;
        }

        [data-theme="dark"] .desktop-file .file-glyph {
            background: rgba(34, 40, 64, 0.82);
        }

        .desktop-file .file-info { display: flex; flex-direction: column; gap: 2px; }
        .desktop-file .file-info strong { font-size: 0.9rem; }
        .desktop-file .file-info span { font-size: 0.75rem; color: var(--text-muted); }

        .desktop-file.empty {
            opacity: 0.7;
            border-style: dashed;
            background: rgba(255,255,255,0.55);
        }

        [data-theme="dark"] .desktop-file.empty {
            background: rgba(34, 40, 64, 0.55);
        }

        #window-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .window {
            position: absolute;
            min-width: 320px;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            border-radius: 20px;
            border: var(--border-soft);
            background: rgba(255, 255, 255, 0.82);
            box-shadow: var(--window-glow);
            overflow: hidden;
            pointer-events: auto;
            backdrop-filter: blur(var(--glass-blur)) saturate(140%);
            transition: transform calc(0.22s * var(--animation-speed)) ease, opacity calc(0.22s * var(--animation-speed)) ease;
            animation: window-in calc(0.26s * var(--animation-speed)) ease;
        }

        [data-theme="dark"] .window {
            background: var(--window-backdrop);
            border-color: var(--window-backdrop-border);
        }

        body[data-animations="off"] .window,
        body[data-animations="off"] .window * {
            animation: none !important;
            transition: none !important;
        }

        @keyframes window-in {
            from { opacity: 0; transform: translateY(18px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .window.minimizing {
            opacity: 0;
            transform: scale(0.92) translateY(8px);
        }

        .window.restoring {
            transform: scale(1.02);
        }

        .window-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            padding: 10px 18px;
            background: rgba(255, 255, 255, 0.65);
            border-bottom: var(--border-soft);
            cursor: grab;
        }

        [data-theme="dark"] .window-header {
            background: rgba(30, 36, 52, 0.7);
        }
        .window-header:active { cursor: grabbing; }
        .window-controls {
            display: flex;
            gap: 8px;
        }

        .window-header-filler {
            width: 70px;
        }

        .window-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: box-shadow 0.2s ease;
        }

        .window-control[data-role="close"] { background: #ff6058; }
        .window-control[data-role="minimize"] { background: #ffbd2e; }
        .window-control[data-role="maximize"] { background: #28c941; }
        .window-control:hover { box-shadow: 0 0 0 4px rgba(0,0,0,0.08); }

        .window-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-muted);
            flex: 1;
            justify-content: center;
            pointer-events: none;
        }

        .window-title .glyph {
            background: transparent;
            box-shadow: none;
            font-size: 1rem;
        }

        .window-title span:last-child {
            color: var(--text-primary);
        }

        .window-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.65);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        [data-theme="dark"] .window-content {
            background: rgba(12, 16, 28, 0.75);
        }
        .window-footer { border-top: var(--border-soft); padding: 8px 12px; font-size: 0.76rem; color: var(--text-muted); }

        .resize-handle { position: absolute; background: transparent; }
        .resize-handle[data-dir="n"], .resize-handle[data-dir="s"] { left: 8px; right: 8px; height: 10px; cursor: ns-resize; }
        .resize-handle[data-dir="e"], .resize-handle[data-dir="w"] { top: 8px; bottom: 8px; width: 10px; cursor: ew-resize; }
        .resize-handle[data-dir="n"] { top: -5px; }
        .resize-handle[data-dir="s"] { bottom: -5px; }
        .resize-handle[data-dir="e"] { right: -5px; }
        .resize-handle[data-dir="w"] { left: -5px; }
        .resize-handle[data-dir="ne"], .resize-handle[data-dir="nw"], .resize-handle[data-dir="se"], .resize-handle[data-dir="sw"] {
            width: 14px; height: 14px;
        }
        .resize-handle[data-dir="ne"] { top: -6px; right: -6px; cursor: nesw-resize; }
        .resize-handle[data-dir="nw"] { top: -6px; left: -6px; cursor: nwse-resize; }
        .resize-handle[data-dir="se"] { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .resize-handle[data-dir="sw"] { bottom: -6px; left: -6px; cursor: nesw-resize; }

        #taskbar {
            position: fixed;
            left: 50%;
            bottom: 26px;
            transform: translate(-50%, var(--taskbar-offset, 0));
            height: var(--taskbar-height);
            min-width: 360px;
            width: min(88vw, 1080px);
            border-radius: 34px;
            background: rgba(255, 255, 255, 0.62);
            border: 1px solid rgba(182, 194, 221, 0.45);
            backdrop-filter: blur(32px) saturate(140%);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 20px;
            gap: 20px;
            box-shadow: 0 18px 36px rgba(26, 32, 68, 0.18);
            z-index: 1200;
            opacity: 1;
            transition: transform 0.32s ease, opacity 0.24s ease;
        }

        [data-theme="dark"] #taskbar {
            background: rgba(22, 28, 46, 0.78);
            border: 1px solid rgba(110, 120, 150, 0.34);
            box-shadow: var(--shadow);
        }
        body[data-dock-autohide="on"] #taskbar {
            pointer-events: none;
            opacity: 0;
            --taskbar-offset: calc(100% + 48px);
        }

        body[data-dock-autohide="on"] #taskbar.dock-visible {
            pointer-events: auto;
            opacity: 1;
            --taskbar-offset: 0;
        }

        #start-button {
            width: 58px;
            height: 58px;
            border-radius: 20px;
            border: none;
            background: rgba(255, 255, 255, 0.85);
            color: var(--text-primary);
            font-size: 1.35rem;
            display: grid;
            place-items: center;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.75);
            cursor: pointer;
            transition: transform 0.18s ease, filter 0.2s ease;
        }

        [data-theme="dark"] #start-button {
            background: rgba(34, 40, 64, 0.9);
            color: #f5f7ff;
        }

        #start-button:hover { filter: brightness(1.08); }
        #start-button:active { transform: scale(0.95); }

        #taskbar-apps {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
        }

        #dock {
            display: flex;
            align-items: flex-end;
            gap: 18px;
            flex: 1 1 auto;
            justify-content: center;
            flex-wrap: wrap;
        }

        #taskbar-apps {
            display: flex;
            align-items: center;
            gap: 16px;
            overflow: visible;
            min-width: 180px;
            justify-content: flex-end;
        }

        #taskbar-apps::-webkit-scrollbar { display: none; }

        .taskbar-item {
            position: relative;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            color: inherit;
            transition: transform 0.22s ease;
        }

        .taskbar-item:hover,
        .taskbar-item.active {
            transform: translateY(-6px);
        }

        .taskbar-item .glyph {
            width: 54px;
            height: 54px;
            border-radius: 16px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.75);
            box-shadow: 0 12px 24px rgba(26, 32, 68, 0.18);
            font-size: 1.35rem;
        }

        [data-theme="dark"] .taskbar-item .glyph {
            background: rgba(34, 40, 64, 0.82);
            box-shadow: 0 12px 28px rgba(6, 10, 24, 0.45);
        }

        .taskbar-item span:last-child {
            display: none;
        }

        .dock-item {
            position: relative;
            border: none;
            background: transparent;
            cursor: pointer;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: inherit;
            transition: transform 0.2s ease, filter 0.2s ease;
        }

        .dock-item .glyph {
            width: var(--dock-icon-size, 56px);
            height: var(--dock-icon-size, 56px);
            border-radius: 18px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 16px 32px rgba(26, 32, 68, 0.24);
            font-size: calc(var(--dock-icon-size, 56px) * 0.28);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        [data-theme="dark"] .dock-item .glyph {
            background: rgba(34, 40, 64, 0.88);
            box-shadow: 0 18px 28px rgba(6, 10, 24, 0.42);
        }

        .dock-item::after {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .dock-item.running::after {
            opacity: 1;
            transform: translateY(2px);
        }

        .dock-item:hover {
            transform: translateY(-8px) scale(1.05);
        }

        .dock-item.active {
            transform: translateY(-10px) scale(1.08);
        }

        .dock-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dock-group + .dock-group {
            margin-left: 18px;
        }

        .dock-group-label {
            font-size: 0.7rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .dock-group-items {
            display: flex;
            align-items: flex-end;
            gap: 16px;
        }

        #start-menu {
            position: fixed;
            left: 50%;
            bottom: calc(var(--taskbar-height) + 32px);
            transform: translate(-50%, 10%) scale(0.92);
            width: min(760px, 92vw);
            border-radius: 26px;
            background: rgba(255, 255, 255, 0.88);
            border: 1px solid rgba(182, 194, 221, 0.45);
            box-shadow: 0 30px 58px rgba(26, 32, 68, 0.26);
            backdrop-filter: blur(30px) saturate(140%);
            display: none;
            flex-direction: column;
            max-height: min(72vh, 640px);
            z-index: 1500;
        }

        [data-theme="dark"] #start-menu {
            background: rgba(18, 22, 34, 0.95);
            border: 1px solid rgba(90, 110, 160, 0.4);
            box-shadow: var(--shadow);
        }

        #start-menu[aria-hidden="false"] {
            display: flex;
            animation: start-menu-in 0.24s ease;
            transform: translate(-50%, 0) scale(1);
        }

        @keyframes start-menu-in {
            from {
                opacity: 0;
                transform: translate(-50%, 12%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0) scale(1);
            }
        }

        .start-menu-header {
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 24px 28px 0;
        }

        .start-menu-title {
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-muted);
        }

        .start-menu-title .glyph {
            width: 42px;
            height: 42px;
            border-radius: 14px;
            display: grid;
            place-items: center;
            font-size: 1.3rem;
            background: rgba(10, 132, 255, 0.12);
        }

        .start-menu-heading-text {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .start-menu-heading-text strong {
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        #start-menu-app-count {
            font-size: 0.78rem;
            color: var(--text-muted);
            letter-spacing: 0.04em;
            text-transform: uppercase;
        }

        .start-menu-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #start-menu-search {
            flex: 1;
            border: 1px solid rgba(180, 190, 220, 0.45);
            border-radius: 16px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            color: inherit;
        }

        [data-theme="dark"] #start-menu-search {
            background: rgba(30, 38, 62, 0.8);
            border: 1px solid rgba(90, 110, 160, 0.45);
        }

        #start-menu-add-category,
        #start-menu-manage-categories {
            border: none;
            border-radius: 14px;
            background: rgba(255,255,255,0.7);
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.9rem;
            color: inherit;
            transition: filter 0.15s ease;
        }

        [data-theme="dark"] #start-menu-add-category,
        [data-theme="dark"] #start-menu-manage-categories {
            background: rgba(34, 42, 68, 0.8);
        }

        #start-menu-add-category:hover,
        #start-menu-manage-categories:hover {
            filter: brightness(1.08);
        }

        .start-menu-body {
            padding: 20px 28px;
            flex: 1 1 auto;
            overflow-y: auto;
            min-height: 0;
        }

        .start-menu-categories {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding-right: 6px;
        }

        .start-menu-suggestions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 18px;
        }

        .start-menu-suggestions.hidden { display: none; }

        .suggestion-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.6);
            border: var(--border-soft);
            backdrop-filter: blur(18px);
        }

        [data-theme="dark"] .suggestion-group {
            background: rgba(26, 32, 60, 0.6);
        }

        .suggestion-group header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .suggestion-chip-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .suggestion-chip {
            border: none;
            border-radius: 999px;
            padding: 6px 14px;
            font-size: 0.78rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: inherit;
            background: rgba(255, 255, 255, 0.18);
            transition: transform 0.2s ease, filter 0.2s ease;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.24);
        }

        [data-theme="dark"] .suggestion-chip {
            background: rgba(255, 255, 255, 0.08);
        }

        .suggestion-chip[data-accent] {
            color: var(--chip-accent, inherit);
            box-shadow: inset 0 0 0 1px var(--chip-accent, rgba(255,255,255,0.3));
        }

        .suggestion-chip:hover {
            transform: translateY(-2px);
            filter: brightness(1.08);
        }

        .suggestion-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.9;
        }

        .suggestion-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px;
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.65);
            border: var(--border-soft);
        }

        [data-theme="dark"] .suggestion-card {
            background: rgba(24, 30, 52, 0.68);
        }

        .suggestion-card strong {
            font-size: 0.9rem;
        }

        .suggestion-card footer {
            display: flex;
            gap: 10px;
        }

        .suggestion-card button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.85);
            color: inherit;
        }

        [data-theme="dark"] .suggestion-card button {
            background: rgba(38, 46, 74, 0.85);
        }

        .suggestion-card button.primary {
            background: var(--accent-gradient);
            color: #fff;
        }

        .start-menu-category {
            position: relative;
            background: rgba(255, 255, 255, 0.72);
            border: 1px solid rgba(182, 194, 221, 0.35);
            border-radius: 18px;
            overflow: hidden;
            opacity: 0;
            transform: translateY(16px) scale(0.98);
            transition: transform 0.26s cubic-bezier(0.16, 0.86, 0.35, 1.18), box-shadow 0.24s ease, opacity 0.26s ease;
            margin-left: calc(var(--category-depth, 0) * 12px);
            border-left: 4px solid rgba(255, 255, 255, 0.18);
        }

        .start-menu-category.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .start-menu-category::before {
            content: '';
            position: absolute;
            top: 0;
            left: -1px;
            width: 6px;
            bottom: 0;
            border-radius: 4px 0 0 4px;
            background: var(--category-accent, rgba(123, 139, 255, 0.4));
            opacity: 0.7;
        }

        [data-theme="dark"] .start-menu-category {
            background: rgba(24, 30, 48, 0.78);
            border: 1px solid rgba(90, 110, 160, 0.32);
            border-left-color: rgba(90, 110, 160, 0.38);
        }

        .start-menu-category:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 32px rgba(26, 32, 68, 0.18);
        }

        .start-menu-category.drag-over {
            outline: 2px dashed var(--category-accent, rgba(123, 139, 255, 0.4));
            transform: translateY(-2px) scale(1.01);
        }

        .start-menu-category.drag-source {
            opacity: 0.7;
        }

        .start-menu-category.category-smart::after {
            content: 'Smart';
            position: absolute;
            top: 12px;
            right: 16px;
            font-size: 0.65rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.28);
            color: var(--text-muted);
        }

        .start-menu-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 16px 18px;
            cursor: pointer;
        }

        .start-menu-category-meta {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .start-menu-category-meta .glyph {
            width: 32px;
            height: 32px;
            border-radius: 12px;
            display: grid;
            place-items: center;
            background: rgba(10, 132, 255, 0.15);
            font-size: 1.1rem;
        }

        .start-menu-category-meta strong {
            font-size: 0.95rem;
            color: var(--text-primary);
        }

        .start-menu-category-meta span {
            font-size: 0.78rem;
            color: var(--text-muted);
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .start-menu-category-meta small {
            display: block;
            font-size: 0.72rem;
            color: var(--text-muted);
            letter-spacing: 0.04em;
        }

        .start-menu-category-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .start-menu-category-controls button {
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.6);
            color: inherit;
            width: 30px;
            height: 30px;
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: filter 0.15s ease;
        }

        [data-theme="dark"] .start-menu-category-controls button {
            background: rgba(34, 42, 68, 0.72);
        }

        .start-menu-category-controls button:hover {
            filter: brightness(1.1);
        }

        .start-menu-app-wrapper {
            overflow: hidden;
            transition: height 0.24s ease;
        }

        .start-menu-category[aria-expanded="false"] .start-menu-app-wrapper {
            height: 0 !important;
        }

        .start-menu-app-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 14px;
            padding: 0 18px 18px;
        }

        .start-menu-app {
            border: none;
            border-radius: 16px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.75);
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 12px;
            text-align: left;
            cursor: pointer;
            color: inherit;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            opacity: 0;
            transform: translateY(6px);
        }

        [data-theme="dark"] .start-menu-app {
            background: rgba(30, 38, 62, 0.85);
        }

        .start-menu-app:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 26px rgba(26, 32, 68, 0.2);
        }

        .start-menu-category[aria-expanded="true"] .start-menu-app {
            opacity: 1;
            transform: translateY(0);
            transition-delay: calc(var(--item-index, 0) * 40ms);
        }

        @keyframes start-menu-app-in {
            from { opacity: 0; transform: translateY(8px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @media (prefers-reduced-motion: reduce) {
            .start-menu-category {
                opacity: 1 !important;
                transform: none !important;
            }
            .start-menu-app {
                opacity: 1 !important;
                transform: none !important;
                transition: none !important;
            }
        }

        .start-menu-app .glyph {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            display: grid;
            place-items: center;
            background: rgba(255,255,255,0.85);
            font-size: 1.45rem;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
        }

        [data-theme="dark"] .start-menu-app .glyph {
            background: rgba(38, 46, 74, 0.88);
        }

        .start-menu-app .app-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .start-menu-app .app-info strong {
            font-size: 0.95rem;
        }

        .start-menu-app .app-info span {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .start-menu-app.empty {
            opacity: 0.6;
            pointer-events: none;
        }

        .start-menu-footer {
            padding: 14px 28px 24px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        #start-menu-pin[aria-pressed="true"] {
            background: rgba(10, 132, 255, 0.2);
            color: var(--accent);
            box-shadow: inset 0 0 0 1px rgba(10, 132, 255, 0.15);
        }

        @keyframes menu-in {
            from { opacity: 0; transform: translate(-50%, -55%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .context-menu {
            position: fixed;
            min-width: 200px;
            background: var(--panel-strong);
            border-radius: 14px;
            border: var(--border-soft);
            box-shadow: var(--shadow-soft);
            padding: 6px;
            display: none;
            flex-direction: column;
            z-index: 1500;
        }
        .context-menu[aria-hidden="false"] { display: flex; }
        .context-menu button {
            border: none; background: transparent; color: inherit;
            text-align: left; padding: 8px 12px;
            border-radius: 10px; font-size: 0.9rem;
            display: flex; justify-content: space-between;
            cursor: pointer;
        }
        .context-menu button:hover { background: rgba(255, 255, 255, 0.1); }

        .context-menu-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            padding: 6px 12px 4px;
        }

        #toast-container {
            position: fixed;
            top: 24px; right: 24px;
            width: min(320px, calc(100vw - 48px));
            display: flex; flex-direction: column; gap: 12px;
            z-index: 1600;
        }
        .toast {
            background: var(--panel-strong);
            border-radius: 16px;
            border: var(--border-soft);
            box-shadow: var(--shadow-soft);
            padding: 14px 16px;
            display: flex; flex-direction: column; gap: 6px;
            animation: toast-in 0.24s ease;
        }
        .toast strong { font-size: 0.94rem; }
        .toast p { margin: 0; font-size: 0.8rem; color: var(--text-muted); }
        @keyframes toast-in { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        #modal-layer {
            position: fixed; inset: 0;
            background: rgba(6, 9, 20, 0.5);
            backdrop-filter: blur(12px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1700;
        }
        #modal-layer[aria-hidden="false"] { display: flex; }
        .modal {
            width: min(560px, 92vw);
            max-height: 90vh;
            background: var(--panel-strong);
            border-radius: 18px;
            border: var(--border-strong);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .modal header { padding: 18px; border-bottom: var(--border-soft); font-weight: 600; }
        .modal main { padding: 18px; overflow: auto; }
        .modal footer { padding: 12px 18px; border-top: var(--border-soft); display: flex; gap: 10px; justify-content: flex-end; }
        .btn-primary { border: none; border-radius: 12px; padding: 8px 16px; background: var(--accent-gradient); color: #fff; cursor: pointer; }
        .btn-secondary { border: none; border-radius: 12px; padding: 8px 16px; background: rgba(255, 255, 255, 0.08); color: inherit; cursor: pointer; }

        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.16); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.24); }

        .app-shell { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        .app-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.65);
            border-bottom: var(--border-soft);
        }

        [data-theme="dark"] .app-toolbar {
            background: rgba(24, 30, 48, 0.78);
        }

        .app-toolbar button,
        .app-toolbar input,
        .app-toolbar select {
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.65);
            color: inherit;
            padding: 8px 14px;
        }

        [data-theme="dark"] .app-toolbar button,
        [data-theme="dark"] .app-toolbar input,
        [data-theme="dark"] .app-toolbar select {
            background: rgba(34, 42, 68, 0.75);
        }

        .app-toolbar button {
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .app-toolbar button:hover {
            filter: brightness(1.05);
            transform: translateY(-1px);
        }

        .game-app {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.62);
        }

        [data-theme="dark"] .game-app {
            background: rgba(16, 22, 36, 0.78);
        }

        .game-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
            justify-content: space-between;
        }

        .game-header .game-meta {
            display: flex;
            gap: 18px;
            align-items: center;
        }

        .game-header .game-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
        }

        .game-metric {
            min-width: 80px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.65);
            border: var(--border-soft);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        [data-theme="dark"] .game-metric {
            background: rgba(24, 30, 48, 0.82);
        }

        .game-metric label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .game-metric strong {
            font-size: 1.05rem;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .game-controls button {
            border: none;
            border-radius: 12px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.75);
            cursor: pointer;
        }

        [data-theme="dark"] .game-controls button {
            background: rgba(34, 42, 68, 0.85);
        }

        .game-playfield {
            flex: 1;
            min-height: 0;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 220px;
            gap: 18px;
        }

        .game-playfield.single-column {
            grid-template-columns: 1fr;
        }

        .game-canvas-wrapper {
            position: relative;
            border-radius: 18px;
            background: rgba(0, 0, 0, 0.75);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.18);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .game-canvas-wrapper canvas,
        .game-canvas-wrapper .game-stage {
            width: 100%;
            height: 100%;
            display: block;
        }

        .game-info-panel {
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.7);
            border: var(--border-soft);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow: auto;
        }

        [data-theme="dark"] .game-info-panel {
            background: rgba(18, 24, 38, 0.82);
        }

        .game-info-panel h3 {
            margin: 0;
            font-size: 0.95rem;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .game-instructions {
            margin: 0;
            font-size: 0.82rem;
            line-height: 1.5;
            color: var(--text-muted);
        }

        .game-log {
            font-size: 0.78rem;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px;
            max-height: 220px;
            overflow: auto;
        }

        .game-stage.grid {
            display: grid;
            gap: 2px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px;
        }

        .game-stage.grid span {
            display: block;
            aspect-ratio: 1 / 1;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
        }

        .game-stage.grid span.revealed {
            background: rgba(255, 255, 255, 0.75);
            color: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .game-stage.grid span.flagged {
            background: rgba(255, 178, 102, 0.8);
        }

        .solitaire-table {
            display: grid;
            grid-template-columns: repeat(7, minmax(120px, 1fr));
            gap: 12px;
        }

        .solitaire-top {
            display: grid;
            grid-template-columns: repeat(7, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 18px;
        }

        .solitaire-pile-label {
            font-size: 0.75rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .solitaire-waste {
            border-radius: 14px;
            min-height: 160px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px dashed rgba(255, 255, 255, 0.18);
            position: relative;
        }

        .solitaire-foundations {
            display: flex;
            gap: 12px;
        }

        .solitaire-foundations .solitaire-foundation-slot {
            flex: 1;
            border-radius: 14px;
            min-height: 160px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px dashed rgba(255, 255, 255, 0.18);
            position: relative;
        }

        .solitaire-foundation-slot::after {
            content: attr(data-suit);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            opacity: 0.25;
        }

        .solitaire-waste .solitaire-card,
        .solitaire-foundations .solitaire-card {
            position: absolute;
            top: 8px;
            left: 8px;
        }

        .solitaire-card.drag-source {
            opacity: 0.2;
        }

        .solitaire-drop-indicator {
            position: absolute;
            inset: 0;
            border: 2px dashed rgba(74, 163, 255, 0.8);
            border-radius: 12px;
            pointer-events: none;
        }

        .solitaire-column,
        .solitaire-foundations,
        .solitaire-stock {
            border-radius: 14px;
            min-height: 160px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px dashed rgba(255, 255, 255, 0.18);
            position: relative;
        }

        .solitaire-card {
            width: 100%;
            height: 140px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.95);
            color: #222;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 8px;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.18);
            position: absolute;
            left: 8px;
            cursor: grab;
            user-select: none;
        }

        .solitaire-card.face-down {
            background: linear-gradient(135deg, #243b6b, #16213d);
            color: #fff;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
        }

        .solitaire-card.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .solitaire-table .drop-target {
            outline: 2px dashed rgba(74, 163, 255, 0.8);
        }

        .game-overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(6, 12, 28, 0.72);
            color: #fff;
            font-size: 1.4rem;
            z-index: 5;
        }

        .game-legend {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 6px;
            font-size: 0.78rem;
        }

        .game-legend li {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-legend span {
            width: 14px;
            height: 14px;
            border-radius: 4px;
            display: inline-block;
        }

        .game-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-actions button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.75);
            cursor: pointer;
        }

        [data-theme="dark"] .game-actions button {
            background: rgba(34, 42, 68, 0.85);
        }

        .file-explorer {
            flex: 1;
            display: grid;
            grid-template-columns: 230px 1fr 260px;
            min-height: 0;
        }
        .file-explorer section {
            padding: 14px;
            overflow: auto;
            background: rgba(255, 255, 255, 0.62);
        }

        [data-theme="dark"] .file-explorer section {
            background: rgba(16, 22, 36, 0.75);
        }
        .file-explorer section + section { border-left: var(--border-soft); }
        .tree-item { padding: 6px 10px; border-radius: 10px; color: var(--text-muted); cursor: pointer; }
        .tree-item:hover, .tree-item.active { background: rgba(123, 139, 255, 0.2); color: var(--text-primary); }
        .file-breadcrumb {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 0.78rem;
            margin-bottom: 12px;
            color: var(--text-muted);
        }
        .file-breadcrumb button {
            border: none;
            background: transparent;
            color: inherit;
            cursor: pointer;
            padding: 0;
        }
        .file-view-toggle {
            display: inline-flex;
            border-radius: 10px;
            overflow: hidden;
            border: var(--border-soft);
        }
        .file-view-toggle button {
            border: none;
            background: transparent;
            padding: 6px 10px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .file-view-toggle button.active {
            background: rgba(123, 139, 255, 0.18);
            color: var(--text-primary);
        }
        .file-table { width: 100%; border-collapse: collapse; }
        .file-table th { text-align: left; font-size: 0.72rem; text-transform: uppercase; color: var(--text-muted); padding-bottom: 6px; }
        .file-row { cursor: pointer; border-radius: 10px; }
        .file-row td { padding: 8px 6px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .file-row:hover { background: rgba(255,255,255,0.08); }
        .file-row.active { background: rgba(123,139,255,0.22); }
        .file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 14px;
        }
        .file-card {
            background: rgba(255, 255, 255, 0.72);
            border-radius: 14px;
            border: var(--border-soft);
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.2s ease;
        }
        .file-card:hover { transform: translateY(-3px); box-shadow: var(--shadow-soft); }
        .file-card.active { outline: 2px solid var(--accent); outline-offset: 2px; box-shadow: var(--shadow); }
        .file-card-icon { font-size: 2rem; }
        .file-card strong { font-size: 0.95rem; color: var(--text-primary); }
        .file-card-meta { font-size: 0.75rem; color: var(--text-muted); display: flex; flex-direction: column; gap: 2px; }

        .calendar-app { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .calendar-toolbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .calendar-toolbar h2 { margin: 0; font-size: 1.3rem; }
        .calendar-toolbar .spacer { flex: 1; }
        .calendar-body { flex: 1; display: grid; grid-template-columns: minmax(0, 1fr) 260px; gap: 16px; min-height: 0; }
        .calendar-month { background: rgba(255, 255, 255, 0.65); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: hidden; }
        [data-theme="dark"] .calendar-month { background: rgba(20, 26, 42, 0.78); }
        .calendar-weekday-row { display: grid; grid-template-columns: repeat(7, minmax(0, 1fr)); font-size: 0.78rem; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.08em; }
        .calendar-weekday-row span { padding: 4px 6px; text-align: center; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, minmax(0, 1fr)); gap: 10px; flex: 1; min-height: 0; }
        .calendar-cell { background: rgba(255, 255, 255, 0.75); border-radius: 14px; border: var(--border-soft); padding: 10px; display: flex; flex-direction: column; gap: 6px; min-height: 110px; cursor: pointer; }
        [data-theme="dark"] .calendar-cell { background: rgba(24, 30, 48, 0.82); }
        .calendar-cell header { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; font-weight: 600; }
        .calendar-cell.outside { opacity: 0.45; }
        .calendar-cell.today { outline: 2px solid var(--accent); outline-offset: 2px; }
        .calendar-cell.selected { box-shadow: 0 0 0 2px rgba(123,139,255,0.4); }
        .calendar-events { display: flex; flex-direction: column; gap: 4px; overflow: hidden; }
        .calendar-event { background: rgba(123, 139, 255, 0.15); border-radius: 10px; padding: 4px 6px; font-size: 0.75rem; color: var(--text-primary); display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .calendar-event[data-past="true"] { opacity: 0.6; }
        [data-theme="dark"] .calendar-event { background: rgba(123, 139, 255, 0.25); }
        .calendar-more { font-size: 0.7rem; color: var(--text-muted); }
        .calendar-sidebar { background: rgba(255, 255, 255, 0.65); border-radius: 18px; border: var(--border-soft); padding: 18px; display: flex; flex-direction: column; gap: 12px; overflow: auto; }
        [data-theme="dark"] .calendar-sidebar { background: rgba(20, 26, 42, 0.78); }
        .calendar-section { display: flex; flex-direction: column; gap: 10px; }
        .calendar-section h3 { margin: 0; font-size: 0.95rem; }
        .calendar-upcoming { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 10px; }
        .calendar-upcoming li { display: flex; flex-direction: column; gap: 4px; padding: 10px; border-radius: 12px; background: rgba(255,255,255,0.7); border: var(--border-soft); }
        [data-theme="dark"] .calendar-upcoming li { background: rgba(24, 30, 48, 0.82); }
        .calendar-upcoming strong { font-size: 0.9rem; }
        .calendar-upcoming span { font-size: 0.78rem; color: var(--text-muted); }
        .calendar-empty { font-size: 0.78rem; color: var(--text-muted); }

        .mail-app { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .mail-toolbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .mail-toolbar .spacer { flex: 1; }
        .mail-layout { flex: 1; display: grid; grid-template-columns: 220px 260px 1fr; gap: 16px; min-height: 0; }
        .mail-pane { background: rgba(255, 255, 255, 0.68); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: hidden; min-height: 0; }
        [data-theme="dark"] .mail-pane { background: rgba(20, 26, 42, 0.82); }
        .mail-accounts { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; }
        .mail-accounts li { padding: 10px; border-radius: 12px; cursor: pointer; display: flex; flex-direction: column; gap: 4px; transition: background 0.2s ease; }
        .mail-accounts li:hover { background: rgba(123, 139, 255, 0.18); }
        .mail-accounts li.active { background: rgba(123, 139, 255, 0.28); color: var(--text-primary); }
        .mail-folder-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 6px; }
        .mail-folder-list button { border: none; background: transparent; padding: 6px 8px; border-radius: 10px; text-align: left; color: inherit; cursor: pointer; }
        .mail-folder-list button:hover { background: rgba(123, 139, 255, 0.16); }
        .mail-folder-list button.active { background: rgba(123, 139, 255, 0.26); color: var(--text-primary); }
        .mail-message-list { flex: 1; overflow: auto; display: flex; flex-direction: column; gap: 8px; padding-right: 4px; }
        .mail-message { border-radius: 12px; padding: 10px; background: rgba(255, 255, 255, 0.75); border: var(--border-soft); cursor: pointer; display: flex; flex-direction: column; gap: 4px; transition: box-shadow 0.2s ease; }
        [data-theme="dark"] .mail-message { background: rgba(24, 30, 48, 0.85); }
        .mail-message:hover { box-shadow: var(--shadow-soft); }
        .mail-message.unread strong { font-weight: 700; }
        .mail-message .meta { font-size: 0.72rem; color: var(--text-muted); display: flex; justify-content: space-between; gap: 8px; }
        .mail-message .snippet { font-size: 0.75rem; color: var(--text-muted); }
        .mail-message.active { outline: 2px solid var(--accent); outline-offset: 2px; }
        .mail-preview { flex: 1; overflow: auto; display: flex; flex-direction: column; gap: 12px; }
        .mail-preview header { display: flex; flex-direction: column; gap: 4px; }
        .mail-preview header strong { font-size: 1.1rem; }
        .mail-preview article { background: rgba(255, 255, 255, 0.72); border-radius: 14px; border: var(--border-soft); padding: 16px; line-height: 1.6; white-space: pre-wrap; }
        [data-theme="dark"] .mail-preview article { background: rgba(24, 30, 48, 0.88); }
        .mail-preview footer { display: flex; gap: 8px; flex-wrap: wrap; }
        .mail-compose { display: flex; flex-direction: column; gap: 10px; }
        .mail-compose textarea { min-height: 160px; border-radius: 10px; padding: 12px; resize: vertical; }
        .mail-empty { font-size: 0.78rem; color: var(--text-muted); }

        .chat-app { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .chat-toolbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .chat-layout { flex: 1; display: grid; grid-template-columns: 240px 1fr; gap: 16px; min-height: 0; }
        .chat-pane { background: rgba(255, 255, 255, 0.68); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: hidden; }
        [data-theme="dark"] .chat-pane { background: rgba(22, 28, 44, 0.85); }
        .chat-thread-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; overflow: auto; }
        .chat-thread { border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.75); border: var(--border-soft); cursor: pointer; }
        [data-theme="dark"] .chat-thread { background: rgba(28, 34, 52, 0.85); }
        .chat-thread.active { outline: 2px solid var(--accent); outline-offset: 2px; }
        .chat-history { flex: 1; overflow: auto; display: flex; flex-direction: column; gap: 10px; padding-right: 4px; }
        .chat-message { border-radius: 14px; padding: 10px 12px; max-width: 72%; line-height: 1.5; font-size: 0.92rem; }
        .chat-message.user { align-self: flex-end; background: var(--accent-gradient); color: #fff; }
        .chat-message.peer { align-self: flex-start; background: rgba(255,255,255,0.78); border: var(--border-soft); }
        [data-theme="dark"] .chat-message.peer { background: rgba(28, 34, 52, 0.9); }
        .chat-input { display: flex; gap: 10px; padding-top: 8px; }
        .chat-input textarea { flex: 1; resize: none; min-height: 60px; border-radius: 12px; padding: 10px; }
        .chat-status { font-size: 0.75rem; color: var(--text-muted); }

        .code-editor { display: grid; grid-template-columns: 240px 1fr; gap: 16px; height: 100%; min-height: 0; }
        .code-files, .code-workspace { background: rgba(255, 255, 255, 0.68); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; min-height: 0; overflow: hidden; }
        [data-theme="dark"] .code-files, [data-theme="dark"] .code-workspace { background: rgba(20, 26, 42, 0.82); }
        .code-file-list { list-style: none; margin: 0; padding: 0; flex: 1; overflow: auto; display: flex; flex-direction: column; gap: 6px; }
        .code-file-list button { border: none; background: transparent; text-align: left; padding: 6px 8px; border-radius: 10px; color: inherit; cursor: pointer; }
        .code-file-list button.active { background: rgba(123,139,255,0.2); color: var(--text-primary); }
        .code-editor-toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .code-editor-body { position: relative; flex: 1; display: grid; grid-template-columns: 1fr; }
        .code-editor textarea { font-family: "JetBrains Mono", monospace; font-size: 0.95rem; line-height: 1.6; border-radius: 12px; border: var(--border-soft); padding: 16px; background: rgba(7, 12, 28, 0.85); color: #f7f9ff; resize: none; }
        .code-preview { font-family: "JetBrains Mono", monospace; font-size: 0.9rem; background: rgba(255,255,255,0.75); border-radius: 12px; border: var(--border-soft); padding: 12px; max-height: 160px; overflow: auto; }
        [data-theme="dark"] .code-preview { background: rgba(24, 30, 48, 0.85); }

        .paint-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .paint-toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .paint-canvas-wrap { flex: 1; background: rgba(255,255,255,0.7); border-radius: 18px; border: var(--border-soft); display: flex; align-items: center; justify-content: center; }
        [data-theme="dark"] .paint-canvas-wrap { background: rgba(18, 24, 38, 0.82); }
        .paint-canvas { background: #fff; border-radius: 12px; box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1); max-width: 100%; }

        .sheet-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .sheet-toolbar { display: flex; gap: 10px; flex-wrap: wrap; }
        .sheet-grid { flex: 1; overflow: auto; background: rgba(255,255,255,0.7); border-radius: 18px; border: var(--border-soft); padding: 12px; }
        [data-theme="dark"] .sheet-grid { background: rgba(20, 26, 42, 0.82); }
        .sheet-table { border-collapse: collapse; width: max-content; min-width: 100%; }
        .sheet-table th, .sheet-table td { border: 1px solid rgba(123,139,255,0.25); padding: 6px 10px; min-width: 90px; font-size: 0.85rem; }
        .sheet-table td { background: rgba(255,255,255,0.85); }
        [data-theme="dark"] .sheet-table td { background: rgba(28, 34, 52, 0.88); color: #e4e9ff; }
        .sheet-formula { display: flex; gap: 8px; align-items: center; }
        .sheet-formula input { flex: 1; }

        .database-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .database-layout { flex: 1; display: grid; grid-template-columns: 280px 1fr; gap: 16px; min-height: 0; }
        .database-pane { background: rgba(255,255,255,0.7); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; min-height: 0; }
        [data-theme="dark"] .database-pane { background: rgba(20, 26, 42, 0.82); }
        .database-query { flex: 1; display: flex; flex-direction: column; gap: 8px; }
        .database-query textarea { flex: 1; border-radius: 12px; padding: 12px; font-family: "JetBrains Mono", monospace; }
        .database-result { flex: 1; overflow: auto; }
        .database-result table { border-collapse: collapse; width: 100%; }
        .database-result th, .database-result td { border: 1px solid rgba(123,139,255,0.2); padding: 6px 8px; font-size: 0.85rem; }

        .cloud-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .cloud-layout { flex: 1; display: grid; grid-template-columns: 280px 1fr; gap: 16px; min-height: 0; }
        .cloud-pane { background: rgba(255,255,255,0.68); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: hidden; }
        [data-theme="dark"] .cloud-pane { background: rgba(22, 28, 44, 0.85); }
        .cloud-accounts { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 8px; overflow: auto; }
        .cloud-accounts li { border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.78); border: var(--border-soft); display: flex; flex-direction: column; gap: 4px; }
        [data-theme="dark"] .cloud-accounts li { background: rgba(28, 34, 52, 0.88); }
        .cloud-sync-log { flex: 1; overflow: auto; background: rgba(255,255,255,0.75); border-radius: 12px; border: var(--border-soft); padding: 10px; font-size: 0.82rem; }
        [data-theme="dark"] .cloud-sync-log { background: rgba(28, 34, 52, 0.88); }

        .capture-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .capture-toolbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .capture-preview { flex: 1; background: rgba(255,255,255,0.7); border-radius: 18px; border: var(--border-soft); display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; }
        [data-theme="dark"] .capture-preview { background: rgba(20, 26, 42, 0.82); }
        .capture-preview video, .capture-preview img { max-width: 100%; border-radius: 12px; }
        .capture-status { font-size: 0.78rem; color: var(--text-muted); text-align: center; }

        .package-app { display: flex; flex-direction: column; gap: 14px; height: 100%; }
        .package-layout { flex: 1; display: grid; grid-template-columns: 260px 1fr; gap: 16px; min-height: 0; }
        .package-pane { background: rgba(255,255,255,0.7); border-radius: 18px; border: var(--border-soft); padding: 16px; display: flex; flex-direction: column; gap: 12px; overflow: hidden; }
        [data-theme="dark"] .package-pane { background: rgba(20, 26, 42, 0.82); }
        .package-list { flex: 1; overflow: auto; display: flex; flex-direction: column; gap: 10px; }
        .package-card { border-radius: 12px; padding: 12px; background: rgba(255,255,255,0.78); border: var(--border-soft); display: flex; flex-direction: column; gap: 8px; }
        [data-theme="dark"] .package-card { background: rgba(24, 30, 48, 0.88); }

        .store-app { display: flex; flex-direction: column; gap: 16px; height: 100%; }
        .store-search { display: flex; gap: 10px; flex-wrap: wrap; }
        .store-search input { flex: 1; }
        .store-grid { flex: 1; overflow: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; }
        .store-card { border-radius: 18px; padding: 16px; background: rgba(255,255,255,0.75); border: var(--border-soft); display: flex; flex-direction: column; gap: 10px; }
        [data-theme="dark"] .store-card { background: rgba(24, 30, 48, 0.88); }
        .store-card footer { display: flex; gap: 8px; }

        .preview-card {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 16px;
            border: var(--border-soft);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        [data-theme="dark"] .preview-card {
            background: rgba(18, 24, 38, 0.8);
        }

        [data-theme="dark"] .file-card {
            background: rgba(18, 24, 38, 0.82);
        }

        .preview-body {
            background: rgba(255, 255, 255, 0.75);
            border-radius: 14px;
            padding: 12px;
            font-family: "JetBrains Mono", monospace;
            font-size: 0.82rem;
            max-height: 240px;
            overflow: auto;
        }

        [data-theme="dark"] .preview-body {
            background: rgba(22, 28, 46, 0.72);
        }

        .preview-body img { max-width: 100%; border-radius: 14px; }

        .editor-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.78);
            color: inherit;
            border: none;
            padding: 18px;
            resize: none;
            font-family: "JetBrains Mono", monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            outline: none;
        }

        [data-theme="dark"] .editor-area {
            background: rgba(14, 20, 34, 0.82);
        }
        .editor-status { padding: 6px 12px; border-top: var(--border-soft); display: flex; justify-content: space-between; font-size: 0.78rem; color: var(--text-muted); }

        .browser-layout { flex: 1; display: grid; grid-template-columns: minmax(0, 1fr) 260px; min-height: 0; }
        .browser-viewport {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.72);
            border-right: var(--border-soft);
        }

        [data-theme="dark"] .browser-viewport {
            background: rgba(16, 22, 36, 0.78);
        }
        .browser-viewport iframe { flex: 1; border: none; background: #ffffff; }
        .browser-sidebar {
            background: rgba(255, 255, 255, 0.7);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow: auto;
            border-left: var(--border-soft);
        }

        [data-theme="dark"] .browser-sidebar {
            background: rgba(20, 26, 44, 0.78);
        }
        .browser-panel { display: flex; flex-direction: column; gap: 10px; }
        .browser-panel h3 { margin: 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .browser-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 12px; }
        .browser-list li {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.78);
        }

        [data-theme="dark"] .browser-list li {
            background: rgba(24, 30, 48, 0.82);
        }

        .browser-list li span {
            flex: 1;
            font-size: 0.82rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .browser-list li button {
            border: none;
            background: rgba(255,255,255,0.75);
            color: inherit;
            border-radius: 10px;
            padding: 4px 8px;
            cursor: pointer;
        }

        [data-theme="dark"] .browser-list li button {
            background: rgba(36, 44, 70, 0.85);
        }

        .browser-list li button:hover {
            filter: brightness(1.05);
        }
        .browser-status { font-size: 0.75rem; color: var(--text-muted); }

        .terminal { flex: 1; display: grid; grid-template-rows: 1fr auto; background: #020308; }
        .terminal-output { padding: 16px; font-family: "JetBrains Mono", monospace; font-size: 0.84rem; color: #d4fca3; overflow: auto; }
        .terminal-input { display: flex; gap: 8px; padding: 12px 16px; border-top: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.32); }
        .terminal-input input { flex: 1; border: none; border-radius: 8px; background: rgba(255,255,255,0.12); color: inherit; padding: 8px 10px; font-family: inherit; }

        .calculator { flex: 1; display: grid; grid-template-rows: auto 1fr; padding: 20px; gap: 16px; }
        .calc-display { background: rgba(0,0,0,0.4); border-radius: 14px; padding: 18px; text-align: right; font-size: 2rem; font-family: "JetBrains Mono", monospace; }
        .calc-grid { display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 10px; }
        .calc-grid button { border-radius: 12px; border: none; background: rgba(255,255,255,0.1); color: inherit; padding: 14px 0; font-size: 1rem; cursor: pointer; }
        .calc-grid button:hover { background: rgba(255,255,255,0.2); }

        .media-player { flex: 1; display: grid; grid-template-columns: minmax(320px, 2fr) minmax(220px, 1fr); min-height: 0; }
        .media-stage { display: flex; flex-direction: column; padding: 20px; gap: 16px; }
        .media-screen { flex: 1; background: rgba(0,0,0,0.5); border-radius: 16px; display: grid; place-items: center; overflow: hidden; }
        .playlist { padding: 18px; border-left: var(--border-soft); display: flex; flex-direction: column; gap: 12px; overflow: auto; }
        .playlist-item { padding: 10px 12px; border-radius: 12px; background: rgba(255,255,255,0.08); display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .playlist-item.active { background: rgba(123,139,255,0.26); }

        .notes-app {
            flex: 1;
            display: grid;
            grid-template-columns: 280px 1fr;
            min-height: 0;
        }
        @media (max-width: 820px) {
            .notes-app {
                grid-template-columns: 1fr;
            }
            .notes-sidebar {
                border-right: none;
                border-bottom: var(--border-soft);
                flex-direction: row;
                align-items: flex-start;
                flex-wrap: wrap;
            }
            .notes-list {
                max-height: 220px;
                flex: 1 1 100%;
            }
        }
        .notes-sidebar {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.62);
            border-right: var(--border-soft);
        }
        [data-theme="dark"] .notes-sidebar {
            background: rgba(16, 22, 36, 0.78);
        }
        .notes-sidebar header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .notes-sidebar header button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.82);
            cursor: pointer;
        }
        [data-theme="dark"] .notes-sidebar header button {
            background: rgba(28, 36, 60, 0.82);
        }
        .notes-sidebar header button:hover {
            filter: brightness(1.05);
        }
        .notes-search {
            width: 100%;
            border-radius: 10px;
            border: none;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.78);
            color: inherit;
        }
        [data-theme="dark"] .notes-search {
            background: rgba(28, 36, 60, 0.85);
        }
        .notes-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: auto;
        }
        .note-list-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            border-radius: 12px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(190, 200, 226, 0.32);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        [data-theme="dark"] .note-list-item {
            background: rgba(24, 30, 48, 0.82);
            border: 1px solid rgba(90, 110, 160, 0.28);
        }
        .note-list-item.active {
            border-color: rgba(10, 132, 255, 0.45);
            box-shadow: 0 12px 24px rgba(10, 132, 255, 0.18);
        }
        .note-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 18px rgba(26, 32, 68, 0.18);
        }
        .note-item-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .note-item-title {
            flex: 1;
            font-weight: 600;
            font-size: 0.92rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .note-item-meta {
            font-size: 0.72rem;
            color: var(--text-muted);
        }
        .note-pin {
            border: none;
            background: transparent;
            color: inherit;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .notes-editor {
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 20px;
            gap: 12px;
            background: rgba(255, 255, 255, 0.75);
        }
        [data-theme="dark"] .notes-editor {
            background: rgba(14, 20, 34, 0.82);
        }
        .notes-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .notes-toolbar button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.82);
            cursor: pointer;
        }
        [data-theme="dark"] .notes-toolbar button {
            background: rgba(28, 36, 60, 0.85);
        }
        .notes-toolbar button:hover {
            filter: brightness(1.05);
        }
        .notes-title {
            font-size: 1.25rem;
            font-weight: 600;
            border: none;
            background: transparent;
            color: inherit;
        }
        .notes-title:focus {
            outline: none;
        }
        .notes-body {
            flex: 1;
            border: none;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.78);
            color: inherit;
            padding: 16px;
            font-family: "JetBrains Mono", monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            resize: none;
        }
        [data-theme="dark"] .notes-body {
            background: rgba(22, 28, 46, 0.8);
        }
        .notes-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: space-between;
            font-size: 0.78rem;
            color: var(--text-muted);
        }
        .notes-empty {
            margin: auto;
            text-align: center;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .monitor-app {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.72);
        }
        [data-theme="dark"] .monitor-app {
            background: rgba(16, 22, 36, 0.82);
        }
        .monitor-grid {
            display: grid;
            gap: 16px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
        .monitor-card {
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.78);
            border: var(--border-soft);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        [data-theme="dark"] .monitor-card {
            background: rgba(18, 24, 38, 0.86);
        }
        .monitor-card h3 {
            margin: 0;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }
        .monitor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .monitor-actions button {
            border: none;
            border-radius: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.82);
            cursor: pointer;
        }
        [data-theme="dark"] .monitor-actions button {
            background: rgba(28, 36, 60, 0.85);
        }
        .monitor-actions button:hover {
            filter: brightness(1.05);
        }
        .monitor-highlight {
            font-size: 1.6rem;
            font-weight: 600;
        }
        .monitor-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.86rem;
        }
        .monitor-list li {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }
        .monitor-chart {
            width: 100%;
            height: 140px;
            border-radius: 14px;
            background: rgba(0, 0, 0, 0.12);
        }
        [data-theme="dark"] .monitor-chart {
            background: rgba(255, 255, 255, 0.08);
        }

        .image-viewer { flex: 1; position: relative; background: rgba(0,0,0,0.92); display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .image-viewer img { max-width: 100%; max-height: 100%; transition: transform 0.25s ease; border-radius: 18px; }
        .image-controls { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(0,0,0,0.4); padding: 10px 16px; border-radius: 14px; }
        .image-controls button { border: none; background: transparent; color: #fff; font-size: 1.1rem; cursor: pointer; }

        .settings { flex: 1; display: grid; grid-template-columns: 230px 1fr; min-height: 0; }
        .settings-nav { border-right: var(--border-soft); padding: 18px; display: flex; flex-direction: column; gap: 10px; }
        .settings-nav button { border: none; border-radius: 12px; padding: 10px; text-align: left; background: rgba(255,255,255,0.07); color: inherit; cursor: pointer; }
        .settings-nav button.active { background: rgba(123,139,255,0.24); }
        .settings-content { padding: 20px; overflow: auto; display: flex; flex-direction: column; gap: 24px; }
        .settings-section h3 { margin: 0 0 12px; }
        .settings-row { display: flex; flex-direction: column; gap: 8px; }
        .settings-row label { color: var(--text-muted); font-size: 0.82rem; }
        .settings-row input[type="color"], .settings-row select, .settings-row input[type="range"], .settings-row input[type="checkbox"], .settings-row button { width: fit-content; }
        .settings-controls { display: flex; flex-wrap: wrap; gap: 12px; }
        .settings-controls button { border: none; border-radius: 12px; padding: 8px 14px; background: rgba(255,255,255,0.82); cursor: pointer; }
        [data-theme="dark"] .settings-controls button { background: rgba(32, 40, 64, 0.82); }
        .settings-controls button:hover { filter: brightness(1.05); }

        .task-app { flex: 1; display: grid; grid-template-columns: 250px minmax(0, 1fr) 300px; min-height: 0; overflow: hidden; gap: 0; }
        .task-sidebar { display: flex; flex-direction: column; gap: 16px; padding: 20px; background: rgba(255, 255, 255, 0.62); border-right: var(--border-soft); }
        [data-theme="dark"] .task-sidebar { background: rgba(16, 22, 36, 0.8); }
        .task-sidebar header { display: flex; align-items: center; justify-content: space-between; }
        .task-sidebar h3 { margin: 0; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .task-sidebar button { border: none; border-radius: 12px; background: rgba(255,255,255,0.7); color: inherit; padding: 8px 12px; cursor: pointer; }
        [data-theme="dark"] .task-sidebar button { background: rgba(32, 40, 64, 0.82); }
        .task-sidebar button:hover { filter: brightness(1.05); }
        .task-filter-list, .task-project-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 6px; }
        .task-filter-item, .task-project-item { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 12px; cursor: pointer; }
        .task-filter-item.active, .task-project-item.active { background: rgba(123,139,255,0.22); color: var(--text-primary); }
        .task-filter-item .count, .task-project-item .count { margin-left: auto; color: var(--text-muted); font-size: 0.75rem; }
        .task-project-color { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 0 2px rgba(255,255,255,0.4); }
        .task-project-item button { margin-left: 8px; border: none; background: transparent; color: inherit; cursor: pointer; padding: 0 4px; }
        .task-project-item button:hover { color: var(--danger); }
        .task-new-project { display: grid; grid-template-columns: 1fr 60px auto; gap: 8px; }
        .task-new-project input[type="text"] { border: none; border-radius: 10px; padding: 8px 10px; background: rgba(255,255,255,0.75); color: inherit; }
        .task-new-project input[type="color"] { border: none; border-radius: 10px; padding: 0; height: 36px; }
        .task-new-project button { padding: 8px 12px; }

        .task-main { display: flex; flex-direction: column; background: rgba(255,255,255,0.6); min-height: 0; }
        [data-theme="dark"] .task-main { background: rgba(14, 20, 34, 0.82); }
        .task-toolbar { display: flex; gap: 12px; padding: 16px 18px; align-items: center; border-bottom: var(--border-soft); }
        .task-toolbar input[type="text"] { flex: 1; border: none; border-radius: 12px; padding: 10px 14px; background: rgba(255,255,255,0.78); color: inherit; }
        [data-theme="dark"] .task-toolbar input[type="text"] { background: rgba(28, 36, 60, 0.88); }
        .task-toolbar button { border: none; border-radius: 12px; background: rgba(255,255,255,0.75); padding: 9px 14px; cursor: pointer; color: inherit; }
        [data-theme="dark"] .task-toolbar button { background: rgba(32, 40, 64, 0.85); }
        .task-toolbar button.active { background: var(--accent); color: #fff; }

        .task-list { flex: 1; overflow: auto; padding: 18px; display: flex; flex-direction: column; gap: 12px; }
        .task-card { display: grid; grid-template-columns: auto 1fr auto; gap: 12px; align-items: start; padding: 14px; border-radius: 16px; background: rgba(255,255,255,0.78); border: 1px solid rgba(190, 200, 226, 0.32); cursor: pointer; transition: transform 0.18s ease, box-shadow 0.18s ease; }
        [data-theme="dark"] .task-card { background: rgba(22, 28, 46, 0.85); border: 1px solid rgba(90, 110, 160, 0.32); }
        .task-card:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(26, 32, 68, 0.18); }
        .task-card.active { border-color: rgba(10, 132, 255, 0.45); box-shadow: 0 14px 30px rgba(10, 132, 255, 0.22); }
        .task-card.completed { opacity: 0.55; }
        .task-card h4 { margin: 0; font-size: 1rem; }
        .task-card .task-meta { display: flex; flex-wrap: wrap; gap: 8px; font-size: 0.75rem; color: var(--text-muted); }
        .task-card .task-chip { padding: 4px 8px; border-radius: 999px; background: rgba(123,139,255,0.18); color: var(--text-primary); font-size: 0.72rem; letter-spacing: 0.02em; }
        .task-card .task-chip.due-soon { background: rgba(255,130,102,0.22); }
        .task-card .task-chip.overdue { background: rgba(255,96,88,0.22); }
        .task-card .task-chip.priority-high { background: rgba(255,190,70,0.22); }
        .task-card .task-chip.priority-urgent { background: rgba(255,96,88,0.26); }
        .task-card .task-actions { display: flex; gap: 10px; align-items: center; }
        .task-card .task-actions button { border: none; background: transparent; color: inherit; cursor: pointer; font-size: 1.1rem; }
        .task-card .task-actions button:hover { transform: scale(1.1); }
        .task-card input[type="checkbox"] { width: 18px; height: 18px; }

        .task-focus-panel { flex: 1; display: none; padding: 24px; align-items: center; justify-content: center; }
        .task-focus-panel.active { display: flex; }
        .task-focus-card { max-width: 540px; width: 100%; background: rgba(255,255,255,0.84); border-radius: 22px; border: 1px solid rgba(180, 190, 220, 0.35); padding: 28px; display: flex; flex-direction: column; gap: 18px; box-shadow: 0 28px 38px rgba(24, 32, 64, 0.22); }
        [data-theme="dark"] .task-focus-card { background: rgba(18, 24, 38, 0.92); border: 1px solid rgba(90, 110, 160, 0.35); }
        .task-focus-card h2 { margin: 0; font-size: 1.4rem; }
        .task-focus-actions { display: flex; gap: 12px; }
        .task-focus-actions button { flex: 1; border: none; border-radius: 14px; padding: 12px 16px; cursor: pointer; background: var(--accent-gradient); color: #fff; font-weight: 600; }
        .task-focus-actions button.secondary { background: rgba(255,255,255,0.8); color: var(--text-primary); }
        [data-theme="dark"] .task-focus-actions button.secondary { background: rgba(34, 42, 68, 0.85); color: inherit; }

        .task-detail { background: rgba(255,255,255,0.64); padding: 22px; border-left: var(--border-soft); display: flex; flex-direction: column; gap: 16px; }
        [data-theme="dark"] .task-detail { background: rgba(16, 22, 36, 0.88); }
        .task-detail h3 { margin: 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-muted); }
        .task-detail-form { display: flex; flex-direction: column; gap: 12px; }
        .task-detail input[type="text"], .task-detail textarea, .task-detail select, .task-detail input[type="datetime-local"] {
            border: none; border-radius: 12px; padding: 10px 12px; background: rgba(255,255,255,0.78); color: inherit; font-family: inherit;
        }
        [data-theme="dark"] .task-detail input[type="text"], [data-theme="dark"] .task-detail textarea, [data-theme="dark"] .task-detail select, [data-theme="dark"] .task-detail input[type="datetime-local"] {
            background: rgba(28, 36, 60, 0.88);
        }
        .task-detail textarea { min-height: 140px; resize: vertical; }
        .task-detail .task-detail-row { display: flex; flex-direction: column; gap: 6px; }
        .task-detail footer { margin-top: auto; display: flex; gap: 12px; }
        .task-detail footer button { flex: 1; border-radius: 14px; border: none; padding: 10px 14px; cursor: pointer; background: rgba(255,255,255,0.82); }
        [data-theme="dark"] .task-detail footer button { background: rgba(32, 40, 64, 0.85); }
        .task-detail footer button.danger { background: rgba(255,96,88,0.22); color: #ffb0aa; }

        .task-detail-empty { margin: auto; text-align: center; font-size: 0.9rem; color: var(--text-muted); line-height: 1.6; }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
            white-space: nowrap;
        }
        .shortcut-app {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.68);
            border-radius: 22px;
            border: var(--border-soft);
        }
        [data-theme="dark"] .shortcut-app {
            background: rgba(18, 24, 38, 0.82);
        }
        .shortcut-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .shortcut-header h2 {
            margin: 0;
            font-size: 1.35rem;
        }
        .shortcut-url {
            font-size: 0.82rem;
            color: var(--text-muted);
            word-break: break-all;
        }
        .shortcut-body {
            font-size: 0.92rem;
            color: var(--text-muted);
            line-height: 1.6;
        }
        .shortcut-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .shortcut-tag {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(123, 139, 255, 0.2);
            font-size: 0.72rem;
            letter-spacing: 0.02em;
            color: var(--text-primary);
        }
        .shortcut-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: auto;
        }
        .shortcut-actions button {
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.82);
            color: inherit;
        }
        [data-theme="dark"] .shortcut-actions button {
            background: rgba(34, 42, 68, 0.85);
        }
        .shortcut-actions button.primary {
            background: var(--accent-gradient);
            color: #fff;
        }

        @media (max-width: 1100px) {
            #desktop {
                grid-template-columns: minmax(0, 1fr);
                padding: 72px 20px calc(var(--taskbar-height) + 32px);
            }
            #desktop-launcher {
                flex-direction: row;
                gap: 18px;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 16px;
            }
            .desktop-section { min-width: 220px; }
            .file-explorer { grid-template-columns: 210px 1fr; }
            .file-explorer section:last-child { display: none; }
            .media-player { grid-template-columns: 1fr; }
            .playlist { border-left: none; border-top: var(--border-soft); }
            .browser-layout { grid-template-columns: 1fr; }
            .browser-sidebar { border-left: none; border-top: var(--border-soft); }
        }
        @media (max-width: 840px) {
            #desktop-launcher {
                flex-direction: column;
                overflow: auto;
            }
            .desktop-section { min-width: 0; }
            .settings { grid-template-columns: 1fr; }
            .settings-nav { flex-direction: row; overflow-x: auto; }
            .settings-nav button { flex: 1 0 auto; }
            #desktop {
                padding: 72px 18px calc(var(--taskbar-height) + 36px);
            }
        }
        @media (max-width: 680px) {
            #taskbar {
                max-width: 90vw;
                gap: 14px;
            }
            #start-button {
                width: 52px;
                height: 52px;
            }
        }
    </style>
</head>
<body>
    <div id="wallpaper-layer"></div>
    <canvas id="desktop-bg"></canvas>
    <header id="menu-bar">
        <div class="menu-left">
            <button id="menu-apple" aria-label="Apple menu" type="button"></button>
            <nav id="menu-items">
                <button type="button" data-menu="finder">ToastSearcher</button>
                <button type="button" data-menu="file">File</button>
                <button type="button" data-menu="edit">Edit</button>
                <button type="button" data-menu="view">View</button>
                <button type="button" data-menu="go">Go</button>
                <button type="button" data-menu="window">Window</button>
                <button type="button" data-menu="help">Help</button>
            </nav>
        </div>
        <div class="menu-center">Designed by Jared Sanford · Slighty.Toasted</div>
        <div class="menu-right">
            <button id="notification-button" aria-label="Notifications" type="button">🔔</button>
            <button id="theme-toggle" aria-label="Toggle appearance" type="button">🌗</button>
            <span id="tray-clock">00:00</span>
        </div>
    </header>
    <main id="desktop">
        <div id="desktop-canvas">
            <div id="desktop-apps" class="desktop-grid"></div>
            <div id="desktop-files" class="desktop-files-grid"></div>
        </div>
        <div id="window-layer"></div>
    </main>
    <div id="taskbar">
        <button id="start-button" title="Open Start Menu" type="button" aria-haspopup="true" aria-expanded="false">
            <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block">
                <g fill="currentColor">
                    <circle cx="5" cy="5" r="1.8"/>
                    <circle cx="12" cy="5" r="1.8"/>
                    <circle cx="19" cy="5" r="1.8"/>
                    <circle cx="5" cy="12" r="1.8"/>
                    <circle cx="12" cy="12" r="1.8"/>
                    <circle cx="19" cy="12" r="1.8"/>
                    <circle cx="5" cy="19" r="1.8"/>
                    <circle cx="12" cy="19" r="1.8"/>
                    <circle cx="19" cy="19" r="1.8"/>
                </g>
            </svg>
        </button>
        <div id="dock"></div>
        <div id="taskbar-apps"></div>
    </div>
    <section id="start-menu" aria-hidden="true" role="dialog" aria-label="Start Menu">
        <header class="start-menu-header">
            <div class="start-menu-title">
                <span class="glyph">⌘</span>
                <div class="start-menu-heading-text">
                    <strong>Applications</strong>
                    <span id="start-menu-app-count"></span>
                </div>
            </div>
            <div class="start-menu-actions">
                <label class="visually-hidden" for="start-menu-search">Search applications</label>
                <input type="search" id="start-menu-search" placeholder="Search apps or categories" autocomplete="off">
                <button type="button" id="start-menu-add-category" title="Create category">＋</button>
            </div>
        </header>
        <div class="start-menu-body">
            <div id="start-menu-categories" class="start-menu-categories" role="tree"></div>
        </div>
        <footer class="start-menu-footer">
            <button type="button" id="start-menu-manage-categories">Manage categories</button>
            <button type="button" id="start-menu-pin" aria-pressed="false" title="Pin start menu">📌 Pin</button>
        </footer>
    </section>
    <nav id="desktop-menu" class="context-menu" aria-hidden="true">
        <button data-action="new-file">New File <span>Ctrl+Shift+N</span></button>
        <button data-action="new-folder">New Folder <span>Ctrl+Shift+D</span></button>
        <button data-action="paste">Paste</button>
        <button data-action="refresh">Refresh</button>
        <div class="menu-separator"></div>
        <button data-action="stack-files">Stack Selected</button>
        <button data-action="desktop-search">Search Desktop <span>Ctrl+Space</span></button>
        <button data-action="workspace-new">New Workspace</button>
        <button data-action="workspace-switch">Switch Workspace</button>
        <button data-action="workspace-assign">Assign Selection to Workspace</button>
        <button data-action="desktop-clean">Smart Clean</button>
        <button data-action="settings">Settings</button>
    </nav>
    <nav id="icon-menu" class="context-menu" aria-hidden="true">
        <button data-action="app-open">Open</button>
        <button data-action="app-pin">Pin to Dock</button>
        <button data-action="app-unpin">Remove from Dock</button>
    </nav>
    <nav id="dock-menu" class="context-menu" aria-hidden="true"></nav>
    <nav id="start-menu-menu" class="context-menu" aria-hidden="true">
        <button data-action="start-open">Open</button>
        <button data-action="start-pin">Pin to Dock</button>
        <button data-action="start-move">Move to Category…</button>
    </nav>
    <section id="toast-container"></section>
    <section id="modal-layer" aria-hidden="true"></section>
    <input type="file" id="file-input" multiple style="display:none">
    <script>
    (() => {
        const USER_META_STORAGE_KEY = 'webos.users.meta.v1';
        let activeUserId = 'primary';

        const scopedKey = key => `${key}::${activeUserId}`;

        const scopedStorage = {
            get(key) { return localStorage.getItem(scopedKey(key)); },
            set(key, value) { localStorage.setItem(scopedKey(key), value); },
            remove(key) { localStorage.removeItem(scopedKey(key)); }
        };

        const STORAGE_KEYS = {
            FILE_SYSTEM: 'webos.fs.v1',
            SETTINGS: 'webos.settings.v1',
            TERMINAL_HISTORY: 'webos.terminal.history.v1',
            MEDIA_PLAYLIST: 'webos.media.playlist.v1',
            TASKS: 'webos.tasks.v1',
            AI_SETTINGS: 'webos.ai.settings.v1',
            NOTES: 'webos.notes.v1',
            CALENDAR_EVENTS: 'webos.calendar.events.v1',
            EMAIL_STATE: 'webos.mail.state.v1',
            PLUGINS: 'webos.plugins.v1',
            PACKAGES: 'webos.packages.v1'
        };

        const APP_CATALOG = [
            { id: 'tasks', name: 'Task Command', icon: '✅', hint: 'Plan & focus' },
            { id: 'toastsearcher', name: 'ToastSearcher', icon: '🍞', hint: 'Search & manage files' },
            { id: 'file-manager', name: 'File Manager', icon: '📂', hint: 'Grid & list file browser' },
            { id: 'calendar', name: 'Agenda Planner', icon: '📆', hint: 'Schedule events & reminders' },
            { id: 'email', name: 'Mail Center', icon: '✉️', hint: 'Read & send mail' },
            { id: 'browser', name: 'Web Navigator', icon: '🌐', hint: 'Browse the web' },
            { id: 'text-editor', name: 'Text Studio', icon: '📝', hint: 'Edit documents' },
            { id: 'notes', name: 'Sticky Notes', icon: '📔', hint: 'Capture & organize ideas' },
            { id: 'calculator', name: 'ScientiCalc', icon: '🧮', hint: 'Scientific calculator' },
            { id: 'terminal', name: 'Terminal', icon: '💻', hint: 'Command line' },
            { id: 'media-player', name: 'Media Player', icon: '🎵', hint: 'Audio & video playback' },
            { id: 'image-viewer', name: 'Image Viewer', icon: '🖼️', hint: 'View pictures' },
            { id: 'chat', name: 'Realtime Chat', icon: '💬', hint: 'Converse instantly' },
            { id: 'code-editor', name: 'Code Workshop', icon: '💡', hint: 'Hack on code' },
            { id: 'paint', name: 'Canvas Studio', icon: '🎨', hint: 'Draw & sketch' },
            { id: 'spreadsheet', name: 'Grid Sheets', icon: '📈', hint: 'Organize data' },
            { id: 'database', name: 'Data Explorer', icon: '🗄️', hint: 'Run SQL queries' },
            { id: 'cloud-sync', name: 'Cloud Bridge', icon: '☁️', hint: 'Link cloud drives' },
            { id: 'screen-recorder', name: 'Screen Recorder', icon: '📹', hint: 'Capture screen video' },
            { id: 'screenshot-tool', name: 'Snapshot Tool', icon: '📸', hint: 'Capture regions' },
            { id: 'package-manager', name: 'Package Manager', icon: '📦', hint: 'Manage components' },
            { id: 'app-store', name: 'App Plaza', icon: '🛍️', hint: 'Discover applications' },
            { id: 'plugin-manager', name: 'Plugin Manager', icon: '🧩', hint: 'Manage extensions' },
            { id: 'extension-store', name: 'Extension Store', icon: '🛒', hint: 'Discover plugins' },
            { id: 'developer-tools', name: 'Developer Tools', icon: '🛠️', hint: 'Inspect & debug WebOS' },
            { id: 'package-registry', name: 'Package Registry', icon: '🧺', hint: 'Install developer packages' },
            { id: 'api-docs', name: 'API Docs', icon: '📘', hint: 'Developer reference' },
            { id: 'sdk-workbench', name: 'SDK Workbench', icon: '🧰', hint: 'Build WebOS integrations' },
            { id: 'tetris', name: 'Tetris Classic', icon: '🧱', hint: 'Falling-block puzzle' },
            { id: 'snake', name: 'Neon Snake', icon: '🐍', hint: 'Retro grid crawler' },
            { id: 'pong', name: 'Quantum Pong', icon: '🏓', hint: 'Reflex paddle duel' },
            { id: 'breakout', name: 'Neon Breakout', icon: '🧱', hint: 'Brick-smashing arcade' },
            { id: 'minesweeper', name: 'Minesweeper Pro', icon: '🧨', hint: 'Logic minefield' },
            { id: 'solitaire', name: 'Solitaire Desk', icon: '🃏', hint: 'Classic patience' },
            { id: 'flappy-bird', name: 'Flappy Flight', icon: '🐦', hint: 'Endless flyer' },
            { id: 'game-2048', name: '2048 Fusion', icon: '🔢', hint: 'Number merging puzzle' },
            { id: 'pac-man', name: 'Pac Maze', icon: '😋', hint: 'Maze chase classic' },
            { id: 'space-invaders', name: 'Space Invaders', icon: '👾', hint: 'Shoot alien waves' },
            { id: 'galaga', name: 'Galaga Squadron', icon: '🚀', hint: 'Vertical shooter' },
            { id: 'asteroids', name: 'Asteroid Belt', icon: '☄️', hint: 'Retro space physics' },
            { id: 'frogger', name: 'Pixel Frogger', icon: '🐸', hint: 'Cross the lanes' },
            { id: 'pinball', name: 'Neon Pinball', icon: '🎰', hint: 'Arcade table' },
            { id: 'settings', name: 'System Settings', icon: '⚙️', hint: 'Configure WebOS' },
            { id: 'assistant', name: 'AI Assistant', icon: '🤖', hint: 'Chat & automate' },
            { id: 'system-monitor', name: 'System Monitor', icon: '📊', hint: 'Runtime diagnostics' }
        ];

        const GAME_APP_IDS = [
            'tetris',
            'snake',
            'pong',
            'breakout',
            'minesweeper',
            'solitaire',
            'flappy-bird',
            'game-2048',
            'pac-man',
            'space-invaders',
            'galaga',
            'asteroids',
            'frogger',
            'pinball'
        ];

        const WEB_PORTAL_APPS = [
            { id: 'netflix', name: 'Netflix', icon: '🎬', hint: 'Stream movies & TV', url: 'https://www.netflix.com/browse', description: 'Stream Netflix originals, films, and series. A Netflix subscription and regional availability are required.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'youtube', name: 'YouTube', icon: '▶️', hint: 'Watch online video', url: 'https://www.youtube.com/', description: 'Browse channels, watch live streams, and discover trending videos on YouTube.', categories: ['Streaming & Media'] },
            { id: 'primevideo', name: 'Amazon Prime Video', icon: '📺', hint: 'Prime Video library', url: 'https://www.primevideo.com/', description: 'Watch Amazon Originals along with licensed films and series. Requires an Amazon Prime Video membership.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'hulu', name: 'Hulu', icon: '📼', hint: 'Hulu streaming', url: 'https://www.hulu.com/', description: 'Catch next-day TV, movies, and Hulu originals. Service available primarily within the United States.', categories: ['Streaming & Media'], availability: 'Region: United States' },
            { id: 'disneyplus', name: 'Disney+', icon: '🪄', hint: 'Disney, Marvel & more', url: 'https://www.disneyplus.com/', description: 'Stream Disney, Pixar, Marvel, Star Wars, and National Geographic stories in one place.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'hbomax', name: 'Max', icon: '🍿', hint: 'HBO & Warner content', url: 'https://www.max.com/', description: 'Enjoy HBO series, Warner Bros. films, and Max Originals. Availability varies by region.', categories: ['Streaming & Media'], availability: 'Subscription required' },
            { id: 'spotify', name: 'Spotify', icon: '🎧', hint: 'Music & podcasts', url: 'https://open.spotify.com/', description: 'Listen to millions of songs, curated playlists, and podcasts on Spotify.', categories: ['Music & Audio'], availability: 'Login required' },
            { id: 'bbciplayer', name: 'BBC iPlayer', icon: '📻', hint: 'BBC live & on-demand', url: 'https://www.bbc.co.uk/iplayer', description: 'Stream BBC TV channels, live news, and on-demand programmes. Access limited to UK audiences.', categories: ['News & Live TV'], availability: 'Region: United Kingdom' },
            { id: 'cnn', name: 'CNN', icon: '📰', hint: 'Global news updates', url: 'https://www.cnn.com/', description: 'Stay informed with breaking news, live video, and world coverage from CNN.', categories: ['News & Live TV'] },
            { id: 'accuweather', name: 'AccuWeather', icon: '🌤️', hint: 'Forecasts & radar', url: 'https://www.accuweather.com/', description: 'Track hyperlocal forecasts, severe weather alerts, and radar maps.', categories: ['Weather', 'Utilities'] },
            { id: 'facebookwatch', name: 'Facebook Watch', icon: '📱', hint: 'Shows & live streams', url: 'https://www.facebook.com/watch', description: 'Discover trending videos, live streams, and Facebook Originals.', categories: ['Social & Communication', 'Streaming & Media'], availability: 'Login required' },
            { id: 'zoom', name: 'Zoom Meetings', icon: '🎥', hint: 'Video conferencing', url: 'https://zoom.us/wc/join', description: 'Join or host video meetings directly in the browser with Zoom Web Client.', categories: ['Social & Communication', 'Productivity'] },
            { id: 'twitch', name: 'Twitch', icon: '🕹️', hint: 'Live gaming streams', url: 'https://www.twitch.tv/', description: 'Watch live gaming broadcasts, esports events, and creative streams.', categories: ['Gaming & Entertainment'] },
            { id: 'plex', name: 'Plex', icon: '📦', hint: 'Personal media hub', url: 'https://app.plex.tv/desktop', description: 'Stream your personal media library or ad-supported content through Plex.', categories: ['Streaming & Media', 'Personal Media'], availability: 'Login required' },
            { id: 'kodi', name: 'Kodi Web', icon: '🧩', hint: 'Kodi remote interface', url: 'http://kodi.tv/', description: 'Connect to the Kodi web interface for browsing and controlling a configured Kodi media center.', categories: ['Streaming & Media', 'Personal Media'], availability: 'Requires existing Kodi setup' },
            { id: 'google', name: 'Google Search', icon: '🔍', hint: 'Search the web', url: 'https://www.google.com/', description: 'Quickly search the web with Google Search.', categories: ['Utilities', 'Productivity'] },
            { id: 'gmail', name: 'Gmail', icon: '✉️', hint: 'Google email', url: 'https://mail.google.com/', description: 'Read and compose email using the Gmail web client.', categories: ['Productivity', 'Email'], availability: 'Login required' },
            { id: 'outlookmail', name: 'Outlook Mail', icon: '📬', hint: 'Microsoft email', url: 'https://outlook.office.com/mail/', description: 'Access Outlook, Microsoft 365, or Hotmail inboxes in the browser.', categories: ['Productivity', 'Email'], availability: 'Login required' },
            { id: 'googledrive', name: 'Google Drive', icon: '📁', hint: 'Google cloud files', url: 'https://drive.google.com/drive/my-drive', description: 'Manage documents, spreadsheets, and cloud storage with Google Drive.', categories: ['Productivity', 'Cloud Storage'], availability: 'Login required' },
            { id: 'dropbox', name: 'Dropbox', icon: '🗄️', hint: 'Dropbox storage', url: 'https://www.dropbox.com/home', description: 'Browse and share files stored in Dropbox cloud storage.', categories: ['Productivity', 'Cloud Storage'], availability: 'Login required' }
        ];

        WEB_PORTAL_APPS.forEach(app => APP_CATALOG.push({ id: app.id, name: app.name, icon: app.icon, hint: app.hint }));

        const APP_CATEGORY_STORAGE_KEY = 'webos.appCategories.v1';
        const DEFAULT_CATEGORY_DEFS = [
            { id: 'productivity', name: 'Productivity', icon: '📂', accent: '#7b8bff', custom: false },
            { id: 'productivity-collab', parentId: 'productivity', name: 'Collaboration', icon: '🤝', accent: '#9b7bff', type: 'smart', filters: { keywords: ['meeting', 'mail', 'drive', 'cloud', 'team'] }, custom: false },
            { id: 'media', name: 'Media & Entertainment', icon: '🎬', accent: '#ff8f70', custom: false },
            { id: 'media-streaming', parentId: 'media', name: 'Streaming Services', icon: '📺', accent: '#ffb347', type: 'smart', filters: { keywords: ['stream', 'video', 'tv', 'movie'] }, custom: false },
            { id: 'media-music', parentId: 'media', name: 'Music & Audio', icon: '🎧', accent: '#6ad2ff', type: 'smart', filters: { keywords: ['music', 'audio', 'podcast'] }, custom: false },
            { id: 'games', name: 'Games & Fun', icon: '🕹️', accent: '#ff7096', custom: false },
            { id: 'news', name: 'News & Weather', icon: '📰', accent: '#6ddccf', custom: false },
            { id: 'utilities', name: 'Utilities', icon: '🧰', accent: '#f6c667', custom: false },
            { id: 'utilities-web', parentId: 'utilities', name: 'Web Tools', icon: '🧭', accent: '#57c7ff', type: 'smart', filters: { keywords: ['web', 'search', 'browser'] }, custom: false },
            { id: 'system', name: 'System', icon: '🛠️', accent: '#6f7cff', custom: false },
            { id: 'development', name: 'Development', icon: '💻', accent: '#4f8dff', custom: false },
            { id: 'uncategorized', name: 'Uncategorized', icon: '🗂️', accent: '#a0aec0', custom: false }
        ];

        const DEFAULT_APP_CATEGORY_ASSIGNMENTS = {
            tasks: 'productivity',
            toastsearcher: 'system',
            'file-manager': 'utilities',
            calendar: 'productivity',
            email: 'productivity',
            chat: 'productivity',
            'code-editor': 'productivity',
            paint: 'media',
            spreadsheet: 'productivity',
            database: 'productivity',
            'cloud-sync': 'utilities',
            'screen-recorder': 'media',
            'screenshot-tool': 'utilities',
            'package-manager': 'system',
            'app-store': 'system',
            'plugin-manager': 'development',
            'extension-store': 'development',
            'developer-tools': 'development',
            'package-registry': 'development',
            'api-docs': 'development',
            'sdk-workbench': 'development',
            browser: 'utilities-web',
            'text-editor': 'productivity',
            notes: 'productivity',
            calculator: 'utilities',
            terminal: 'system',
            'media-player': 'media',
            'image-viewer': 'media',
            tetris: 'games',
            snake: 'games',
            pong: 'games',
            breakout: 'games',
            minesweeper: 'games',
            solitaire: 'games',
            'flappy-bird': 'games',
            'game-2048': 'games',
            'pac-man': 'games',
            'space-invaders': 'games',
            galaga: 'games',
            asteroids: 'games',
            frogger: 'games',
            pinball: 'games',
            settings: 'system',
            assistant: 'system',
            'system-monitor': 'system',
            netflix: 'media-streaming',
            youtube: 'media-streaming',
            primevideo: 'media-streaming',
            hulu: 'media-streaming',
            disneyplus: 'media-streaming',
            hbomax: 'media-streaming',
            spotify: 'media-music',
            plex: 'media-streaming',
            kodi: 'media-streaming',
            facebookwatch: 'media-streaming',
            zoom: 'productivity-collab',
            twitch: 'media-streaming',
            google: 'utilities-web',
            gmail: 'productivity-collab',
            outlookmail: 'productivity-collab',
            googledrive: 'productivity-collab',
            dropbox: 'productivity-collab',
            cnn: 'news',
            bbciplayer: 'news',
            accuweather: 'news'
        };

        const CATEGORY_KEYWORD_RULES = [
            { category: 'productivity-collab', keywords: ['email', 'mail', 'meet', 'calendar', 'drive', 'doc', 'team', 'collab', 'office', 'zoom'] },
            { category: 'productivity', keywords: ['note', 'task', 'todo', 'plan', 'write', 'editor', 'text'] },
            { category: 'media-streaming', keywords: ['stream', 'movie', 'tv', 'video', 'show', 'series', 'watch'] },
            { category: 'media-music', keywords: ['music', 'audio', 'podcast', 'playlist', 'song'] },
            { category: 'games', keywords: ['game', 'play', 'fun', 'arcade'] },
            { category: 'news', keywords: ['news', 'weather', 'forecast', 'headline'] },
            { category: 'utilities-web', keywords: ['web', 'browser', 'search', 'drive', 'cloud'] },
            { category: 'system', keywords: ['settings', 'system', 'config', 'terminal'] },
            { category: 'development', keywords: ['developer', 'plugin', 'extension', 'debug', 'package', 'api', 'sdk'] }
        ];

        const CATEGORY_ACCENTS = ['#7b8bff', '#ff8f70', '#6ad2ff', '#6ddccf', '#ff7096', '#f6c667', '#9b7bff', '#57c7ff'];

        const reconcileOrder = (existing = [], required = []) => {
            const reqSet = new Set(required);
            const filtered = Array.isArray(existing) ? existing.filter(id => reqSet.has(id)) : [];
            required.forEach(id => {
                if (!filtered.includes(id)) filtered.push(id);
            });
            return filtered;
        };

        const DOCK_QUICK_ACTIONS = {
            'text-editor': [
                { label: 'New Document', handler: ctx => ctx.appManager.open('text-editor') },
                { label: 'Open Notes Folder', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Documents/notes' }) }
            ],
            browser: [
                { label: 'New Tab', handler: ctx => ctx.appManager.open('browser') },
                { label: 'Cascade Projects', handler: ctx => ctx.appManager.open('browser', { url: 'https://cascade.cool' }) },
                { label: 'MDN Docs', handler: ctx => ctx.appManager.open('browser', { url: 'https://developer.mozilla.org' }) }
            ],
            tasks: [
                { label: 'Focus Session', handler: ctx => ctx.appManager.open('tasks', { focus: true }) },
                { label: 'Today View', handler: ctx => ctx.appManager.open('tasks', { focus: false }) }
            ],
            'media-player': [
                { label: 'Open Playlist', handler: ctx => ctx.appManager.open('media-player') }
            ],
            notes: [
                { label: 'New Note', handler: ctx => ctx.appManager.open('notes', { create: true }) },
                { label: 'Pinned Notes', handler: ctx => ctx.appManager.open('notes', { filter: 'pinned' }) }
            ],
            'system-monitor': [
                { label: 'Open Dashboard', handler: ctx => ctx.appManager.open('system-monitor') },
                { label: 'Copy Snapshot', handler: ctx => ctx.appManager.open('system-monitor', { snapshot: true }) }
            ]
        };

        const DOCK_JUMP_LISTS = {
            browser: [
                { label: 'OpenAI', handler: ctx => ctx.appManager.open('browser', { url: 'https://openai.com' }) },
                { label: 'YouTube', handler: ctx => ctx.appManager.open('browser', { url: 'https://www.youtube.com/' }) },
                { label: 'Netflix', handler: ctx => ctx.appManager.open('browser', { url: 'https://www.netflix.com/browse' }) }
            ],
            'text-editor': [
                { label: 'Welcome File', handler: ctx => ctx.appManager.open('text-editor', { path: '/Documents/welcome.txt' }) }
            ],
            toastsearcher: [
                { label: 'Documents Folder', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Documents' }) },
                { label: 'Downloads', handler: ctx => ctx.appManager.open('toastsearcher', { path: '/Downloads' }) }
            ],
            notes: [
                { label: 'Last Updated', handler: ctx => ctx.appManager.open('notes', { openLast: true }) }
            ],
            'system-monitor': [
                { label: 'Resource Snapshot', handler: ctx => ctx.appManager.open('system-monitor', { snapshot: true }) }
            ]
        };

        const MIME_TYPES = {
            '.txt': 'text/plain', '.md': 'text/markdown', '.json': 'application/json', '.js': 'application/javascript',
            '.ts': 'application/typescript', '.html': 'text/html', '.css': 'text/css', '.csv': 'text/csv', '.xml': 'application/xml',
            '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.png': 'image/png', '.gif': 'image/gif', '.webp': 'image/webp', '.svg': 'image/svg+xml',
            '.mp3': 'audio/mpeg', '.wav': 'audio/wav', '.ogg': 'audio/ogg', '.mp4': 'video/mp4', '.webm': 'video/webm', '.mov': 'video/quicktime'
        };

        const APP_ASSOCIATIONS = {
            text: ['.txt', '.md', '.json', '.js', '.ts', '.html', '.css', '.csv', '.xml'],
            image: ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'],
            audio: ['.mp3', '.wav', '.ogg'],
            video: ['.mp4', '.webm', '.mov']
        };

        const utils = {
            nowISO: () => new Date().toISOString(),
            ext(name) { const idx = name.lastIndexOf('.'); return idx >= 0 ? name.slice(idx).toLowerCase() : ''; },
            dirname(path) {
                if (path === '/' || !path) return '/';
                const parts = path.split('/').filter(Boolean);
                parts.pop();
                return '/' + parts.join('/');
            },
            join(...parts) {
                const path = parts.join('/').replace(/\\+/g, '/');
                if (!path.startsWith('/')) return utils.normalize('/' + path);
                return utils.normalize(path);
            },
            normalize(path) {
                if (!path) return '/';
                const segments = [];
                path.split('/').forEach(segment => {
                    if (!segment || segment === '.') return;
                    if (segment === '..') segments.pop(); else segments.push(segment);
                });
                return segments.length ? '/' + segments.join('/') : '/';
            },
            uuid() {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
                return `id-${Math.random().toString(16).slice(2)}${Date.now().toString(16)}`;
            },
            bytesToBase64(bytes) {
                let binary = '';
                const len = bytes.length;
                for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
                return btoa(binary);
            },
            base64ToBytes(base64) {
                const binary = atob(base64);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
                return bytes;
            },
            textToBase64(text) {
                const bytes = new TextEncoder().encode(text);
                return utils.bytesToBase64(bytes);
            },
            base64ToText(base64, encoding = 'utf-8') {
                return new TextDecoder(encoding).decode(utils.base64ToBytes(base64));
            },
            mimeFromName(name) { return MIME_TYPES[utils.ext(name)] || 'application/octet-stream'; },
            formatBytes(bytes) {
                if (!bytes) return '0 B';
                const units = ['B', 'KB', 'MB', 'GB'];
                const index = Math.floor(Math.log(bytes) / Math.log(1024));
                return `${(bytes / 1024 ** index).toFixed(index ? 1 : 0)} ${units[index]}`;
            },
            debounce(fn, wait = 200) {
                let timer;
                let lastArgs;
                const debounced = (...args) => {
                    lastArgs = args;
                    clearTimeout(timer);
                    timer = setTimeout(() => {
                        timer = null;
                        fn(...lastArgs);
                    }, wait);
                };
                debounced.cancel = () => {
                    clearTimeout(timer);
                    timer = null;
                };
                debounced.flush = () => {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                        fn(...lastArgs);
                    }
                };
                return debounced;
            },
            throttle(fn, wait = 100) {
                let last = 0;
                return (...args) => {
                    const now = Date.now();
                    if (now - last >= wait) {
                        last = now;
                        fn(...args);
                    }
                };
            },
            createEl(tag, className, props = {}) {
                const el = document.createElement(tag);
                if (className) el.className = className;
                Object.entries(props).forEach(([key, value]) => {
                    if (key === 'text') el.textContent = value;
                    else if (key === 'html') el.innerHTML = value;
                    else el.setAttribute(key, value);
                });
                return el;
            },
            humanDate(iso) { return new Date(iso).toLocaleString(); },
            relativeTime(value) {
                if (!value) return '';
                const date = value instanceof Date ? value : new Date(value);
                if (Number.isNaN(date.getTime())) return '';
                const diff = date.getTime() - Date.now();
                const absolute = Math.abs(diff);
                const units = [
                    { unit: 'second', ms: 1000 },
                    { unit: 'minute', ms: 60_000 },
                    { unit: 'hour', ms: 3_600_000 },
                    { unit: 'day', ms: 86_400_000 },
                    { unit: 'week', ms: 604_800_000 },
                    { unit: 'month', ms: 2_629_800_000 },
                    { unit: 'year', ms: 31_557_600_000 }
                ];
                const entry = units.find((item, index) => absolute < (index < units.length - 1 ? units[index + 1].ms : Infinity)) || units[units.length - 1];
                const valueRounded = Math.round(diff / entry.ms);
                try {
                    const formatter = new Intl.RelativeTimeFormat(undefined, { numeric: 'auto' });
                    return formatter.format(valueRounded, entry.unit);
                } catch (error) {
                    const absValue = Math.abs(valueRounded);
                    const suffix = valueRounded > 0 ? 'from now' : 'ago';
                    return `${absValue} ${entry.unit}${absValue === 1 ? '' : 's'} ${suffix}`;
                }
            },
            clamp(value, min, max) { return Math.min(Math.max(value, min), max); },
            nextColor(color, amount = 0.2) {
                const num = parseInt(color.replace('#', ''), 16);
                const r = Math.min(255, (num >> 16) + Math.round(255 * amount));
                const g = Math.min(255, ((num >> 8) & 0xff) + Math.round(255 * amount));
                const b = Math.min(255, (num & 0xff) + Math.round(255 * amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }
        };

        class EventEmitter {
            constructor() { this.listeners = new Map(); }
            on(event, handler) {
                if (!this.listeners.has(event)) this.listeners.set(event, new Set());
                this.listeners.get(event).add(handler);
                return () => this.off(event, handler);
            }
            off(event, handler) {
                const set = this.listeners.get(event);
                if (set) set.delete(handler);
            }
            emit(event, payload) {
                const set = this.listeners.get(event);
                if (set) set.forEach(handler => handler(payload));
            }
        }
        class FileSystem extends EventEmitter {
            constructor() {
                super();
                this.storageKey = STORAGE_KEYS.FILE_SYSTEM;
                this.root = null;
                this.load();
            }

            load() {
                try {
                    const raw = scopedStorage.get(this.storageKey);
                    if (raw) {
                        this.root = JSON.parse(raw);
                    } else {
                        this.root = this.createDefaultStructure();
                        this.persist();
                    }
                } catch (error) {
                    console.error('Failed to load file system', error);
                    this.root = this.createDefaultStructure();
                    this.persist();
                }
            }

            persist() {
                scopedStorage.set(this.storageKey, JSON.stringify(this.root));
            }

            createDefaultStructure() {
                const now = utils.nowISO();
                const file = (name, content, mime = 'text/plain') => ({
                    type: 'file',
                    name,
                    mime,
                    encoding: 'utf-8',
                    data: utils.textToBase64(content),
                    size: content.length,
                    createdAt: now,
                    updatedAt: now,
                    metadata: {}
                });
                return {
                    type: 'directory',
                    name: '',
                    createdAt: now,
                    updatedAt: now,
                    children: {
                        Desktop: { type: 'directory', name: 'Desktop', createdAt: now, updatedAt: now, children: {} },
                        Documents: {
                            type: 'directory',
                            name: 'Documents',
                            createdAt: now,
                            updatedAt: now,
                            children: {
                                'welcome.txt': file('welcome.txt', 'Welcome to WebOS!\n\nOpen ToastSearcher to browse the virtual file system. Double click files to open them. Drag files on the desktop to upload. Enjoy!'),
                                notes: { type: 'directory', name: 'notes', createdAt: now, updatedAt: now, children: {} }
                            }
                        },
                        Downloads: { type: 'directory', name: 'Downloads', createdAt: now, updatedAt: now, children: {} },
                        Pictures: { type: 'directory', name: 'Pictures', createdAt: now, updatedAt: now, children: {} },
                        Music: { type: 'directory', name: 'Music', createdAt: now, updatedAt: now, children: {} },
                        System: {
                            type: 'directory',
                            name: 'System',
                            createdAt: now,
                            updatedAt: now,
                            children: {
                                'config.json': file('config.json', JSON.stringify({
                                    theme: 'auto',
                                    accent: '#7b8bff',
                                    fontScale: 1,
                                    notifications: true,
                                    autoSave: true,
                                    showSeconds: false,
                                    wallpaper: 'aurora',
                                    taskbarPosition: 'bottom',
                                    desktopDensity: 'comfortable',
                                    showParticles: true,
                                    useBrowserProxy: true,
                                    dockAutoHide: false,
                                    dockSmartSizing: true,
                                    dockPredictivePinning: true,
                                    dockGroupedView: false
                                }, null, 2), 'application/json'),
                                'bookmarks.json': file('bookmarks.json', JSON.stringify([
                                    { title: 'Cascade Projects', url: 'https://cascade.cool' },
                                    { title: 'MDN Web Docs', url: 'https://developer.mozilla.org' },
                                    { title: 'OpenAI', url: 'https://openai.com' }
                                ], null, 2), 'application/json')
                            }
                        }
                    }
                };
            }

            resolve(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') return { parent: null, entry: this.root, name: '' };
                const segments = normalized.split('/').filter(Boolean);
                let current = this.root;
                let parent = null;
                for (const segment of segments) {
                    if (!current || current.type !== 'directory') return { parent, entry: null, name: segment };
                    parent = current;
                    current = current.children[segment];
                    if (!current) return { parent, entry: null, name: segment };
                }
                return { parent, entry: current, name: segments[segments.length - 1] };
            }

            ensureDirectory(path) {
                const { entry } = this.resolve(path);
                if (!entry) throw new Error(`Path not found: ${path}`);
                if (entry.type !== 'directory') throw new Error(`Not a directory: ${path}`);
                return entry;
            }

            exists(path) {
                return Boolean(this.resolve(path).entry);
            }

            listDirectory(path) {
                const dir = this.ensureDirectory(path);
                return Object.values(dir.children || {})
                    .map(entry => ({
                        name: entry.name,
                        type: entry.type,
                        mime: entry.mime,
                        encoding: entry.encoding,
                        size: entry.size || 0,
                        createdAt: entry.createdAt,
                        updatedAt: entry.updatedAt,
                        metadata: entry.metadata || {},
                        path: utils.join(path, entry.name)
                    }))
                    .sort((a, b) => {
                        if (a.type === b.type) return a.name.localeCompare(b.name);
                        return a.type === 'directory' ? -1 : 1;
                    });
            }

            createDirectory(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') return;
                const { parent, entry, name } = this.resolve(normalized);
                if (entry) throw new Error('Directory already exists');
                if (!parent || parent.type !== 'directory') throw new Error('Parent directory not found');
                parent.children[name] = {
                    type: 'directory',
                    name,
                    createdAt: utils.nowISO(),
                    updatedAt: utils.nowISO(),
                    children: {}
                };
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'createDirectory', path: normalized });
            }

            createFile(path, content = '', options = {}) {
                const normalized = utils.normalize(path);
                const dirPath = utils.dirname(normalized);
                const directory = this.ensureDirectory(dirPath);
                const name = normalized.split('/').pop();
                if (directory.children[name]) throw new Error('File already exists');
                const mime = options.mime || utils.mimeFromName(name);
                let data = '';
                if (content instanceof Uint8Array) data = utils.bytesToBase64(content);
                else if (typeof content === 'string') data = utils.textToBase64(content);
                else if (content === null) data = '';
                else throw new Error('Unsupported file content');
                directory.children[name] = {
                    type: 'file',
                    name,
                    mime,
                    encoding: options.encoding || 'utf-8',
                    data,
                    size: utils.base64ToBytes(data).length,
                    createdAt: utils.nowISO(),
                    updatedAt: utils.nowISO(),
                    metadata: options.metadata || {}
                };
                directory.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'createFile', path: normalized });
            }

            readFile(path, { encoding = 'utf-8', as = 'text' } = {}) {
                const { entry } = this.resolve(path);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                const bytes = utils.base64ToBytes(entry.data || '');
                if (as === 'bytes') return bytes;
                return new TextDecoder(encoding || entry.encoding || 'utf-8').decode(bytes);
            }

            readFileMeta(path) {
                const { entry } = this.resolve(path);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                return entry;
            }

            writeFile(path, content, options = {}) {
                const normalized = utils.normalize(path);
                const { entry } = this.resolve(normalized);
                if (!entry || entry.type !== 'file') throw new Error('File not found');
                let data;
                if (content instanceof Uint8Array) data = utils.bytesToBase64(content);
                else if (typeof content === 'string') data = utils.textToBase64(content);
                else throw new Error('Unsupported content');
                entry.data = data;
                entry.mime = options.mime || entry.mime;
                entry.encoding = options.encoding || entry.encoding || 'utf-8';
                entry.updatedAt = utils.nowISO();
                entry.size = utils.base64ToBytes(data).length;
                this.persist();
                this.emit('change', { type: 'writeFile', path: normalized });
            }

            delete(path) {
                const normalized = utils.normalize(path);
                if (normalized === '/') throw new Error('Cannot delete root directory');
                const { parent, entry, name } = this.resolve(normalized);
                if (!entry) throw new Error('Path not found');
                delete parent.children[name];
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'delete', path: normalized });
            }

            rename(path, newName) {
                const normalized = utils.normalize(path);
                const { parent, entry, name } = this.resolve(normalized);
                if (!entry || !parent) throw new Error('Path not found');
                if (parent.children[newName]) throw new Error('Destination exists');
                delete parent.children[name];
                entry.name = newName;
                parent.children[newName] = entry;
                parent.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'rename', path: normalized, newPath: utils.join(utils.dirname(normalized), newName) });
            }

            copy(sourcePath, targetDirPath) {
                const { entry } = this.resolve(sourcePath);
                if (!entry) throw new Error('Source not found');
                const targetDir = this.ensureDirectory(targetDirPath);
                if (targetDir.children[entry.name]) throw new Error('Target already exists');
                const cloneEntry = JSON.parse(JSON.stringify(entry));
                cloneEntry.createdAt = utils.nowISO();
                cloneEntry.updatedAt = utils.nowISO();
                targetDir.children[entry.name] = cloneEntry;
                targetDir.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'copy', path: sourcePath, target: utils.join(targetDirPath, entry.name) });
            }

            move(sourcePath, targetDirPath) {
                const normalizedSource = utils.normalize(sourcePath);
                const normalizedTarget = utils.normalize(targetDirPath);
                const { parent, entry, name } = this.resolve(normalizedSource);
                if (!entry || !parent) throw new Error('Source not found');
                const targetDir = this.ensureDirectory(normalizedTarget);
                if (targetDir.children[entry.name]) throw new Error('Target already exists');
                targetDir.children[entry.name] = entry;
                delete parent.children[name];
                parent.updatedAt = utils.nowISO();
                targetDir.updatedAt = utils.nowISO();
                this.persist();
                this.emit('change', { type: 'move', path: normalizedSource, target: utils.join(normalizedTarget, entry.name) });
            }

            search(term) {
                const results = [];
                const lower = term.toLowerCase();
                const traverse = (entry, currentPath) => {
                    if (entry !== this.root && entry.name.toLowerCase().includes(lower)) {
                        results.push({ name: entry.name, type: entry.type, path: currentPath, updatedAt: entry.updatedAt });
                    }
                    if (entry.type === 'directory') {
                        Object.entries(entry.children).forEach(([name, child]) => {
                            traverse(child, utils.join(currentPath, name));
                        });
                    }
                };
                traverse(this.root, '/');
                return results.sort((a, b) => a.name.localeCompare(b.name));
            }
        }
        class SettingsManager extends EventEmitter {
            constructor() {
                super();
            this.storageKey = STORAGE_KEYS.SETTINGS;
            this.defaults = {
                theme: 'auto',
                accent: '#7b8bff',
                fontScale: 1,
                notifications: true,
                autoSave: true,
                showSeconds: false,
                wallpaper: 'aurora',
                taskbarPosition: 'bottom',
                desktopDensity: 'comfortable',
                showParticles: true,
                useBrowserProxy: true,
                wallpaperCustom: null,
                wallpaperBlur: 6,
                wallpaperBrightness: 1,
                wallpaperOpacity: 0.95,
                dockAutoHide: false,
                dockSmartSizing: true,
                dockPredictivePinning: true,
                dockGroupedView: false,
                contrast: 'standard',
                transparency: true,
                animations: true,
                gpuAcceleration: true,
                allowP2P: false,
                privacy: {
                    camera: false,
                    microphone: false,
                    filesystem: true,
                    network: true
                },
                permissions: {}
            };
            this.state = this.load();
            this.particlesController = null;
            this.dockController = null;
            this.permissionManager = null;
            this.applyTheme();
            this.applyAccent();
            this.applyFontScale();
            this.applyWallpaper();
            this.applyWallpaperEffects();
            this.applyTaskbarPosition();
            this.applyDesktopDensity();
            this.applyParticles();
            this.applyDockPreferences();
            this.applyContrast();
            this.applyTransparency();
            this.applyAnimations();
            this.applyGpuAcceleration();
            this.applyP2P();
            this.applyPrivacy();
        }

            load() {
                try {
                    const raw = scopedStorage.get(this.storageKey);
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        const merged = { ...this.defaults, ...parsed };
                        merged.privacy = { ...this.defaults.privacy, ...(parsed?.privacy || {}) };
                        merged.permissions = parsed?.permissions && typeof parsed.permissions === 'object'
                            ? { ...parsed.permissions }
                            : {};
                        return merged;
                    }
                } catch (error) {
                    console.warn('Failed to load settings', error);
                }
                return { ...this.defaults, privacy: { ...this.defaults.privacy }, permissions: {} };
            }

            save() {
                scopedStorage.set(this.storageKey, JSON.stringify(this.state));
                this.emit('change', { ...this.state });
            }

            update(partial) {
                Object.assign(this.state, partial);
                this.save();
                if ('theme' in partial) this.applyTheme();
                if ('accent' in partial) this.applyAccent();
                if ('fontScale' in partial) this.applyFontScale();
                if ('wallpaper' in partial || 'wallpaperCustom' in partial) this.applyWallpaper();
                if ('wallpaperBlur' in partial || 'wallpaperBrightness' in partial || 'wallpaperOpacity' in partial) this.applyWallpaperEffects();
                if ('taskbarPosition' in partial) this.applyTaskbarPosition();
                if ('desktopDensity' in partial) this.applyDesktopDensity();
                if ('showParticles' in partial) this.applyParticles();
                if ('dockAutoHide' in partial || 'dockSmartSizing' in partial || 'dockPredictivePinning' in partial || 'dockGroupedView' in partial) this.applyDockPreferences();
                if ('contrast' in partial) this.applyContrast();
                if ('transparency' in partial) this.applyTransparency();
                if ('animations' in partial) this.applyAnimations();
                if ('gpuAcceleration' in partial) this.applyGpuAcceleration();
                if ('allowP2P' in partial) this.applyP2P();
                if ('privacy' in partial) this.applyPrivacy();
                if ('permissions' in partial) this.permissionManager?.syncFromSettings(this.state.permissions || {});
            }

            applyTheme() {
                const theme = this.state.theme;
                if (theme === 'auto') {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.documentElement.dataset.theme = prefersDark ? 'dark' : 'light';
                } else {
                    document.documentElement.dataset.theme = theme;
                }
            }

            applyAccent() {
                const color = this.state.accent;
                document.documentElement.style.setProperty('--accent', color);
                document.documentElement.style.setProperty('--accent-strong', color);
                document.documentElement.style.setProperty('--accent-gradient', `linear-gradient(135deg, ${color} 0%, ${utils.nextColor(color)} 100%)`);
            }

            applyFontScale() {
                document.documentElement.style.setProperty('--base-font-size', `${14 * this.state.fontScale}px`);
            }

            applyWallpaper() {
                const wallpaper = this.state.wallpaper;
                if (wallpaper === 'custom' && this.state.wallpaperCustom) {
                    document.body.dataset.wallpaper = 'custom';
                    document.documentElement.style.setProperty('--wallpaper-image', `url('${this.state.wallpaperCustom}')`);
                } else {
                    document.documentElement.style.removeProperty('--wallpaper-image');
                    document.body.dataset.wallpaper = wallpaper;
                }
                this.particlesController?.setMode?.(wallpaper);
            }

            applyWallpaperEffects() {
                const blurValue = Number(this.state.wallpaperBlur ?? 0);
                const brightnessValue = Number(this.state.wallpaperBrightness ?? 1);
                const opacityValue = Number(this.state.wallpaperOpacity ?? 1);
                document.documentElement.style.setProperty('--wallpaper-blur', `${blurValue}px`);
                document.documentElement.style.setProperty('--wallpaper-brightness', String(brightnessValue));
                document.documentElement.style.setProperty('--wallpaper-opacity', String(opacityValue));
            }

            applyTaskbarPosition() {
                document.body.dataset.taskbar = this.state.taskbarPosition;
            }

            applyDesktopDensity() {
                const density = this.state.desktopDensity;
                const presets = {
                    compact: { icon: 50, gap: 10 },
                    comfortable: { icon: 62, gap: 16 },
                    spacious: { icon: 74, gap: 20 }
                };
                const chosen = presets[density] || presets.comfortable;
                document.documentElement.style.setProperty('--desktop-icon-size', `${chosen.icon}px`);
                document.documentElement.style.setProperty('--desktop-stack-gap', `${chosen.gap}px`);
                document.body.dataset.desktopDensity = density;
            }

            applyParticles() {
                document.body.dataset.particles = this.state.showParticles ? 'on' : 'off';
                this.particlesController?.setEnabled(this.state.showParticles);
            }

            setBackgroundController(controller) {
                this.particlesController = controller;
                this.particlesController?.setMode?.(this.state.wallpaper);
                this.applyParticles();
                this.applyWallpaperEffects();
            }

            applyDockPreferences() {
                document.body.dataset.dockAutohide = this.state.dockAutoHide ? 'on' : 'off';
                document.body.dataset.dockGrouped = this.state.dockGroupedView ? 'on' : 'off';
                document.body.dataset.dockSizing = this.state.dockSmartSizing ? 'smart' : 'static';
                this.dockController?.applyPreferences?.(this.state);
            }

            setDockController(controller) {
                this.dockController = controller;
                this.applyDockPreferences();
            }

            applyContrast() {
                document.body.dataset.contrast = this.state.contrast === 'high' ? 'high' : 'standard';
            }

            applyTransparency() {
                document.body.dataset.transparency = this.state.transparency ? 'on' : 'off';
            }

            applyAnimations() {
                document.body.dataset.animations = this.state.animations ? 'on' : 'off';
                const speed = this.state.animations ? 1 : 0.6;
                document.documentElement.style.setProperty('--animation-speed', String(speed));
            }

            applyGpuAcceleration() {
                document.body.dataset.gpu = this.state.gpuAcceleration ? 'on' : 'off';
                if (this.state.gpuAcceleration) document.body.style.setProperty('will-change', 'transform');
                else document.body.style.removeProperty('will-change');
            }

            applyP2P() {
                document.body.dataset.p2p = this.state.allowP2P ? 'allowed' : 'blocked';
                this.permissionManager?.setGlobalCapability('p2p', this.state.allowP2P);
            }

            applyPrivacy() {
                const privacy = this.state.privacy || {};
                document.body.dataset.privacyCamera = privacy.camera ? 'on' : 'off';
                document.body.dataset.privacyMicrophone = privacy.microphone ? 'on' : 'off';
                document.body.dataset.privacyFilesystem = privacy.filesystem ? 'on' : 'off';
                document.body.dataset.privacyNetwork = privacy.network ? 'on' : 'off';
                this.permissionManager?.setGlobalPrivacy(privacy);
            }

            setPermissionManager(manager) {
                this.permissionManager = manager;
                manager?.syncFromSettings?.(this.state.permissions || {});
            }
        }

        class PermissionManager extends EventEmitter {
            constructor(settings, modals, notifications) {
                super();
                this.settings = settings;
                this.modals = modals;
                this.notifications = notifications;
                this.queue = [];
                this.activePrompt = null;
                this.map = {};
                this.globalCapabilities = { p2p: settings.state.allowP2P };
                this.globalPrivacy = { ...settings.state.privacy };
            }

            syncFromSettings(value) {
                this.map = JSON.parse(JSON.stringify(value || {}));
            }

            setGlobalCapability(key, allowed) {
                this.globalCapabilities[key] = allowed;
            }

            setGlobalPrivacy(privacy) {
                this.globalPrivacy = { ...privacy };
            }

            getPermissionState(appId, capability) {
                return this.map?.[appId]?.[capability] ?? null;
            }

            setPermissionState(appId, capability, state) {
                if (!this.map[appId]) this.map[appId] = {};
                this.map[appId][capability] = state;
                const snapshot = JSON.parse(JSON.stringify(this.map));
                this.settings.update({ permissions: snapshot });
                this.emit('change', { appId, capability, state });
            }

            request(appId, capability, details = {}) {
                if (!appId) return Promise.resolve(false);
                if (!this.checkGlobalGate(capability)) return Promise.resolve(false);
                const cached = this.getPermissionState(appId, capability);
                if (cached === 'granted' || cached === true) return Promise.resolve(true);
                if (cached === 'denied' || cached === false) return Promise.resolve(false);
                return new Promise(resolve => {
                    this.queue.push({ appId, capability, details, resolve });
                    this.dequeue();
                });
            }

            checkGlobalGate(capability) {
                switch (capability) {
                    case 'p2p':
                        return this.globalCapabilities.p2p;
                    case 'camera':
                    case 'microphone':
                    case 'filesystem':
                    case 'network':
                        return this.globalPrivacy?.[capability] !== false;
                    default:
                        return true;
                }
            }

            dequeue() {
                if (this.activePrompt || !this.queue.length) return;
                const payload = this.queue.shift();
                if (!payload) return;
                const { appId, capability, details, resolve } = payload;
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const appName = descriptor?.name || appId;
                const body = document.createElement('div');
                body.style.display = 'flex';
                body.style.flexDirection = 'column';
                body.style.gap = '12px';
                const summary = document.createElement('p');
                summary.style.margin = '0';
                summary.textContent = `${appName} would like ${this.describeCapability(capability, details)}.`;
                const rememberRow = document.createElement('label');
                rememberRow.style.display = 'flex';
                rememberRow.style.alignItems = 'center';
                rememberRow.style.gap = '6px';
                const rememberInput = document.createElement('input');
                rememberInput.type = 'checkbox';
                rememberRow.append(rememberInput, document.createTextNode('Remember my choice for this app'));
                body.append(summary);
                if (details?.note) {
                    const note = document.createElement('small');
                    note.textContent = details.note;
                    note.style.opacity = '0.8';
                    body.appendChild(note);
                }
                body.append(rememberRow);

                this.activePrompt = { appId, capability, resolve };
                this.modals.open({
                    title: `${appName} Permission`,
                    body,
                    actions: [
                        {
                            label: 'Deny',
                            onClick: () => {
                                if (rememberInput.checked) this.setPermissionState(appId, capability, 'denied');
                                resolve(false);
                                this.finishPrompt();
                            }
                        },
                        {
                            label: 'Allow',
                            primary: true,
                            onClick: () => {
                                if (rememberInput.checked) this.setPermissionState(appId, capability, 'granted');
                                resolve(true);
                                this.notifications?.notify('Permissions', `${appName} granted ${capability}`);
                                this.finishPrompt();
                            }
                        }
                    ]
                });
            }

            finishPrompt() {
                this.activePrompt = null;
                this.dequeue();
            }

            describeCapability(capability, details) {
                const mapping = {
                    filesystem: 'access to your files',
                    network: 'network connectivity',
                    downloads: 'control of download manager',
                    notifications: 'notification privileges',
                    camera: 'camera access',
                    microphone: 'microphone access',
                    p2p: 'peer-to-peer networking',
                    clipboard: 'clipboard access'
                };
                if (details?.label) return details.label;
                return mapping[capability] || `${capability} access`;
            }
        }
        class NotificationCenter {
            constructor(settings) {
                this.settings = settings;
                this.container = document.getElementById('toast-container');
            }

            notify(title, message, options = {}) {
                if (!this.settings.state.notifications) return;
                const toast = utils.createEl('div', 'toast');
                toast.innerHTML = `<strong>${title}</strong><p>${message}</p>`;
                if (options.action) {
                    const actionBtn = utils.createEl('button', 'btn-secondary', { text: options.action.label });
                    actionBtn.style.alignSelf = 'flex-end';
                    actionBtn.addEventListener('click', () => {
                        options.action.handler();
                        toast.remove();
                    });
                    toast.appendChild(actionBtn);
                }
                this.container.appendChild(toast);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 250);
                }, options.duration || 4000);
            }
        }

        class ModalManager {
            constructor() {
                this.layer = document.getElementById('modal-layer');
            }

            open({ title, body, actions = [] }) {
                this.close();
                const modal = utils.createEl('div', 'modal');
                const header = utils.createEl('header', '', { text: title });
                const content = utils.createEl('main');
                if (body instanceof HTMLElement) content.appendChild(body); else content.innerHTML = body;
                const footer = utils.createEl('footer');
                actions.forEach(action => {
                    const btn = utils.createEl('button', action.primary ? 'btn-primary' : 'btn-secondary', { text: action.label });
                    btn.addEventListener('click', () => {
                        const shouldClose = action.onClick ? action.onClick() !== false : true;
                        if (shouldClose) this.close();
                    });
                    footer.appendChild(btn);
                });
                modal.append(header, content, footer);
                this.layer.appendChild(modal);
                this.layer.setAttribute('aria-hidden', 'false');
                return modal;
            }

            close() {
                this.layer.setAttribute('aria-hidden', 'true');
                this.layer.innerHTML = '';
            }
        }
        class WindowManager extends EventEmitter {
            constructor() {
                super();
                this.container = document.getElementById('window-layer');
                this.taskbar = document.getElementById('taskbar-apps');
                this.windows = new Map();
                this.zCounter = 10;
                this.activeWindowId = null;
                this.supportsPointerEvents = 'PointerEvent' in window;
                this.pointerEvents = this.supportsPointerEvents
                    ? { down: 'pointerdown', move: 'pointermove', up: 'pointerup', cancel: 'pointercancel' }
                    : { down: 'mousedown', move: 'mousemove', up: 'mouseup', cancel: null };
                this.mobileQuery = typeof window.matchMedia === 'function' ? window.matchMedia('(max-width: 768px)') : null;
            }

            isMobileViewport() {
                if (this.mobileQuery) return this.mobileQuery.matches;
                return window.innerWidth <= 768;
            }

            create(appId, { title, icon, content, width = '720px', height = '520px', onClose, onFocus, onBlur }) {
                const id = `win-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                const windowEl = utils.createEl('div', 'window');
                windowEl.dataset.id = id;
                windowEl.dataset.appId = appId;
                windowEl.style.width = width;
                windowEl.style.height = height;
                windowEl.style.left = `${80 + Math.random() * 140}px`;
                windowEl.style.top = `${80 + Math.random() * 100}px`;
                windowEl.style.zIndex = ++this.zCounter;

                const header = utils.createEl('div', 'window-header');
                const controls = utils.createEl('div', 'window-controls');
                ['close', 'minimize', 'maximize'].forEach(role => {
                    const button = utils.createEl('button', 'window-control', { 'data-role': role });
                    controls.appendChild(button);
                });
                const titleEl = utils.createEl('div', 'window-title');
                const glyphText = icon || '🪟';
                const titleText = title || 'Window';
                const glyph = utils.createEl('span', 'glyph', { text: glyphText });
                const label = utils.createEl('span', '', { text: titleText });
                titleEl.append(glyph, label);
                const headerFiller = utils.createEl('div', 'window-header-filler');
                header.append(controls, titleEl, headerFiller);

                const contentContainer = utils.createEl('div', 'window-content');
                if (content instanceof HTMLElement) contentContainer.appendChild(content);
                else contentContainer.innerHTML = content || '';

                windowEl.append(header, contentContainer);

                const resizeDirections = ['n', 's', 'e', 'w', 'ne', 'nw', 'se', 'sw'];
                resizeDirections.forEach(dir => {
                    const handle = utils.createEl('div', 'resize-handle');
                    handle.dataset.dir = dir;
                    windowEl.appendChild(handle);
                });

                this.attachEvents(windowEl);
                this.container.appendChild(windowEl);
                const taskbarItem = this.createTaskbarItem(id, appId, titleText, glyphText);

                const state = {
                    id,
                    appId,
                    element: windowEl,
                    content: contentContainer,
                    onClose,
                    onFocus,
                    onBlur,
                    minimized: false,
                    maximized: false,
                    previousBounds: null,
                    title: titleText,
                    icon: glyphText,
                    titleElement: label,
                    taskbarItem
                };
                this.windows.set(id, state);
                this.focus(id);
                this.emit('created', state);
                return state;
            }

            attachEvents(windowEl) {
                const id = windowEl.dataset.id;
                const header = windowEl.querySelector('.window-header');
                const pointerDown = this.pointerEvents.down;
                const focusWindow = () => this.focus(id);

                const dragStarter = event => {
                    if (this.supportsPointerEvents && event.pointerType && event.pointerType !== 'mouse' && event.pointerType !== 'pen') {
                        focusWindow();
                        return;
                    }
                    if (!this.supportsPointerEvents && event.type.startsWith('touch')) {
                        focusWindow();
                        return;
                    }
                    this.startDrag(id, event);
                };

                header.addEventListener(pointerDown, dragStarter, { passive: false });
                if (!this.supportsPointerEvents) {
                    header.addEventListener('touchstart', focusWindow, { passive: true });
                }
                header.addEventListener('dblclick', () => this.toggleMaximize(id));

                windowEl.querySelector('[data-role="close"]').addEventListener('click', () => this.close(id));
                windowEl.querySelector('[data-role="minimize"]').addEventListener('click', () => this.minimize(id));
                windowEl.querySelector('[data-role="maximize"]').addEventListener('click', () => this.toggleMaximize(id));

                if (this.supportsPointerEvents) {
                    windowEl.addEventListener(pointerDown, focusWindow, { passive: true });
                } else {
                    windowEl.addEventListener('mousedown', focusWindow);
                    windowEl.addEventListener('touchstart', focusWindow, { passive: true });
                }

                windowEl.querySelectorAll('.resize-handle').forEach(handle => {
                    const startResize = event => {
                        if (this.supportsPointerEvents && event.pointerType && event.pointerType !== 'mouse' && event.pointerType !== 'pen') return;
                        if (!this.supportsPointerEvents && event.type.startsWith('touch')) return;
                        this.startResize(id, handle.dataset.dir, event);
                    };
                    handle.addEventListener(pointerDown, startResize, { passive: false });
                });
            }

            createTaskbarItem(id, appId, title, icon) {
                const item = utils.createEl('button', 'taskbar-item');
                item.dataset.windowId = id;
                item.setAttribute('aria-label', title);
                item.innerHTML = `<span class="glyph">${icon || '🪟'}</span><span>${title}</span>`;
                item.addEventListener('click', () => {
                    const state = this.windows.get(id);
                    if (!state) return;
                    if (state.minimized) this.restore(id);
                    else if (this.activeWindowId === id) this.minimize(id);
                    else this.focus(id);
                });
                this.taskbar.appendChild(item);
                return item;
            }

            updateTaskbarState(activeId) {
                this.taskbar.querySelectorAll('.taskbar-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.windowId === activeId);
                });
            }

            focus(id) {
                const state = this.windows.get(id);
                if (!state) return;
                this.windows.forEach(win => {
                    const active = win.id === id;
                    win.element.classList.toggle('active', active);
                    if (!active) win.onBlur?.(win);
                });
                state.element.style.display = 'flex';
                state.element.style.zIndex = ++this.zCounter;
                state.minimized = false;
                this.activeWindowId = id;
                this.updateTaskbarState(id);
                state.onFocus?.(state);
                this.emit('focus', state);
            }

            minimize(id) {
                const state = this.windows.get(id);
                if (!state) return;
                state.element.style.display = 'none';
                state.minimized = true;
                if (this.activeWindowId === id) this.activeWindowId = null;
                this.updateTaskbarState(null);
            }

            restore(id) {
                const state = this.windows.get(id);
                if (!state) return;
                state.element.style.display = 'flex';
                state.minimized = false;
                this.focus(id);
            }

            toggleMaximize(id) {
                const state = this.windows.get(id);
                if (!state) return;
                const el = state.element;
                if (!state.maximized) {
                    const rect = el.getBoundingClientRect();
                    state.previousBounds = { left: rect.left, top: rect.top, width: rect.width, height: rect.height };
                    el.style.left = '0px';
                    el.style.top = '0px';
                    el.style.width = '100%';
                    el.style.height = '100%';
                    state.maximized = true;
                } else {
                    const { left, top, width, height } = state.previousBounds || { left: 100, top: 100, width: 720, height: 520 };
                    el.style.left = `${left}px`;
                    el.style.top = `${top}px`;
                    el.style.width = `${width}px`;
                    el.style.height = `${height}px`;
                    state.maximized = false;
                }
                this.focus(id);
            }

            close(id) {
                const state = this.windows.get(id);
                if (!state) return;
                const shouldClose = state.onClose ? state.onClose(state) !== false : true;
                if (!shouldClose) return;
                state.element.remove();
                this.windows.delete(id);
                state.taskbarItem?.remove();
                if (this.activeWindowId === id) {
                    this.activeWindowId = null;
                    const next = Array.from(this.windows.keys()).pop();
                    if (next) this.focus(next);
                }
                this.emit('closed', state);
            }

            startDrag(id, event) {
                if (this.isMobileViewport()) return;
                if (this.supportsPointerEvents && event.pointerType && event.pointerType !== 'mouse' && event.pointerType !== 'pen') return;
                if (!this.supportsPointerEvents && event.type?.startsWith('touch')) return;
                if (event.button !== undefined && event.button !== 0) return;
                const state = this.windows.get(id);
                if (!state || state.maximized) return;
                this.focus(id);
                if (event.cancelable !== false) event.preventDefault();
                const el = state.element;
                const rect = el.getBoundingClientRect();
                const offsetX = event.clientX - rect.left;
                const offsetY = event.clientY - rect.top;
                const pointerId = this.supportsPointerEvents && typeof event.pointerId === 'number' ? event.pointerId : null;
                const moveEventName = this.pointerEvents.move;
                const upEventName = this.pointerEvents.up;
                const cancelEventName = this.pointerEvents.cancel;
                const move = utils.throttle(moveEvent => {
                    if (pointerId !== null && moveEvent.pointerId !== pointerId) return;
                    el.style.left = `${moveEvent.clientX - offsetX}px`;
                    el.style.top = `${moveEvent.clientY - offsetY}px`;
                }, 16);
                const stop = endEvent => {
                    if (pointerId !== null && endEvent.pointerId !== pointerId) return;
                    document.removeEventListener(moveEventName, move);
                    document.removeEventListener(upEventName, stop);
                    if (cancelEventName) document.removeEventListener(cancelEventName, stop);
                };
                document.addEventListener(moveEventName, move, { passive: false });
                document.addEventListener(upEventName, stop);
                if (cancelEventName) document.addEventListener(cancelEventName, stop);
            }

            startResize(id, dir, event) {
                if (this.isMobileViewport()) return;
                if (this.supportsPointerEvents && event.pointerType && event.pointerType !== 'mouse' && event.pointerType !== 'pen') return;
                if (!this.supportsPointerEvents && event.type?.startsWith('touch')) return;
                if (event.button !== undefined && event.button !== 0) return;
                const state = this.windows.get(id);
                if (!state || state.maximized) return;
                if (event.cancelable !== false) event.preventDefault();
                const el = state.element;
                const rect = el.getBoundingClientRect();
                const pointerId = this.supportsPointerEvents && typeof event.pointerId === 'number' ? event.pointerId : null;
                const startX = event.clientX;
                const startY = event.clientY;
                const startWidth = rect.width;
                const startHeight = rect.height;
                const startLeft = rect.left;
                const startTop = rect.top;
                const moveEventName = this.pointerEvents.move;
                const upEventName = this.pointerEvents.up;
                const cancelEventName = this.pointerEvents.cancel;
                const move = utils.throttle(moveEvent => {
                    if (pointerId !== null && moveEvent.pointerId !== pointerId) return;
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;
                    if (dir.includes('e')) el.style.width = `${Math.max(320, startWidth + dx)}px`;
                    if (dir.includes('s')) el.style.height = `${Math.max(220, startHeight + dy)}px`;
                    if (dir.includes('w')) {
                        const width = Math.max(320, startWidth - dx);
                        el.style.width = `${width}px`;
                        el.style.left = `${startLeft + dx}px`;
                    }
                    if (dir.includes('n')) {
                        const height = Math.max(220, startHeight - dy);
                        el.style.height = `${height}px`;
                        el.style.top = `${startTop + dy}px`;
                    }
                }, 16);
                const stop = endEvent => {
                    if (pointerId !== null && endEvent.pointerId !== pointerId) return;
                    document.removeEventListener(moveEventName, move);
                    document.removeEventListener(upEventName, stop);
                    if (cancelEventName) document.removeEventListener(cancelEventName, stop);
                };
                document.addEventListener(moveEventName, move, { passive: false });
                document.addEventListener(upEventName, stop);
                if (cancelEventName) document.addEventListener(cancelEventName, stop);
            }

            getWindows() {
                return Array.from(this.windows.values()).map(state => ({
                    id: state.id,
                    appId: state.appId,
                    title: state.titleElement?.textContent || state.title || 'Window',
                    minimized: state.minimized,
                    maximized: state.maximized
                }));
            }

            focusWindow(id) {
                if (this.windows.has(id)) this.focus(id);
            }

            minimizeAll() {
                this.windows.forEach((_, id) => this.minimize(id));
            }

            restoreAll() {
                let lastId = null;
                this.windows.forEach((state, id) => {
                    if (state.minimized) {
                        state.element.style.display = 'flex';
                        state.minimized = false;
                        lastId = id;
                    }
                });
                if (lastId) this.focus(lastId);
                else if (!this.activeWindowId && this.windows.size) {
                    const ids = Array.from(this.windows.keys());
                    this.focus(ids[ids.length - 1]);
                }
            }

            cycle() {
                const ids = Array.from(this.windows.keys());
                if (!ids.length) return;
                const currentIndex = ids.indexOf(this.activeWindowId);
                const nextIndex = (currentIndex + 1) % ids.length;
                this.focus(ids[nextIndex]);
            }
        }
        class DesktopManager {
            constructor(fileSystem, appManager, notifications, settings) {
                this.fileSystem = fileSystem;
                this.appManager = appManager;
                this.notifications = notifications;
                this.settings = settings;
                this.root = document.getElementById('desktop');
                this.canvas = document.getElementById('desktop-canvas');
                this.appsContainer = document.getElementById('desktop-apps');
                this.filesContainer = document.getElementById('desktop-files');
                this.windowLayer = document.getElementById('window-layer');
                this.workspace = this.canvas;
                this.contextMenu = document.getElementById('desktop-menu');
                this.iconMenu = document.getElementById('icon-menu');
                this.fileInput = document.getElementById('file-input');
                this.clipboard = null;
                this.selectedItems = new Set();
                this.lastFileSelectionIndex = null;
                this.activeAppContext = null;
                this.dockManager = null;
                this.layoutMode = settings?.state.desktopLayout || 'grid';
                this.workspaces = this.loadWorkspaces();
                this.activeWorkspaceId = this.workspaces.active || Object.keys(this.workspaces.items)[0];
                this.alignmentGuides = this.createAlignmentGuides();
                this.selectionOverlay = this.createSelectionOverlay();
                this.searchOverlay = this.createSearchOverlay();
                this.isLassoing = false;
                this.dragState = null;
                this.registerEvents();
                this.applyLayout();
                this.render();
                fileSystem.on('change', utils.debounce(() => this.render(), 120));
                this.scheduleCleanupCheck();
            }

            loadWorkspaces() {
                try {
                    const raw = scopedStorage.get('webos.desktop.workspaces.v1');
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (parsed && parsed.items && typeof parsed.items === 'object') {
                            return parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load workspaces', error);
                }
                return {
                    active: 'main',
                    items: {
                        main: {
                            id: 'main',
                            name: 'Main Desktop',
                            apps: [],
                            files: [],
                            positions: { apps: {}, files: {} }
                        }
                    }
                };
            }

            saveWorkspaces() {
                try {
                    scopedStorage.set('webos.desktop.workspaces.v1', JSON.stringify(this.workspaces));
                } catch (error) {
                    console.warn('Failed to save workspaces', error);
                }
            }

            getActiveWorkspace() {
                return this.workspaces.items[this.activeWorkspaceId] || this.workspaces.items[Object.keys(this.workspaces.items)[0]];
            }

            applyLayout() {
                document.body.dataset.desktopLayout = this.layoutMode;
            }

            createAlignmentGuides() {
                const vertical = utils.createEl('div', 'alignment-guide vertical hidden');
                const horizontal = utils.createEl('div', 'alignment-guide horizontal hidden');
                this.workspace.appendChild(vertical);
                this.workspace.appendChild(horizontal);
                return { vertical, horizontal };
            }

            createSelectionOverlay() {
                const overlay = utils.createEl('div', 'selection-overlay hidden');
                this.workspace.appendChild(overlay);
                return overlay;
            }

            createSearchOverlay() {
                const overlay = utils.createEl('div', 'desktop-search hidden');
                overlay.innerHTML = `
                    <div class="desktop-search-panel">
                        <input type="search" class="desktop-search-input" placeholder="Search apps and files" aria-label="Search" autocomplete="off" />
                        <ul class="desktop-search-results"></ul>
                    </div>`;
                document.body.appendChild(overlay);
                this.searchInput = overlay.querySelector('.desktop-search-input');
                this.searchResults = overlay.querySelector('.desktop-search-results');
                this.searchInput?.addEventListener('input', utils.debounce(() => this.performSearch(this.searchInput.value), 120));
                overlay.addEventListener('click', event => {
                    if (event.target === overlay) this.closeSearch();
                });
                this.searchInput?.addEventListener('keydown', event => {
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.closeSearch();
                    }
                    if (event.key === 'Enter') {
                        const first = this.searchResults.querySelector('li[data-id]');
                        if (first) this.activateSearchResult(first.dataset.id);
                    }
                });
                return overlay;
            }

            registerEvents() {
                this.workspace.addEventListener('contextmenu', event => {
                    if (event.target.closest('.desktop-icon')) return;
                    event.preventDefault();
                    this.hideIconMenu();
                    this.showContextMenu(event.clientX, event.clientY);
                });

                this.appsContainer.addEventListener('contextmenu', event => {
                    const icon = event.target.closest('.desktop-icon');
                    if (!icon) return;
                    event.preventDefault();
                    event.stopPropagation();
                    this.showIconMenu(icon.dataset.appId, event.clientX, event.clientY);
                });

                this.workspace.addEventListener('click', event => {
                    if (event.target.closest('.desktop-icon') || event.target.closest('.desktop-file') || event.target.closest('.window')) {
                        return;
                    }
                    this.hideIconMenu();
                    this.clearSelection();
                });

                document.addEventListener('click', event => {
                    if (!this.contextMenu.contains(event.target)) this.hideContextMenu();
                    if (!this.iconMenu.contains(event.target)) this.hideIconMenu();
                });

                this.contextMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button) return;
                    this.hideContextMenu();
                    const action = button.dataset.action;
                    switch (action) {
                        case 'new-file':
                            this.createDesktopFile();
                            break;
                        case 'new-folder':
                            this.createDesktopFolder();
                            break;
                        case 'paste':
                            this.pasteClipboard('/Desktop');
                            break;
                        case 'refresh':
                            this.render();
                            break;
                        case 'settings':
                            this.appManager.open('settings');
                            break;
                    }
                });

                this.iconMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button || !this.activeAppContext) return;
                    const action = button.dataset.action;
                    const appId = this.activeAppContext.id;
                    this.hideIconMenu();
                    switch (action) {
                        case 'app-open':
                            this.appManager.open(appId);
                            break;
                        case 'app-pin':
                            this.dockManager?.pin(appId);
                            break;
                        case 'app-unpin':
                            this.dockManager?.unpin(appId);
                            break;
                    }
                });

                this.workspace.addEventListener('dragover', event => event.preventDefault());
                this.workspace.addEventListener('drop', event => {
                    event.preventDefault();
                    const items = event.dataTransfer?.items;
                    if (!items) return;
                    const uploads = [];
                    for (const item of items) if (item.kind === 'file') uploads.push(item.getAsFile());
                    Promise.all(uploads.map(file => this.importFile('/Desktop', file))).then(() => this.render());
                });

                this.fileInput.addEventListener('change', () => {
                    const files = Array.from(this.fileInput.files || []);
                    Promise.all(files.map(file => this.importFile('/Desktop', file))).then(() => {
                        this.fileInput.value = '';
                        this.render();
                    });
                });

                this.workspace.addEventListener('pointerdown', event => this.handleWorkspacePointerDown(event));
                window.addEventListener('pointermove', event => this.handleWorkspacePointerMove(event));
                window.addEventListener('pointerup', () => this.handleWorkspacePointerUp());
            }

            showContextMenu(x, y) {
                const menuWidth = 220;
                const menuHeight = 180;
                this.contextMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.contextMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.contextMenu.setAttribute('aria-hidden', 'false');
            }

            hideContextMenu() {
                this.contextMenu.setAttribute('aria-hidden', 'true');
            }

            setDockManager(manager) {
                this.dockManager = manager;
                manager?.on?.('change', () => this.renderApps());
                this.renderApps();
            }

            showIconMenu(appId, x, y) {
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                if (!descriptor) return;
                this.activeAppContext = descriptor;
                const pinned = this.dockManager?.isPinned?.(appId);
                const pinBtn = this.iconMenu.querySelector('[data-action="app-pin"]');
                const unpinBtn = this.iconMenu.querySelector('[data-action="app-unpin"]');
                if (pinBtn) pinBtn.style.display = pinned ? 'none' : '';
                if (unpinBtn) unpinBtn.style.display = pinned ? '' : 'none';
                const menuWidth = 200;
                const menuHeight = 160;
                this.iconMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.iconMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.iconMenu.setAttribute('aria-hidden', 'false');
            }

            hideIconMenu() {
                this.iconMenu.setAttribute('aria-hidden', 'true');
                this.activeAppContext = null;
            }

            async importFile(targetDir, file) {
                if (!file) return;
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                try {
                    this.fileSystem.createFile(utils.join(targetDir, file.name), bytes, { mime: file.type || utils.mimeFromName(file.name) });
                    this.notifications.notify('File uploaded', `${file.name} saved to ${targetDir}`);
                } catch (error) {
                    this.notifications.notify('Upload failed', error.message);
                }
            }

            createDesktopFile() {
                const name = prompt('File name', 'New File.txt');
                if (!name) return;
                try {
                    this.fileSystem.createFile(`/Desktop/${name}`, '');
                    this.notifications.notify('File created', name);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            createDesktopFolder() {
                const name = prompt('Folder name', 'New Folder');
                if (!name) return;
                try {
                    this.fileSystem.createDirectory(`/Desktop/${name}`);
                    this.notifications.notify('Folder created', name);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            setClipboard(paths, mode) {
                this.clipboard = { paths, mode };
            }

            pasteClipboard(targetDir) {
                if (!this.clipboard) return;
                try {
                    for (const path of this.clipboard.paths) {
                        if (this.clipboard.mode === 'copy') this.fileSystem.copy(path, targetDir);
                        if (this.clipboard.mode === 'cut') this.fileSystem.move(path, targetDir);
                    }
                    if (this.clipboard.mode === 'cut') this.clipboard = null;
                    this.notifications.notify('Paste complete', `Items pasted into ${targetDir}`);
                } catch (error) {
                    this.notifications.notify('Error', error.message);
                }
            }

            render() {
                this.renderApps();
                this.renderDesktopFiles();
            }

            getSelectionPaths() {
                return this.getSelectedFiles();
            }

            copySelection() {
                const selection = this.getSelectionPaths();
                if (!selection.length) return false;
                this.setClipboard(selection, 'copy');
                this.notifications.notify('Copied', `${selection.length} item ready to paste`);
                return true;
            }

            cutSelection() {
                const selection = this.getSelectionPaths();
                if (!selection.length) return false;
                this.setClipboard(selection, 'cut');
                this.notifications.notify('Cut', `${selection.length} item ready to move`);
                return true;
            }

            clearSelection() {
                this.selectedItems.clear();
                this.refreshSelections();
            }

            refreshSelections() {
                this.appsContainer.querySelectorAll('.desktop-icon').forEach(icon => {
                    const key = this.encodeSelection('app', icon.dataset.appId);
                    icon.classList.toggle('active', this.selectedItems.has(key));
                });
                this.filesContainer.querySelectorAll('.desktop-file').forEach(row => {
                    const key = this.encodeSelection('file', row.dataset.path);
                    row.classList.toggle('active', this.selectedItems.has(key));
                });
            }

            encodeSelection(type, id) {
                return `${type}::${id}`;
            }

            getSelectedFiles() {
                const files = [];
                this.selectedItems.forEach(key => {
                    if (key.startsWith('file::')) files.push(key.slice(6));
                });
                return files;
            }

            handleAppClick(event, app, element) {
                event.stopPropagation();
                const key = this.encodeSelection('app', app.id);
                if (event.metaKey || event.ctrlKey) {
                    if (this.selectedItems.has(key)) this.selectedItems.delete(key); else this.selectedItems.add(key);
                } else {
                    this.selectedItems.clear();
                    this.selectedItems.add(key);
                }
                this.refreshSelections();
            }

            handleFileClick(event, entry, index, row) {
                event.stopPropagation();
                const key = this.encodeSelection('file', entry.path);
                if (event.shiftKey && this.lastFileSelectionIndex !== null && Array.isArray(this.desktopEntries)) {
                    const start = Math.min(this.lastFileSelectionIndex, index);
                    const end = Math.max(this.lastFileSelectionIndex, index);
                    this.selectedItems.clear();
                    for (let i = start; i <= end; i += 1) {
                        const item = this.desktopEntries[i];
                        if (!item) continue;
                        this.selectedItems.add(this.encodeSelection('file', item.path));
                    }
                } else if (event.metaKey || event.ctrlKey) {
                    if (this.selectedItems.has(key)) this.selectedItems.delete(key); else this.selectedItems.add(key);
                    this.lastFileSelectionIndex = index;
                } else {
                    this.selectedItems.clear();
                    this.selectedItems.add(key);
                    this.lastFileSelectionIndex = index;
                }
                this.refreshSelections();
            }

            beginIconDrag(event, payload, element) {
                if (event.button !== 0 || this.layoutMode !== 'freeform') return;
                event.preventDefault();
                const initialLeft = parseFloat(element.style.left || '0');
                const initialTop = parseFloat(element.style.top || '0');
                this.dragState = {
                    payload,
                    element,
                    startX: event.clientX,
                    startY: event.clientY,
                    initialLeft,
                    initialTop,
                    pointerId: event.pointerId
                };
                this.onIconDragMove = evt => this.handleIconDragMove(evt);
                this.onIconDragEnd = evt => this.handleIconDragEnd(evt);
                element.setPointerCapture?.(event.pointerId);
                element.addEventListener('pointermove', this.onIconDragMove);
                element.addEventListener('pointerup', this.onIconDragEnd);
                element.addEventListener('pointercancel', this.onIconDragEnd);
            }

            handleIconDragMove(event) {
                if (!this.dragState) return;
                const { element, startX, startY, initialLeft, initialTop } = this.dragState;
                const deltaX = event.clientX - startX;
                const deltaY = event.clientY - startY;
                const left = Math.max(0, initialLeft + deltaX);
                const top = Math.max(0, initialTop + deltaY);
                element.style.left = `${left}px`;
                element.style.top = `${top}px`;
                this.updateAlignmentGuides(left, top, element);
            }

            handleIconDragEnd(event) {
                if (!this.dragState) return;
                const { element, payload } = this.dragState;
                element.releasePointerCapture?.(event.pointerId || this.dragState.pointerId);
                element.removeEventListener('pointermove', this.onIconDragMove);
                element.removeEventListener('pointerup', this.onIconDragEnd);
                element.removeEventListener('pointercancel', this.onIconDragEnd);
                this.hideAlignmentGuides();
                const left = Math.max(0, parseFloat(element.style.left || '0'));
                const top = Math.max(0, parseFloat(element.style.top || '0'));
                const workspace = this.getActiveWorkspace();
                workspace.positions = workspace.positions || { apps: {}, files: {} };
                if (!workspace.positions.apps) workspace.positions.apps = {};
                workspace.positions.apps[payload.id] = { x: left, y: top };
                this.saveWorkspaces();
                this.dragState = null;
            }

            updateAlignmentGuides(left, top, element) {
                if (!this.alignmentGuides) return;
                const threshold = 12;
                let verticalShown = false;
                let horizontalShown = false;
                const centerX = left + element.offsetWidth / 2;
                const centerY = top + element.offsetHeight / 2;
                this.appsContainer.querySelectorAll('.desktop-icon.freeform').forEach(icon => {
                    if (icon === element) return;
                    const otherLeft = parseFloat(icon.style.left || '0');
                    const otherTop = parseFloat(icon.style.top || '0');
                    const otherCenterX = otherLeft + icon.offsetWidth / 2;
                    const otherCenterY = otherTop + icon.offsetHeight / 2;
                    if (Math.abs(otherCenterX - centerX) <= threshold) {
                        verticalShown = true;
                        this.alignmentGuides.vertical.classList.remove('hidden');
                        this.alignmentGuides.vertical.style.left = `${otherCenterX}px`;
                    }
                    if (Math.abs(otherCenterY - centerY) <= threshold) {
                        horizontalShown = true;
                        this.alignmentGuides.horizontal.classList.remove('hidden');
                        this.alignmentGuides.horizontal.style.top = `${otherCenterY}px`;
                    }
                });
                if (!verticalShown) this.alignmentGuides.vertical.classList.add('hidden');
                if (!horizontalShown) this.alignmentGuides.horizontal.classList.add('hidden');
            }

            hideAlignmentGuides() {
                if (!this.alignmentGuides) return;
                this.alignmentGuides.vertical.classList.add('hidden');
                this.alignmentGuides.horizontal.classList.add('hidden');
            }

            handleWorkspacePointerDown(event) {
                if (event.button !== 0) return;
                if (event.target.closest('.desktop-icon') || event.target.closest('.desktop-file') || event.target.closest('.window')) return;
                this.hideIconMenu();
                const rect = this.canvas.getBoundingClientRect();
                this.isLassoing = true;
                this.lassoOrigin = { x: event.clientX, y: event.clientY };
                this.selectionOverlay.classList.remove('hidden');
                this.selectionOverlay.style.left = `${this.lassoOrigin.x - rect.left}px`;
                this.selectionOverlay.style.top = `${this.lassoOrigin.y - rect.top}px`;
                this.selectionOverlay.style.width = '0px';
                this.selectionOverlay.style.height = '0px';
                this.selectedItems.clear();
                this.refreshSelections();
            }

            handleWorkspacePointerMove(event) {
                if (!this.isLassoing) return;
                const rect = this.canvas.getBoundingClientRect();
                const currentX = Math.min(Math.max(event.clientX, rect.left), rect.right);
                const currentY = Math.min(Math.max(event.clientY, rect.top), rect.bottom);
                const minX = Math.min(this.lassoOrigin.x, currentX);
                const minY = Math.min(this.lassoOrigin.y, currentY);
                const width = Math.abs(currentX - this.lassoOrigin.x);
                const height = Math.abs(currentY - this.lassoOrigin.y);
                this.selectionOverlay.style.left = `${minX - rect.left}px`;
                this.selectionOverlay.style.top = `${minY - rect.top}px`;
                this.selectionOverlay.style.width = `${width}px`;
                this.selectionOverlay.style.height = `${height}px`;
                this.updateLassoSelection({ left: minX, top: minY, right: minX + width, bottom: minY + height });
            }

            handleWorkspacePointerUp() {
                if (!this.isLassoing) return;
                this.isLassoing = false;
                this.selectionOverlay.classList.add('hidden');
                this.selectionOverlay.style.width = '0px';
                this.selectionOverlay.style.height = '0px';
                this.refreshSelections();
            }

            updateLassoSelection(bounds) {
                const selected = new Set();
                this.appsContainer.querySelectorAll('.desktop-icon').forEach(icon => {
                    const rect = icon.getBoundingClientRect();
                    if (this.rectIntersects(bounds, rect)) selected.add(this.encodeSelection('app', icon.dataset.appId));
                });
                this.filesContainer.querySelectorAll('.desktop-file').forEach(row => {
                    const rect = row.getBoundingClientRect();
                    if (this.rectIntersects(bounds, rect)) selected.add(this.encodeSelection('file', row.dataset.path));
                });
                this.selectedItems = selected;
                this.refreshSelections();
            }

            rectIntersects(a, b) {
                return !(b.left > a.right || b.right < a.left || b.top > a.bottom || b.bottom < a.top);
            }

            openSearch() {
                if (!this.searchOverlay) return;
                this.searchOverlay.classList.remove('hidden');
                this.performSearch('');
                setTimeout(() => this.searchInput?.focus({ preventScroll: true }), 10);
            }

            closeSearch() {
                if (!this.searchOverlay) return;
                this.searchOverlay.classList.add('hidden');
                if (this.searchResults) this.searchResults.innerHTML = '';
            }

            performSearch(rawQuery) {
                if (!this.searchResults) return;
                const query = (rawQuery || '').trim().toLowerCase();
                this.searchResults.innerHTML = '';
                if (!query) return;
                const fragment = document.createDocumentFragment();
                const workspace = this.getActiveWorkspace();
                const allowedApps = workspace?.apps || [];
                const includeAll = !allowedApps.length;
                const allowedSet = new Set(allowedApps);
                APP_CATALOG.forEach(app => {
                    if (!includeAll && !allowedSet.has(app.id)) return;
                    const haystack = `${app.name} ${app.hint}`.toLowerCase();
                    if (!haystack.includes(query)) return;
                    const li = utils.createEl('li', 'search-result');
                    li.dataset.id = `app:${app.id}`;
                    li.innerHTML = `<strong>${app.name}</strong><span>${app.hint || ''}</span>`;
                    li.addEventListener('click', () => this.activateSearchResult(li.dataset.id));
                    fragment.appendChild(li);
                });
                const matches = this.fileSystem.search(query).slice(0, 20);
                matches.forEach(match => {
                    const li = utils.createEl('li', 'search-result');
                    li.dataset.id = `file:${match.path}`;
                    li.innerHTML = `<strong>${match.name}</strong><span>${match.path}</span>`;
                    li.addEventListener('click', () => this.activateSearchResult(li.dataset.id));
                    fragment.appendChild(li);
                });
                this.searchResults.appendChild(fragment);
            }

            activateSearchResult(id) {
                if (!id) return;
                const [type, ...rest] = id.split(':');
                const value = rest.join(':');
                if (type === 'app') {
                    this.appManager.open(value);
                } else if (type === 'file') {
                    try {
                        const meta = this.fileSystem.readFileMeta(value);
                        this.appManager.openByFile(value, meta.mime);
                    } catch (error) {
                        this.notifications.notify('Desktop Search', error.message || 'Unable to open file');
                    }
                }
                this.closeSearch();
            }

            switchWorkspace(id) {
                if (!id || !this.workspaces.items[id]) return;
                this.activeWorkspaceId = id;
                this.workspaces.active = id;
                this.saveWorkspaces();
                this.selectedItems.clear();
                this.applyLayout();
                this.render();
            }

            createWorkspace(name = 'Workspace') {
                const base = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'workspace';
                let id = base;
                let counter = 2;
                while (this.workspaces.items[id]) id = `${base}-${counter++}`;
                this.workspaces.items[id] = {
                    id,
                    name,
                    apps: [],
                    files: [],
                    positions: { apps: {}, files: {} }
                };
                this.switchWorkspace(id);
                this.saveWorkspaces();
                return id;
            }

            assignSelectedToWorkspace(id) {
                const workspace = this.workspaces.items[id];
                if (!workspace) return;
                workspace.apps = workspace.apps || [];
                workspace.files = workspace.files || [];
                const appSet = new Set(workspace.apps);
                const fileSet = new Set(workspace.files);
                this.selectedItems.forEach(key => {
                    if (key.startsWith('app::')) appSet.add(key.slice(5));
                    if (key.startsWith('file::')) fileSet.add(key.slice(6));
                });
                workspace.apps = Array.from(appSet);
                workspace.files = Array.from(fileSet);
                this.saveWorkspaces();
                if (id === this.activeWorkspaceId) this.render();
            }

            handleSettingsChange(state) {
                if (!state) return;
                if (state.desktopLayout && state.desktopLayout !== this.layoutMode) {
                    this.layoutMode = state.desktopLayout;
                    this.applyLayout();
                }
            }

            stackSelectedFiles() {
                const files = this.getSelectedFiles();
                if (files.length < 2) {
                    this.notifications.notify('Desktop', 'Select two or more files to stack.');
                    return;
                }
                const name = prompt('New folder name', 'Stacked Files');
                if (!name) return;
                const targetDir = `/Desktop/${name}`;
                try {
                    if (!this.fileSystem.exists(targetDir)) this.fileSystem.createDirectory(targetDir);
                    files.forEach(path => this.fileSystem.move(path, targetDir));
                    this.notifications.notify('Desktop', `${files.length} items moved to ${name}.`);
                    this.selectedItems.clear();
                    this.render();
                } catch (error) {
                    this.notifications.notify('Desktop', error.message || 'Unable to stack files.');
                }
            }

            promptWorkspaceSwitch() {
                const entries = Object.values(this.workspaces.items).map(ws => `${ws.id}: ${ws.name}`);
                const choice = prompt(`Switch to workspace:\n${entries.join('\n')}`);
                if (!choice) return;
                const trimmed = choice.trim().toLowerCase();
                const match = Object.values(this.workspaces.items).find(ws => ws.id === trimmed || ws.name.toLowerCase() === trimmed);
                if (match) this.switchWorkspace(match.id);
                else this.notifications.notify('Desktop', 'Workspace not found.');
            }

            promptAssignWorkspace() {
                if (!this.selectedItems.size) {
                    this.notifications.notify('Desktop', 'Select items to assign to a workspace.');
                    return;
                }
                const entries = Object.values(this.workspaces.items).map(ws => `${ws.id}: ${ws.name}`);
                const choice = prompt(`Assign selection to workspace:\n${entries.join('\n')}`);
                if (!choice) return;
                const trimmed = choice.trim().toLowerCase();
                const match = Object.values(this.workspaces.items).find(ws => ws.id === trimmed || ws.name.toLowerCase() === trimmed);
                if (!match) {
                    this.notifications.notify('Desktop', 'Workspace not found.');
                    return;
                }
                this.assignSelectedToWorkspace(match.id);
                this.notifications.notify('Desktop', `Selection assigned to ${match.name}.`);
            }

            smartCleanDesktop() {
                const entries = this.fileSystem.listDirectory('/Desktop');
                const now = Date.now();
                const threshold = 21 * 24 * 60 * 60 * 1000;
                const stale = entries.filter(entry => entry.type === 'file' && entry.updatedAt && now - new Date(entry.updatedAt).getTime() > threshold);
                if (!stale.length) {
                    this.notifications.notify('Desktop', 'No stale files detected.');
                    return;
                }
                const archiveDir = '/Desktop/Archive';
                if (!this.fileSystem.exists(archiveDir)) this.fileSystem.createDirectory(archiveDir);
                stale.forEach(entry => {
                    try {
                        this.fileSystem.move(entry.path, archiveDir);
                    } catch (error) {
                        console.warn('Failed to move file during cleanup', error);
                    }
                });
                this.notifications.notify('Desktop', `Moved ${stale.length} items to Archive.`);
                this.render();
            }

            scheduleCleanupCheck() {
                try {
                    const key = 'webos.desktop.clean.timestamp';
                    const last = Number(scopedStorage.get(key) || 0);
                    if (Date.now() - last < 24 * 60 * 60 * 1000) return;
                    const entries = this.fileSystem.listDirectory('/Desktop');
                    const stale = entries.filter(entry => entry.type === 'file' && entry.updatedAt && Date.now() - new Date(entry.updatedAt).getTime() > 21 * 24 * 60 * 60 * 1000);
                    if (stale.length) {
                        this.notifications.notify('Desktop Cleanup', `${stale.length} items look unused.`, {
                            action: {
                                label: 'Clean now',
                                handler: () => this.smartCleanDesktop()
                            }
                        });
                    }
                    scopedStorage.set(key, String(Date.now()));
                } catch (error) {
                    console.warn('Cleanup suggestion failed', error);
                }
            }

            renderApps() {
                this.hideIconMenu();
                this.appsContainer.innerHTML = '';
                const workspace = this.getActiveWorkspace();
                const allowedApps = workspace?.apps || [];
                const includeAll = !allowedApps.length;
                const allowedSet = new Set(allowedApps);
                const layoutFreeform = this.layoutMode === 'freeform';
                const positions = workspace?.positions?.apps || {};
                const apps = APP_CATALOG.slice();
                apps.forEach((app, index) => {
                    if (!includeAll && !allowedSet.has(app.id)) return;
                    const icon = utils.createEl('div', 'desktop-icon');
                    icon.setAttribute('aria-label', app.name);
                    icon.dataset.appId = app.id;
                    if (layoutFreeform) {
                        icon.classList.add('freeform');
                        icon.style.position = 'absolute';
                        const fallback = { x: (index % 6) * 120, y: Math.floor(index / 6) * 120 };
                        const position = positions[app.id] || fallback;
                        icon.style.left = `${position.x}px`;
                        icon.style.top = `${position.y}px`;
                    } else {
                        icon.style.removeProperty('left');
                        icon.style.removeProperty('top');
                        icon.style.removeProperty('position');
                    }
                    const glyph = utils.createEl('div', 'glyph', { text: app.icon });
                    const label = utils.createEl('div', 'icon-label');
                    label.innerHTML = `<strong>${app.name}</strong><span>${app.hint}</span>`;
                    icon.append(glyph, label);
                    const key = this.encodeSelection('app', app.id);
                    icon.classList.toggle('active', this.selectedItems.has(key));
                    if (this.dockManager?.isPinned?.(app.id)) icon.classList.add('pinned'); else icon.classList.remove('pinned');
                    icon.addEventListener('click', event => this.handleAppClick(event, app, icon));
                    icon.addEventListener('dblclick', () => this.appManager.open(app.id));
                    icon.addEventListener('contextmenu', event => {
                        event.preventDefault();
                        event.stopPropagation();
                        this.showIconMenu(app.id, event.clientX, event.clientY);
                    });
                    if (layoutFreeform) {
                        icon.addEventListener('pointerdown', event => this.beginIconDrag(event, { type: 'app', id: app.id }, icon));
                    }
                    this.appsContainer.appendChild(icon);
                });
            }

            renderDesktopFiles() {
                this.filesContainer.innerHTML = '';
                const entries = this.fileSystem.listDirectory('/Desktop');
                this.desktopEntries = entries;
                if (!entries.length) {
                    const emptyState = utils.createEl('div', 'desktop-file');
                    emptyState.classList.add('empty');
                    emptyState.innerHTML = '<div class="file-glyph">🗂️</div><div class="file-info"><strong>No files yet</strong><span>Drag files here or create a new item.</span></div>';
                    emptyState.style.pointerEvents = 'none';
                    this.filesContainer.appendChild(emptyState);
                    return;
                }
                entries.forEach((entry, index) => {
                    const row = utils.createEl('div', 'desktop-file');
                    row.dataset.path = entry.path;
                    row.dataset.type = entry.type;
                    row.setAttribute('aria-label', entry.name);
                    const glyph = utils.createEl('div', 'file-glyph', { text: entry.type === 'directory' ? '📁' : '📄' });
                    const info = utils.createEl('div', 'file-info');
                    info.innerHTML = `<strong>${entry.name}</strong><span>${entry.type === 'directory' ? 'Folder' : entry.mime} · ${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size)}</span>`;
                    row.append(glyph, info);
                    const key = this.encodeSelection('file', entry.path);
                    row.classList.toggle('active', this.selectedItems.has(key));
                    row.addEventListener('click', event => this.handleFileClick(event, entry, index, row));
                    row.addEventListener('dblclick', () => {
                        if (entry.type === 'directory') this.appManager.open('toastsearcher', { path: entry.path });
                        else this.appManager.openByFile(entry.path, entry.mime);
                    });
                    this.filesContainer.appendChild(row);
                });
            }
        }

        class DockManager extends EventEmitter {
            constructor(appManager, windowManager, notifications, settings, categoryManager) {
                super();
                this.appManager = appManager;
                this.windowManager = windowManager;
                this.notifications = notifications;
                this.settings = settings;
                this.categoryManager = categoryManager;
                this.storageKey = 'webos.dock.pins.v1';
                this.element = document.getElementById('dock');
                this.menu = document.getElementById('dock-menu');
                this.taskbar = document.getElementById('taskbar');
                this.pins = this.load();
                this.running = new Map();
                this.activeAppId = null;
                this.menuTarget = null;
                this.menuActions = new Map();
                this.autoHide = settings?.state.dockAutoHide ?? false;
                this.smartSizing = settings?.state.dockSmartSizing !== false;
                this.predictivePinning = settings?.state.dockPredictivePinning !== false;
                this.groupedView = settings?.state.dockGroupedView ?? false;
                this.autoHideTimer = null;
                this.mouseMoveHandler = event => this.handleMouseMove(event);
                this.mouseMoveActive = false;
                this.dockHover = false;
                this.recentLaunches = new Map();
                this.render();
                this.attachEvents();
                this.updateAutohideListeners();
                windowManager.on('created', state => this.handleCreated(state));
                windowManager.on('closed', state => this.handleClosed(state));
                windowManager.on('focus', state => this.markActive(state.appId));
                settings?.setDockController?.(this);
            }

            load() {
                try {
                    const raw = scopedStorage.get(this.storageKey);
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (Array.isArray(parsed) && parsed.length) return parsed;
                    }
                } catch (error) {
                    console.warn('Failed to load dock pins', error);
                }
                return ['browser', 'toastsearcher', 'tasks', 'netflix', 'spotify'];
            }

            save() {
                scopedStorage.set(this.storageKey, JSON.stringify(this.pins));
            }

            isPinned(id) {
                return this.pins.includes(id);
            }

            pin(id, options = {}) {
                if (!id || this.isPinned(id)) return;
                this.pins.push(id);
                this.save();
                this.render();
                if (!options.silent) {
                    const message = options.reason === 'predictive'
                        ? 'Pinned to dock based on recent activity.'
                        : 'Pinned to dock.';
                    this.notifications?.notify('Dock', message);
                }
                this.emit('change', this.pins.slice());
            }

            unpin(id) {
                if (!id) return;
                this.pins = this.pins.filter(pin => pin !== id);
                this.save();
                this.render();
                this.notifications?.notify('Dock', 'Removed from dock.');
                this.emit('change', this.pins.slice());
            }

            openApp(id) {
                if (!id) return;
                try {
                    this.appManager.open(id);
                } catch (error) {
                    this.notifications?.notify('Dock', error.message || 'Unable to open application.');
                }
            }

            render() {
                this.element.innerHTML = '';
                const groups = this.buildGroups();
                let totalIcons = 0;
                groups.forEach(group => {
                    let host = this.element;
                    if (this.groupedView) {
                        const wrapper = utils.createEl('div', 'dock-group');
                        if (group.name) {
                            const label = utils.createEl('span', 'dock-group-label', { text: group.name });
                            wrapper.appendChild(label);
                        }
                        host = utils.createEl('div', 'dock-group-items');
                        wrapper.appendChild(host);
                        this.element.appendChild(wrapper);
                    }
                    group.pins.forEach(id => {
                        const button = this.createDockButton(id);
                        if (!button) return;
                        host.appendChild(button);
                        totalIcons += 1;
                    });
                });
                this.updateIndicators();
                this.applySmartSizing(totalIcons);
            }

            buildGroups() {
                if (!this.groupedView || !this.categoryManager) {
                    return [{ id: 'default', name: '', pins: this.pins.slice() }];
                }
                const rootOrder = this.categoryManager.getChildOrder(null);
                const groups = new Map();
                this.pins.forEach(id => {
                    const categoryId = this.categoryManager.getCategoryForApp(id);
                    const path = this.categoryManager.getCategoryPath(categoryId);
                    const root = path[0];
                    const key = root?.id || 'other';
                    if (!groups.has(key)) {
                        groups.set(key, { id: key, name: root?.name || 'Other', accent: root?.accent, pins: [] });
                    }
                    groups.get(key).pins.push(id);
                });
                const ordered = [];
                rootOrder.forEach(rootId => {
                    if (groups.has(rootId)) {
                        ordered.push(groups.get(rootId));
                        groups.delete(rootId);
                    }
                });
                if (groups.has('other')) {
                    ordered.push(groups.get('other'));
                    groups.delete('other');
                }
                groups.forEach(group => ordered.push(group));
                return ordered.length ? ordered : [{ id: 'default', name: '', pins: this.pins.slice() }];
            }

            createDockButton(id) {
                const descriptor = APP_CATALOG.find(app => app.id === id);
                if (!descriptor) return null;
                const button = utils.createEl('button', 'dock-item');
                button.dataset.appId = id;
                button.title = descriptor.name;
                const glyph = utils.createEl('span', 'glyph', { text: descriptor.icon });
                button.appendChild(glyph);
                if (this.running.get(id)) button.classList.add('running');
                if (this.activeAppId === id) button.classList.add('active');
                button.addEventListener('click', () => this.openApp(id));
                button.addEventListener('contextmenu', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.showMenu(button, id, event.clientX, event.clientY);
                });
                return button;
            }

            applySmartSizing(count) {
                if (!this.smartSizing) {
                    this.element.style.removeProperty('--dock-icon-size');
                    return;
                }
                if (!count) {
                    this.element.style.removeProperty('--dock-icon-size');
                    return;
                }
                const base = 64;
                const min = 44;
                const size = Math.max(min, Math.min(base, base - Math.max(0, count - 5) * 3));
                this.element.style.setProperty('--dock-icon-size', `${Math.round(size)}px`);
            }

            attachEvents() {
                document.addEventListener('click', event => {
                    if (!this.menu.contains(event.target)) this.hideMenu();
                });
                document.addEventListener('keydown', event => {
                    if (event.key === 'Escape') this.hideMenu();
                });
                this.menu.addEventListener('click', event => {
                    const button = event.target.closest('button[data-action-key]');
                    if (!button) return;
                    const handler = this.menuActions.get(button.dataset.actionKey);
                    this.hideMenu();
                    handler?.();
                });
                this.element.addEventListener('mouseenter', () => {
                    this.dockHover = true;
                    this.showDock();
                });
                this.element.addEventListener('mouseleave', () => {
                    this.dockHover = false;
                    this.scheduleHide();
                });
            }

            applyPreferences(state) {
                if (!state) return;
                this.autoHide = Boolean(state.dockAutoHide);
                this.smartSizing = state.dockSmartSizing !== false;
                this.predictivePinning = state.dockPredictivePinning !== false;
                this.groupedView = Boolean(state.dockGroupedView);
                this.updateAutohideListeners();
                this.render();
            }

            updateAutohideListeners() {
                if (this.autoHide) {
                    if (!this.mouseMoveActive) {
                        window.addEventListener('mousemove', this.mouseMoveHandler, { passive: true });
                        this.mouseMoveActive = true;
                    }
                    this.showDock(true);
                    this.scheduleHide();
                } else if (this.mouseMoveActive) {
                    window.removeEventListener('mousemove', this.mouseMoveHandler);
                    this.mouseMoveActive = false;
                    this.showDock(true);
                    if (this.autoHideTimer) {
                        clearTimeout(this.autoHideTimer);
                        this.autoHideTimer = null;
                    }
                } else {
                    this.showDock(true);
                }
            }

            showDock(force = false) {
                if (this.taskbar) this.taskbar.classList.add('dock-visible');
                if (this.autoHideTimer) {
                    clearTimeout(this.autoHideTimer);
                    this.autoHideTimer = null;
                }
            }

            hideDock() {
                if (!this.autoHide) return;
                if (this.taskbar) this.taskbar.classList.remove('dock-visible');
            }

            scheduleHide(delay = 1800) {
                if (!this.autoHide) return;
                if (this.autoHideTimer) clearTimeout(this.autoHideTimer);
                this.autoHideTimer = setTimeout(() => {
                    if (!this.dockHover) this.hideDock();
                }, delay);
            }

            handleMouseMove(event) {
                if (!this.autoHide) return;
                const position = document.body.dataset.taskbar || 'bottom';
                const threshold = 90;
                const nearEdge = position === 'top'
                    ? event.clientY <= threshold
                    : window.innerHeight - event.clientY <= threshold;
                if (nearEdge) {
                    this.showDock();
                } else if (!this.dockHover) {
                    this.scheduleHide();
                }
            }

            showMenu(target, appId, x, y) {
                this.menuTarget = target;
                this.menuActions.clear();
                this.menu.innerHTML = '';
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const context = { appId, descriptor, appManager: this.appManager, dockManager: this };
                const quickActions = DOCK_QUICK_ACTIONS[appId] || [];
                if (quickActions.length) {
                    this.addMenuLabel('Quick Actions');
                    quickActions.forEach(action => this.addMenuButton(action.label, () => action.handler(context)));
                    this.addMenuSeparator();
                }
                const jumpList = DOCK_JUMP_LISTS[appId] || [];
                if (jumpList.length) {
                    this.addMenuLabel('Jump List');
                    jumpList.forEach(item => this.addMenuButton(item.label, () => item.handler(context)));
                    this.addMenuSeparator();
                }
                const recents = (this.recentLaunches.get(appId) || []).slice(-3).reverse();
                if (recents.length) {
                    this.addMenuLabel('Recent Activity');
                    recents.forEach(timestamp => {
                        const relative = utils.relativeTime(new Date(timestamp));
                        this.addMenuButton(relative, null, { disabled: true });
                    });
                    this.addMenuSeparator();
                }
                const windows = this.windowManager.getWindows().filter(win => win.appId === appId);
                if (windows.length) {
                    this.addMenuLabel('Running Windows');
                    windows.forEach(win => {
                        const title = win.title || 'Window';
                        this.addMenuButton(`Focus ${title}`, () => this.windowManager.focusWindow(win.id));
                        this.addMenuButton(`Close ${title}`, () => this.windowManager.close?.(win.id));
                    });
                    this.addMenuSeparator();
                }
                this.addMenuLabel('Dock');
                this.addMenuButton('Open', () => this.openApp(appId));
                if (this.isPinned(appId)) {
                    this.addMenuButton('Unpin from Dock', () => this.unpin(appId));
                } else {
                    this.addMenuButton('Pin to Dock', () => this.pin(appId));
                }
                if (windows.length) {
                    this.addMenuButton('Close All Windows', () => {
                        this.windowManager.getWindows().filter(win => win.appId === appId).forEach(win => this.windowManager.close?.(win.id));
                    });
                }
                const separators = this.menu.querySelectorAll('.menu-separator');
                if (separators.length && separators[separators.length - 1].nextSibling === null) {
                    separators[separators.length - 1].remove();
                }
                this.menu.setAttribute('aria-hidden', 'false');
                requestAnimationFrame(() => {
                    const rect = this.menu.getBoundingClientRect();
                    const width = rect.width || 200;
                    const height = rect.height || 160;
                    const left = Math.min(x, window.innerWidth - width - 8);
                    const top = Math.min(y, window.innerHeight - height - 8);
                    this.menu.style.left = `${left}px`;
                    this.menu.style.top = `${top}px`;
                });
            }

            addMenuLabel(text) {
                if (!text) return;
                this.menu.appendChild(utils.createEl('div', 'context-menu-label', { text }));
            }

            addMenuSeparator() {
                this.menu.appendChild(utils.createEl('div', 'menu-separator'));
            }

            addMenuButton(label, handler, options = {}) {
                const button = utils.createEl('button');
                if (options.hint) {
                    button.innerHTML = `<span>${label}</span><span class="menu-shortcut">${options.hint}</span>`;
                } else {
                    button.textContent = label;
                }
                if (options.disabled) {
                    button.disabled = true;
                } else if (handler) {
                    const key = `${label}-${Math.random().toString(16).slice(2)}`;
                    button.dataset.actionKey = key;
                    this.menuActions.set(key, handler);
                }
                this.menu.appendChild(button);
            }

            hideMenu() {
                this.menu.setAttribute('aria-hidden', 'true');
                this.menu.innerHTML = '';
                this.menuActions.clear();
                this.menuTarget = null;
            }

            handleCreated(state) {
                if (!state?.appId) return;
                this.running.set(state.appId, (this.running.get(state.appId) || 0) + 1);
                this.updateIndicators();
            }

            handleClosed(state) {
                if (!state?.appId) return;
                const count = (this.running.get(state.appId) || 1) - 1;
                if (count <= 0) this.running.delete(state.appId); else this.running.set(state.appId, count);
                if (this.activeAppId === state.appId && count <= 0) this.activeAppId = null;
                this.updateIndicators();
            }

            markActive(appId) {
                this.activeAppId = appId;
                this.updateIndicators();
            }

            updateIndicators() {
                this.element.querySelectorAll('.dock-item').forEach(item => {
                    const id = item.dataset.appId;
                    if (!id) return;
                    item.classList.toggle('running', this.running.has(id));
                    item.classList.toggle('active', this.activeAppId === id);
                });
            }

            handleAppUsage(appId) {
                this.recordRecent(appId);
                if (!this.predictivePinning || this.isPinned(appId)) return;
                const usage = this.categoryManager?.getAppUsage?.(appId);
                if (!usage) return;
                if (usage.count >= 4) {
                    this.pin(appId, { reason: 'predictive' });
                }
            }

            recordRecent(appId) {
                const list = this.recentLaunches.get(appId) || [];
                list.push(Date.now());
                if (list.length > 5) list.shift();
                this.recentLaunches.set(appId, list);
            }
        }

        class MenuManager {
            constructor(deps) {
                this.deps = deps;
                this.dropdown = utils.createEl('div', 'menu-dropdown', { 'aria-hidden': 'true' });
                document.body.appendChild(this.dropdown);
                this.activeMenu = null;
                this.anchorButton = null;
                document.addEventListener('click', (event) => {
                    if (!this.dropdown.contains(event.target)) this.hide();
                });
            }

            attach(button, menuId) {
                button.setAttribute('aria-haspopup', 'true');
                button.setAttribute('aria-expanded', 'false');
                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (this.activeMenu === menuId) this.hide(); else this.show(menuId, button);
                });
            }

            show(menuId, button) {
                this.deps.startMenu?.hide?.();
                this.dropdown.innerHTML = '';
                const items = this.getItems(menuId);
                items.forEach(item => {
                    if (item.type === 'separator') {
                        this.dropdown.appendChild(utils.createEl('div', 'menu-separator'));
                        return;
                    }
                    const btn = utils.createEl('button');
                    btn.textContent = item.label;
                    if (item.shortcut) {
                        btn.appendChild(utils.createEl('span', 'menu-shortcut', { text: item.shortcut }));
                    }
                    if (item.disabled) {
                        btn.disabled = true;
                    } else {
                        btn.addEventListener('click', () => {
                            this.hide();
                            item.handler();
                        });
                    }
                    this.dropdown.appendChild(btn);
                });
                const rect = button.getBoundingClientRect();
                this.dropdown.style.left = `${rect.left}px`;
                this.dropdown.style.top = `${rect.bottom + 4}px`;
                this.dropdown.setAttribute('aria-hidden', 'false');
                this.activeMenu = menuId;
                if (this.anchorButton && this.anchorButton !== button) this.anchorButton.setAttribute('aria-expanded', 'false');
                this.anchorButton = button;
                this.anchorButton.setAttribute('aria-expanded', 'true');
            }

            hide() {
                this.dropdown.setAttribute('aria-hidden', 'true');
                this.dropdown.innerHTML = '';
                if (this.anchorButton) this.anchorButton.setAttribute('aria-expanded', 'false');
                this.activeMenu = null;
                this.anchorButton = null;
            }

            getItems(menuId) {
                const { desktopManager, windowManager, appManager, settings, notifications } = this.deps;
                switch (menuId) {
                    case 'finder':
                        return [
                            { label: 'About ToastSearcher', handler: () => appManager.open('toastsearcher', { path: '/Documents' }) },
                            { type: 'separator' },
                            { label: 'Preferences…', shortcut: '⌘,', handler: () => appManager.open('settings', { section: 'appearance' }) }
                        ];
                    case 'file':
                        return [
                            { label: 'New File…', shortcut: '⌘N', handler: () => desktopManager.createDesktopFile() },
                            { label: 'New Folder…', shortcut: '⇧⌘N', handler: () => desktopManager.createDesktopFolder() },
                            { type: 'separator' },
                            { label: 'Open ToastSearcher', shortcut: '⌘O', handler: () => appManager.open('toastsearcher', { path: '/Desktop' }) },
                            { label: 'Download From URL…', handler: () => this.downloadFromUrl() },
                            { type: 'separator' },
                            { label: 'Export File System Snapshot', handler: () => {
                                downloadFileSystemSnapshot(this.deps.fileSystem);
                                notifications.notify('Snapshot saved', 'Filesystem exported successfully.');
                            } }
                        ];
                    case 'edit':
                        return [
                            { label: 'Copy', shortcut: '⌘C', handler: () => desktopManager.copySelection?.() || notifications.notify('Edit', 'Select files to copy.') },
                            { label: 'Cut', shortcut: '⌘X', handler: () => desktopManager.cutSelection?.() || notifications.notify('Edit', 'Select files to cut.') },
                            { label: 'Paste', shortcut: '⌘V', handler: () => desktopManager.pasteClipboard('/Desktop') },
                            { type: 'separator' },
                            { label: 'Select None', handler: () => desktopManager.clearSelection?.() }
                        ];
                    case 'view':
                        return [
                            { label: settings.state.showParticles ? 'Hide Desktop Particles' : 'Show Desktop Particles', handler: () => settings.update({ showParticles: !settings.state.showParticles }) },
                            { label: 'Toggle Dark Mode', shortcut: '⌘⌥L', handler: () => {
                                const next = settings.state.theme === 'dark' ? 'light' : 'dark';
                                settings.update({ theme: next });
                                notifications.notify('Appearance', `Switched to ${next} mode.`);
                            } },
                            { label: 'Refresh Desktop', handler: () => desktopManager.render() }
                        ];
                    case 'go': {
                        const destinations = [
                            { label: 'Desktop', path: '/Desktop' },
                            { label: 'Documents', path: '/Documents' },
                            { label: 'Downloads', path: '/Downloads' },
                            { label: 'Pictures', path: '/Pictures' },
                            { label: 'Music', path: '/Music' }
                        ];
                        return destinations.map(dest => ({ label: dest.label, handler: () => appManager.open('toastsearcher', { path: dest.path }) }));
                    }
                    case 'window': {
                        const items = [];
                        const wins = windowManager.getWindows();
                        if (!wins.length) {
                            items.push({ label: 'No open windows', disabled: true });
                        } else {
                            wins.forEach(win => {
                                items.push({ label: win.title || 'Untitled', handler: () => windowManager.focusWindow(win.id) });
                            });
                            items.push({ type: 'separator' });
                        }
                        items.push({ label: 'Minimize All', handler: () => windowManager.minimizeAll() });
                        items.push({ label: 'Show All', handler: () => windowManager.restoreAll() });
                        return items;
                    }
                    case 'help':
                        return [
                            { label: 'ToastSearcher Help', handler: () => appManager.open('toastsearcher', { path: '/System' }) },
                            { label: 'View Keyboard Shortcuts', handler: () => {
                                this.deps.modals.open({
                                    title: 'Keyboard Shortcuts',
                                    body: `<ul style="padding-left:18px; line-height:1.6;">
                                        <li><strong>⌥ Tab</strong> — Cycle windows</li>
                                        <li><strong>⌘⇧N</strong> — New note in Text Studio</li>
                                        <li><strong>⌘O</strong> — Open ToastSearcher</li>
                                        <li><strong>⌘⌥L</strong> — Toggle dark mode</li>
                                    </ul>`,
                                    actions: [{ label: 'Done', primary: true }]
                                });
                            } },
                            { label: 'About Slighty.Toasted', handler: () => appManager.open('settings', { section: 'about' }) }
                        ];
                    default:
                        return [];
                }
            }

            async downloadFromUrl() {
                const { fileSystem, notifications } = this.deps;
                const url = prompt('Enter the file URL to download into Downloads');
                if (!url) return;
                try {
                    notifications.notify('Download', 'Fetching remote file…');
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
                    const buffer = await response.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    const contentType = response.headers.get('Content-Type') || utils.mimeFromName(url);
                    const suggested = (() => {
                        try {
                            const withoutQuery = url.split('#')[0].split('?')[0];
                            const segment = withoutQuery.split('/').filter(Boolean).pop();
                            return segment && segment.length < 128 ? segment : null;
                        } catch (error) {
                            return null;
                        }
                    })();
                    const defaultName = suggested || `download-${Date.now()}`;
                    const name = prompt('Save file as', defaultName);
                    if (!name) return;
                    const target = `/Downloads/${name}`;
                    if (fileSystem.exists(target)) {
                        if (!confirm('File exists. Overwrite?')) return;
                        fileSystem.writeFile(target, bytes, { mime: contentType });
                    } else {
                        fileSystem.createFile(target, bytes, { mime: contentType });
                    }
                    notifications.notify('Download complete', `${name} stored in Downloads.`);
                } catch (error) {
                    notifications.notify('Download failed', error.message || 'Unable to fetch remote file.');
                }
            }
        }

        class AppCategoryManager extends EventEmitter {
            constructor(appDescriptors = []) {
                super();
                this.storageKey = APP_CATEGORY_STORAGE_KEY;
                this.state = this.load();
                this.ensureDefaults();
                if (appDescriptors.length) this.registerDescriptors(appDescriptors);
            }

            load() {
                try {
                    const raw = scopedStorage.get(this.storageKey);
                    const parsed = raw ? JSON.parse(raw) : {};
                    const categories = Array.isArray(parsed.categories) ? parsed.categories.map(cat => this.normalizeCategory(cat)).filter(Boolean) : [];
                    const assignments = parsed.assignments && typeof parsed.assignments === 'object' ? parsed.assignments : {};
                    const order = Array.isArray(parsed.order) ? parsed.order : [];
                    const suggestions = parsed.suggestions && typeof parsed.suggestions === 'object' ? parsed.suggestions : {};
                    const usageRaw = parsed.usage && typeof parsed.usage === 'object' ? parsed.usage : {};
                    const usage = {
                        apps: usageRaw.apps && typeof usageRaw.apps === 'object' ? usageRaw.apps : {},
                        categories: usageRaw.categories && typeof usageRaw.categories === 'object' ? usageRaw.categories : {}
                    };
                    return { categories, assignments, order, suggestions, usage };
                } catch (error) {
                    console.warn('Failed to load category assignments', error);
                    return { categories: [], assignments: {}, order: [], suggestions: {}, usage: { apps: {}, categories: {} } };
                }
            }

            normalizeCategory(cat) {
                if (!cat || !cat.id) return null;
                return {
                    id: cat.id,
                    name: cat.name || 'Untitled',
                    icon: cat.icon || '🗂️',
                    accent: cat.accent || '#7b8bff',
                    custom: Boolean(cat.custom),
                    expanded: cat.expanded !== undefined ? Boolean(cat.expanded) : true,
                    parentId: cat.parentId || null,
                    type: cat.type || 'standard',
                    filters: cat.filters || null,
                    theme: cat.theme || 'default',
                    childrenOrder: Array.isArray(cat.childrenOrder) ? cat.childrenOrder.slice() : []
                };
            }

            ensureDefaults() {
                let changed = false;
                const categoriesMap = new Map(this.state.categories.map(cat => [cat.id, cat]));
                DEFAULT_CATEGORY_DEFS.forEach(def => {
                    const normalized = this.normalizeCategory(def);
                    if (!categoriesMap.has(def.id)) {
                        this.state.categories.push({ ...normalized, custom: Boolean(def.custom), expanded: true });
                        categoriesMap.set(def.id, this.state.categories[this.state.categories.length - 1]);
                        changed = true;
                    } else {
                        const existing = categoriesMap.get(def.id);
                        Object.assign(existing, {
                            name: normalized.name,
                            icon: normalized.icon,
                            accent: normalized.accent,
                            type: normalized.type,
                            filters: normalized.filters,
                            parentId: normalized.parentId || null,
                            custom: Boolean(def.custom),
                            theme: normalized.theme || existing.theme
                        });
                        if (existing.expanded === undefined) existing.expanded = true;
                        if (!Array.isArray(existing.childrenOrder)) existing.childrenOrder = [];
                    }
                });

                this.state.categories = this.state.categories.filter(cat => cat && cat.id);
                const validIds = new Set(this.state.categories.map(cat => cat.id));

                this.state.categories.forEach(cat => {
                    if (cat.parentId && !validIds.has(cat.parentId)) {
                        cat.parentId = null;
                        changed = true;
                    }
                });

                const rootIds = this.state.categories.filter(cat => !cat.parentId).map(cat => cat.id);
                this.state.order = reconcileOrder(this.state.order, rootIds);

                const childrenMap = new Map();
                this.state.categories.forEach(cat => {
                    if (!childrenMap.has(cat.parentId || '__root__')) childrenMap.set(cat.parentId || '__root__', []);
                    childrenMap.get(cat.parentId || '__root__').push(cat.id);
                });
                this.state.categories.forEach(cat => {
                    const children = childrenMap.get(cat.id) || [];
                    cat.childrenOrder = reconcileOrder(cat.childrenOrder, children);
                });

                if (!this.state.usage || typeof this.state.usage !== 'object') {
                    this.state.usage = { apps: {}, categories: {} };
                    changed = true;
                } else {
                    if (!this.state.usage.apps || typeof this.state.usage.apps !== 'object') {
                        this.state.usage.apps = {};
                        changed = true;
                    }
                    if (!this.state.usage.categories || typeof this.state.usage.categories !== 'object') {
                        this.state.usage.categories = {};
                        changed = true;
                    }
                }

                if (changed) this.persist();
            }

            persist() {
                const payload = {
                    categories: this.state.categories,
                    assignments: this.state.assignments,
                    order: this.state.order,
                    suggestions: this.state.suggestions,
                    usage: this.state.usage
                };
                scopedStorage.set(this.storageKey, JSON.stringify(payload));
                this.emit('change', this.state);
            }

            registerDescriptors(descriptors = []) {
                let changed = false;
                descriptors.forEach(descriptor => {
                    if (!descriptor?.id) return;
                    if (!this.state.assignments[descriptor.id]) {
                        const target = this.ensureCategoryExists(this.autoCategorize(descriptor));
                        this.state.assignments[descriptor.id] = target;
                        changed = true;
                    }
                    const suggestions = this.suggestCategories(descriptor);
                    if (suggestions.length) {
                        this.state.suggestions[descriptor.id] = suggestions;
                        changed = true;
                    } else if (this.state.suggestions[descriptor.id]) {
                        delete this.state.suggestions[descriptor.id];
                        changed = true;
                    }
                });
                if (changed) this.persist();
            }

            ensureCategoryExists(categoryId) {
                if (!categoryId) return 'uncategorized';
                const existing = this.getCategoryById(categoryId);
                if (existing) return existing.id;
                const fallback = DEFAULT_CATEGORY_DEFS.find(cat => cat.id === categoryId);
                if (fallback) {
                    const normalized = this.normalizeCategory({ ...fallback, custom: Boolean(fallback.custom), expanded: true });
                    this.state.categories.push(normalized);
                    if (!normalized.parentId) {
                        this.state.order = reconcileOrder(this.state.order, [...this.state.order, normalized.id]);
                    } else {
                        const parent = this.getCategoryById(normalized.parentId);
                        if (parent) parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, normalized.id]);
                    }
                    this.persist();
                    return normalized.id;
                }
                return 'uncategorized';
            }

            autoCategorize(descriptor) {
                if (!descriptor) return 'uncategorized';
                const explicit = DEFAULT_APP_CATEGORY_ASSIGNMENTS[descriptor.id];
                if (explicit) return explicit;
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                for (const rule of CATEGORY_KEYWORD_RULES) {
                    if (rule.keywords.some(keyword => haystack.includes(keyword))) {
                        return this.ensureCategoryExists(rule.category);
                    }
                }
                return 'uncategorized';
            }

            suggestCategories(descriptor) {
                if (!descriptor) return [];
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                const matches = new Set();
                CATEGORY_KEYWORD_RULES.forEach(rule => {
                    if (rule.keywords.some(keyword => haystack.includes(keyword))) {
                        matches.add(this.ensureCategoryExists(rule.category));
                    }
                });
                return Array.from(matches);
            }

            listCategories(options = {}) {
                const { includeRoot = true } = options;
                const output = [];
                const visit = (id, depth = 0) => {
                    const category = this.getCategoryById(id);
                    if (!category) return;
                    if (includeRoot || depth > 0 || category.parentId) {
                        output.push({ ...category, depth, path: this.getCategoryPath(id) });
                    }
                    const childOrder = category.childrenOrder || [];
                    childOrder.forEach(childId => visit(childId, depth + 1));
                };
                (this.state.order || []).forEach(rootId => visit(rootId, 0));
                return output;
            }

            getCategoryTree() {
                const build = (id) => {
                    const category = this.getCategoryById(id);
                    if (!category) return null;
                    const children = (category.childrenOrder || []).map(childId => build(childId)).filter(Boolean);
                    return { category, children };
                };
                return (this.state.order || []).map(rootId => build(rootId)).filter(Boolean);
            }

            getCategoryById(id) {
                return this.state.categories.find(cat => cat.id === id) || null;
            }

            getCategoryPath(id) {
                const path = [];
                let current = this.getCategoryById(id);
                while (current) {
                    path.unshift(current);
                    if (!current.parentId) break;
                    current = this.getCategoryById(current.parentId);
                }
                return path;
            }

            getChildOrder(parentId) {
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    return parent ? parent.childrenOrder.slice() : [];
                }
                return (this.state.order || []).slice();
            }

            getCategoryForApp(appId) {
                if (this.state.assignments[appId]) return this.state.assignments[appId];
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const inferred = this.autoCategorize(descriptor);
                this.state.assignments[appId] = inferred;
                this.persist();
                return inferred;
            }

            getSmartMatches(descriptor) {
                const matches = [];
                const haystack = `${descriptor.name || ''} ${descriptor.hint || ''} ${descriptor.description || ''}`.toLowerCase();
                this.state.categories.forEach(cat => {
                    if (cat.type === 'smart' && cat.filters?.keywords?.some(keyword => haystack.includes(keyword))) {
                        matches.push(cat.id);
                    }
                });
                return matches;
            }

            recordAppUsage(appId) {
                if (!appId) return;
                if (!this.state.usage) this.state.usage = { apps: {}, categories: {} };
                const now = Date.now();
                if (!this.state.usage.apps[appId]) this.state.usage.apps[appId] = { count: 0, lastUsed: 0 };
                this.state.usage.apps[appId].count += 1;
                this.state.usage.apps[appId].lastUsed = now;
                let categoryId = this.state.assignments[appId];
                if (!categoryId) {
                    const descriptor = APP_CATALOG.find(app => app.id === appId);
                    categoryId = this.autoCategorize(descriptor);
                    this.state.assignments[appId] = categoryId;
                }
                categoryId = this.ensureCategoryExists(categoryId);
                if (!this.state.usage.categories[categoryId]) this.state.usage.categories[categoryId] = { count: 0, lastUsed: 0 };
                this.state.usage.categories[categoryId].count += 1;
                this.state.usage.categories[categoryId].lastUsed = now;
                this.persist();
            }

            getAppUsage(appId) {
                const usage = this.state.usage?.apps?.[appId];
                return usage ? { ...usage } : { count: 0, lastUsed: null };
            }

            getCategoryUsage(categoryId) {
                const usage = this.state.usage?.categories?.[categoryId];
                return usage ? { ...usage } : { count: 0, lastUsed: null };
            }

            getSuggestedCategoriesForApp(appId, limit = 3) {
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                if (!descriptor) return [];
                const suggestions = new Set();
                (this.state.suggestions?.[appId] || []).forEach(id => suggestions.add(id));
                this.suggestCategories(descriptor).forEach(id => suggestions.add(id));
                const ranked = Array.from(suggestions)
                    .map(id => {
                        const category = this.getCategoryById(id);
                        if (!category) return null;
                        const usage = this.getCategoryUsage(id);
                        return { category, usage };
                    })
                    .filter(Boolean)
                    .sort((a, b) => (b.usage.count - a.usage.count) || ((b.usage.lastUsed || 0) - (a.usage.lastUsed || 0)));
                return ranked.slice(0, limit).map(entry => entry.category);
            }

            getUsageInsights(limit = 3) {
                const trending = Object.entries(this.state.usage?.categories || {})
                    .map(([categoryId, data]) => ({
                        category: this.getCategoryById(categoryId),
                        count: data?.count || 0,
                        lastUsed: data?.lastUsed || 0
                    }))
                    .filter(item => item.category)
                    .sort((a, b) => (b.count - a.count) || (b.lastUsed - a.lastUsed))
                    .slice(0, limit);

                const suggestedMoves = Object.entries(this.state.usage?.apps || {})
                    .filter(([, data]) => (data?.count || 0) >= 3)
                    .map(([appId, data]) => {
                        const descriptor = APP_CATALOG.find(app => app.id === appId);
                        if (!descriptor) return null;
                        const currentCategoryId = this.state.assignments[appId] || 'uncategorized';
                        const currentCategory = this.getCategoryById(currentCategoryId);
                        const suggestions = this.getSuggestedCategoriesForApp(appId, limit);
                        return {
                            appId,
                            descriptor,
                            usage: { count: data.count, lastUsed: data.lastUsed },
                            currentCategory,
                            suggestions
                        };
                    })
                    .filter(item => item && item.suggestions.length && (!item.currentCategory || item.currentCategory.id === 'uncategorized'))
                    .slice(0, limit);

                return { trending, suggestedMoves };
            }

            dismissSuggestionsForApp(appId) {
                if (!appId || !this.state.suggestions?.[appId]) return;
                delete this.state.suggestions[appId];
                this.persist();
            }

            expandPath(id) {
                const path = this.getCategoryPath(id);
                let changed = false;
                path.forEach(cat => {
                    if (cat && !cat.expanded) {
                        cat.expanded = true;
                        changed = true;
                    }
                });
                if (changed) this.persist();
            }

            createCategory(name, icon = '🗂️', options = {}) {
                const trimmed = (name || '').trim();
                if (!trimmed) throw new Error('Category name is required');
                const base = trimmed.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || `category-${Math.random().toString(16).slice(2, 6)}`;
                const accent = options.accent || CATEGORY_ACCENTS[Math.floor(Math.random() * CATEGORY_ACCENTS.length)];
                let id = base;
                let counter = 2;
                while (this.getCategoryById(id)) id = `${base}-${counter++}`;
                const parentId = options.parentId || null;
                if (parentId && !this.getCategoryById(parentId)) throw new Error('Parent category not found');
                const category = this.normalizeCategory({
                    id,
                    name: trimmed,
                    icon: icon || '🗂️',
                    accent,
                    custom: true,
                    expanded: true,
                    parentId,
                    type: options.type || 'standard',
                    filters: options.filters || null
                });
                this.state.categories.push(category);
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, id]);
                } else {
                    this.state.order = reconcileOrder(this.state.order, [...this.state.order, id]);
                }
                if (this.state.usage && !this.state.usage.categories[id]) {
                    this.state.usage.categories[id] = { count: 0, lastUsed: 0 };
                }
                this.persist();
                return id;
            }

            renameCategory(id, name) {
                const category = this.getCategoryById(id);
                if (!category) return;
                if (!category.custom && DEFAULT_CATEGORY_DEFS.some(cat => cat.id === id)) {
                    throw new Error('System categories cannot be renamed');
                }
                category.name = name.trim();
                this.persist();
            }

            setCategoryIcon(id, icon) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.icon = icon || '🗂️';
                this.persist();
            }

            setCategoryAccent(id, accent) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.accent = accent || category.accent;
                this.persist();
            }

            setCategoryTheme(id, theme) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.theme = theme || 'default';
                this.persist();
            }

            setCategoryFilters(id, filters) {
                const category = this.getCategoryById(id);
                if (!category) return;
                const keywords = Array.isArray(filters)
                    ? filters.map(word => word.trim()).filter(Boolean)
                    : String(filters || '')
                        .split(',')
                        .map(word => word.trim())
                        .filter(Boolean);
                if (keywords.length) {
                    category.type = 'smart';
                    category.filters = { keywords };
                } else {
                    category.type = 'standard';
                    category.filters = null;
                }
                this.persist();
            }

            deleteCategory(id) {
                if (DEFAULT_CATEGORY_DEFS.some(cat => cat.id === id)) throw new Error('Cannot delete default categories');
                const category = this.getCategoryById(id);
                if (!category) return;
                const parentId = category.parentId;
                if (this.state.usage?.categories?.[id]) delete this.state.usage.categories[id];
                (category.childrenOrder || []).forEach(childId => {
                    const child = this.getCategoryById(childId);
                    if (!child) return;
                    child.parentId = parentId || null;
                    if (parentId) {
                        const parent = this.getCategoryById(parentId);
                        parent.childrenOrder = reconcileOrder(parent.childrenOrder, [...parent.childrenOrder, childId]);
                    } else {
                        this.state.order = reconcileOrder(this.state.order, [...this.state.order, childId]);
                    }
                });
                if (parentId) {
                    const parent = this.getCategoryById(parentId);
                    parent.childrenOrder = parent.childrenOrder.filter(child => child !== id);
                } else {
                    this.state.order = this.state.order.filter(rootId => rootId !== id);
                }
                this.state.categories = this.state.categories.filter(cat => cat.id !== id);
                Object.entries(this.state.assignments).forEach(([appId, catId]) => {
                    if (catId === id) this.state.assignments[appId] = 'uncategorized';
                });
                Object.entries(this.state.suggestions || {}).forEach(([key, list]) => {
                    const filtered = Array.isArray(list) ? list.filter(catId => catId !== id) : [];
                    if (filtered.length) this.state.suggestions[key] = filtered; else delete this.state.suggestions[key];
                });
                this.persist();
            }

            assignApp(appId, categoryId) {
                const target = this.ensureCategoryExists(categoryId);
                this.state.assignments[appId] = target;
                if (this.state.usage && !this.state.usage.categories[target]) {
                    this.state.usage.categories[target] = { count: 0, lastUsed: 0 };
                }
                this.persist();
            }

            toggleExpanded(id) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.expanded = !category.expanded;
                this.persist();
            }

            setExpanded(id, value) {
                const category = this.getCategoryById(id);
                if (!category) return;
                category.expanded = Boolean(value);
                this.persist();
            }

            reorderCategory(sourceId, targetParentId, targetIndex = Infinity) {
                const category = this.getCategoryById(sourceId);
                if (!category) return;
                if (targetParentId === sourceId) return;
                if (this.isAncestor(sourceId, targetParentId)) return;

                if (category.parentId) {
                    const parent = this.getCategoryById(category.parentId);
                    if (parent) parent.childrenOrder = parent.childrenOrder.filter(id => id !== sourceId);
                } else {
                    this.state.order = this.state.order.filter(id => id !== sourceId);
                }

                category.parentId = targetParentId || null;

                if (category.parentId) {
                    const parent = this.getCategoryById(category.parentId);
                    if (!parent) {
                        category.parentId = null;
                        this.state.order = this.insertAt(this.state.order, sourceId, targetIndex);
                    } else {
                        parent.childrenOrder = this.insertAt(parent.childrenOrder, sourceId, targetIndex);
                    }
                } else {
                    this.state.order = this.insertAt(this.state.order, sourceId, targetIndex);
                }
                this.persist();
            }

            isAncestor(ancestorId, childId) {
                if (!ancestorId || !childId) return false;
                let cursor = this.getCategoryById(childId);
                while (cursor) {
                    if (cursor.parentId === ancestorId) return true;
                    cursor = this.getCategoryById(cursor.parentId);
                }
                return false;
            }

            insertAt(list, id, index) {
                const clone = (list || []).filter(item => item !== id);
                const safeIndex = Number.isFinite(index) ? Math.max(0, Math.min(index, clone.length)) : clone.length;
                clone.splice(safeIndex, 0, id);
                return clone;
            }
        }

        class StartMenu {
            constructor({ appManager, categoryManager, dockManager = null, notifications, modals }) {
                this.appManager = appManager;
                this.categoryManager = categoryManager;
                this.dockManager = dockManager;
                this.notifications = notifications;
                this.modals = modals;
                this.element = document.getElementById('start-menu');
                this.categoriesEl = document.getElementById('start-menu-categories');
                this.searchInput = document.getElementById('start-menu-search');
                this.addCategoryButton = document.getElementById('start-menu-add-category');
                this.manageCategoriesButton = document.getElementById('start-menu-manage-categories');
                this.countEl = document.getElementById('start-menu-app-count');
                this.startButton = document.getElementById('start-button');
                this.contextMenu = document.getElementById('start-menu-menu');
                this.pinButton = document.getElementById('start-menu-pin');
                this.suggestionStrip = utils.createEl('div', 'start-menu-suggestions hidden');
                this.categoriesEl?.parentElement?.insertBefore(this.suggestionStrip, this.categoriesEl);
                this.visible = false;
                this.searchTerm = '';
                this.contextTarget = null;
                this.animationStates = new Map();
                this.draggingCategoryId = null;
                this.interacting = false;
                this.interactionTimer = null;
                this.pinned = scopedStorage.get('webos.startMenuPinned') === 'true';
                if ('IntersectionObserver' in window) {
                    this.categoryObserver = new IntersectionObserver(entries => {
                        entries.forEach(entry => {
                            if (!entry.isIntersecting) return;
                            entry.target.classList.add('visible');
                            this.categoryObserver.unobserve(entry.target);
                        });
                    }, { root: this.categoriesEl, threshold: 0.12 });
                } else {
                    this.categoryObserver = null;
                }

                this.startButton.addEventListener('click', event => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.toggle();
                });

                document.addEventListener('click', event => {
                    if (!this.visible) return;
                    if (this.element.contains(event.target) || event.target === this.startButton) {
                        this.releaseInteractionGuard();
                        return;
                    }
                    if (this.interacting || this.pinned) return;
                    this.hide();
                });

                document.addEventListener('keydown', event => {
                    if (!this.visible) return;
                    if (event.key === 'Escape') {
                        event.preventDefault();
                        this.hide(true);
                    }
                });

                this.searchInput.addEventListener('input', utils.debounce(event => {
                    this.searchTerm = event.target.value.trim().toLowerCase();
                    this.render();
                }, 120));

                this.addCategoryButton.addEventListener('click', () => this.promptCreateCategory());
                this.manageCategoriesButton.addEventListener('click', () => this.openManageCategories());

                this.categoriesEl.addEventListener('scroll', () => {
                    // lazy placeholder for future use
                });

                this.categoriesEl.addEventListener('dragover', event => {
                    if (!this.draggingCategoryId) return;
                    if (event.target.closest('.start-menu-category')) return;
                    event.preventDefault();
                });
                this.categoriesEl.addEventListener('drop', event => {
                    if (!this.draggingCategoryId) return;
                    if (event.target.closest('.start-menu-category')) return;
                    event.preventDefault();
                    this.categoryManager.reorderCategory(this.draggingCategoryId, null, Infinity);
                    this.draggingCategoryId = null;
                });

                this.element.addEventListener('pointerdown', () => this.setInteractionGuard(true));
                this.element.addEventListener('pointerup', () => this.releaseInteractionGuard());
                this.element.addEventListener('pointerleave', () => this.releaseInteractionGuard(160));
                this.element.addEventListener('pointercancel', () => this.releaseInteractionGuard());

                if (this.pinButton) {
                    this.pinButton.addEventListener('click', () => this.setPinned(!this.pinned));
                    this.updatePinButton();
                }

                this.contextMenu.addEventListener('click', event => {
                    const button = event.target.closest('button');
                    if (!button || !this.contextTarget) return;
                    const action = button.dataset.action;
                    this.hideContextMenu();
                    switch (action) {
                        case 'start-open':
                            this.openApp(this.contextTarget);
                            break;
                        case 'start-pin':
                            this.pinApp(this.contextTarget);
                            break;
                        case 'start-move':
                            this.promptMoveApp(this.contextTarget);
                            break;
                    }
                });

                document.addEventListener('click', event => {
                    if (!this.contextMenu.contains(event.target)) this.hideContextMenu();
                });

                this.categoryManager.on('change', () => this.render());
                this.render();
            }

            setDockManager(manager) {
                this.dockManager = manager;
            }

            setInteractionGuard(active) {
                if (active) {
                    this.interacting = true;
                    if (this.interactionTimer) {
                        clearTimeout(this.interactionTimer);
                        this.interactionTimer = null;
                    }
                } else {
                    this.releaseInteractionGuard();
                }
            }

            releaseInteractionGuard(delay = 0) {
                if (this.interactionTimer) {
                    clearTimeout(this.interactionTimer);
                    this.interactionTimer = null;
                }
                if (delay > 0) {
                    this.interactionTimer = setTimeout(() => {
                        this.interacting = false;
                        this.interactionTimer = null;
                    }, delay);
                } else {
                    this.interacting = false;
                }
            }

            setPinned(pinned) {
                this.pinned = Boolean(pinned);
                scopedStorage.set('webos.startMenuPinned', this.pinned ? 'true' : 'false');
                this.updatePinButton();
                if (this.pinned && !this.visible) this.show();
            }

            updatePinButton() {
                if (!this.pinButton) return;
                this.pinButton.setAttribute('aria-pressed', this.pinned ? 'true' : 'false');
                this.pinButton.textContent = this.pinned ? '📌 Pinned' : '📌 Pin';
            }

            handleExternalFocus(state) {
                if (!this.visible) return;
                if (this.pinned || this.interacting) return;
                if (state?.appId === 'start-menu') return;
                this.hide();
            }

            toggle() {
                if (this.visible) this.hide(true); else this.show();
            }

            show() {
                if (this.visible) return;
                this.visible = true;
                this.element.setAttribute('aria-hidden', 'false');
                this.startButton.setAttribute('aria-expanded', 'true');
                this.startButton.classList.add('active');
                this.render();
                setTimeout(() => this.searchInput.focus({ preventScroll: true }), 120);
            }

            hide(force = false) {
                if (!this.visible) return;
                if (this.pinned && !force) return;
                this.visible = false;
                this.element.setAttribute('aria-hidden', 'true');
                this.startButton.setAttribute('aria-expanded', 'false');
                this.startButton.classList.remove('active');
                this.hideContextMenu();
                if (this.searchTerm) {
                    this.searchTerm = '';
                    this.searchInput.value = '';
                }
            }

            hideContextMenu() {
                this.contextMenu.setAttribute('aria-hidden', 'true');
                this.contextTarget = null;
            }

            showContextMenu(appId, x, y) {
                this.contextTarget = appId;
                const menuWidth = 220;
                const menuHeight = 150;
                this.contextMenu.style.left = `${Math.min(x, window.innerWidth - menuWidth)}px`;
                this.contextMenu.style.top = `${Math.min(y, window.innerHeight - menuHeight)}px`;
                this.contextMenu.setAttribute('aria-hidden', 'false');
            }

            getAppDescriptors() {
                return this.appManager.listDescriptors?.() || APP_CATALOG.slice();
            }

            buildAppMap() {
                const descriptors = this.getAppDescriptors();
                const map = new Map();
                const add = (categoryId, descriptor) => {
                    if (!categoryId || !descriptor) return;
                    if (!map.has(categoryId)) map.set(categoryId, []);
                    const bucket = map.get(categoryId);
                    if (!bucket.some(item => item.id === descriptor.id)) bucket.push(descriptor);
                };
                descriptors.forEach(descriptor => {
                    add(this.categoryManager.getCategoryForApp(descriptor.id), descriptor);
                    this.categoryManager.getSmartMatches(descriptor).forEach(id => add(id, descriptor));
                });
                if (Array.isArray(GAME_APP_IDS) && GAME_APP_IDS.length) {
                    GAME_APP_IDS.forEach(id => {
                        const descriptor = descriptors.find(app => app.id === id) || APP_CATALOG.find(app => app.id === id);
                        add('games', descriptor);
                    });
                }
                return map;
            }

            render() {
                const categories = this.categoryManager.listCategories({ includeRoot: true });
                const appMap = this.buildAppMap();
                const term = (this.searchTerm || '').toLowerCase();
                const totalApps = this.getAppDescriptors().length;
                this.countEl.textContent = `${totalApps} apps installed`;
                const insights = this.categoryManager.getUsageInsights?.(6) || { trending: [], suggestedMoves: [] };
                this.renderSuggestions(insights);
                this.categoriesEl.innerHTML = '';

                const matchesTerm = (value) => (value || '').toLowerCase().includes(term);

                let visibleCategoryCount = 0;

                categories.forEach(category => {
                    const apps = (appMap.get(category.id) || []).slice().sort((a, b) => a.name.localeCompare(b.name));
                    const matchesCategory = term && matchesTerm(category.name);
                    const filteredApps = term
                        ? apps.filter(app => matchesTerm(app.name) || matchesTerm(app.hint) || matchesTerm(app.id))
                        : apps;
                    const appsForDisplay = matchesCategory ? apps : filteredApps;
                    if (!appsForDisplay.length && term && !matchesCategory && category.type !== 'smart') return;

                    visibleCategoryCount += 1;
                    const categoryEl = utils.createEl('div', 'start-menu-category');
                    categoryEl.dataset.categoryId = category.id;
                    categoryEl.dataset.depth = String(category.depth || 0);
                    categoryEl.setAttribute('role', 'treeitem');
                    categoryEl.setAttribute('aria-expanded', category.expanded ? 'true' : 'false');
                    categoryEl.style.setProperty('--category-depth', String(category.depth || 0));
                    if (category.accent) categoryEl.style.setProperty('--category-accent', category.accent);
                    if (category.type === 'smart') categoryEl.classList.add('category-smart');

                    const header = utils.createEl('div', 'start-menu-category-header');
                    const meta = utils.createEl('div', 'start-menu-category-meta');
                    meta.innerHTML = `<span class="glyph">${category.icon || '🗂️'}</span>`;
                    const text = utils.createEl('div');
                    text.innerHTML = `<strong>${category.name}</strong><span>${apps.length} app${apps.length === 1 ? '' : 's'}</span>`;

                    const usage = this.categoryManager.getCategoryUsage(category.id);
                    const usageBits = [];
                    if (usage.count) usageBits.push(`${usage.count} launch${usage.count === 1 ? '' : 'es'}`);
                    if (usage.lastUsed) usageBits.push(`Last ${utils.relativeTime(new Date(usage.lastUsed))}`);
                    const crumb = (category.path || []).slice(0, -1).map(node => node.name).join(' › ');
                    const infoLine = [crumb, usageBits.join(' • ')].filter(Boolean).join(' · ');
                    if (infoLine) {
                        const small = document.createElement('small');
                        small.textContent = infoLine;
                        text.appendChild(small);
                    }
                    meta.appendChild(text);

                    const controls = utils.createEl('div', 'start-menu-category-controls');
                    const toggleBtn = utils.createEl('button', '', { title: category.expanded ? 'Collapse' : 'Expand' });
                    toggleBtn.textContent = category.expanded ? '▾' : '▸';
                    controls.appendChild(toggleBtn);
                    if (category.custom) {
                        const editBtn = utils.createEl('button', '', { title: 'Edit category' });
                        editBtn.textContent = '✎';
                        controls.appendChild(editBtn);
                        editBtn.addEventListener('click', event => {
                            event.stopPropagation();
                            this.promptEditCategory(category.id);
                        });
                    }

                    header.append(meta, controls);
                    header.addEventListener('click', () => {
                        this.toggleCategory(category.id, categoryEl);
                        const newState = categoryEl.getAttribute('aria-expanded') === 'true';
                        toggleBtn.textContent = newState ? '▾' : '▸';
                    });
                    header.setAttribute('draggable', 'true');
                    header.addEventListener('dragstart', event => {
                        this.draggingCategoryId = category.id;
                        event.dataTransfer?.setData('text/plain', category.id);
                        event.dataTransfer?.setDragImage?.(categoryEl, 0, 0);
                        event.dataTransfer.effectAllowed = 'move';
                        categoryEl.classList.add('drag-source');
                    });
                    header.addEventListener('dragend', () => {
                        this.draggingCategoryId = null;
                        categoryEl.classList.remove('drag-source');
                        categoryEl.classList.remove('drag-over');
                    });

                    categoryEl.addEventListener('dragover', event => {
                        if (!this.draggingCategoryId || this.draggingCategoryId === category.id) return;
                        event.preventDefault();
                        categoryEl.classList.add('drag-over');
                    });
                    categoryEl.addEventListener('dragleave', event => {
                        if (event.relatedTarget && categoryEl.contains(event.relatedTarget)) return;
                        categoryEl.classList.remove('drag-over');
                    });
                    categoryEl.addEventListener('drop', event => {
                        if (!this.draggingCategoryId || this.draggingCategoryId === category.id) return;
                        event.preventDefault();
                        categoryEl.classList.remove('drag-over');
                        const rect = categoryEl.getBoundingClientRect();
                        const offset = event.clientY - rect.top;
                        const height = rect.height || 1;
                        const centerZone = offset > height * 0.35 && offset < height * 0.65;
                        const siblings = this.categoryManager.getChildOrder(category.parentId || null);
                        const currentIndex = siblings.indexOf(category.id);
                        let targetParent = category.parentId || null;
                        let targetIndex;
                        if (event.ctrlKey || event.metaKey || centerZone) {
                            targetParent = category.id;
                            targetIndex = 0;
                        } else if (offset < height * 0.5) {
                            targetIndex = Math.max(0, currentIndex);
                        } else {
                            targetIndex = currentIndex + 1;
                        }
                        this.categoryManager.reorderCategory(this.draggingCategoryId, targetParent, targetIndex);
                        this.draggingCategoryId = null;
                    });

                    const wrapper = utils.createEl('div', 'start-menu-app-wrapper');
                    const grid = utils.createEl('div', 'start-menu-app-grid');
                    if (!appsForDisplay.length) {
                        const empty = utils.createEl('button', 'start-menu-app empty');
                        const subtitle = category.type === 'smart' ? 'Smart category will populate automatically.' : 'Nothing in this category yet.';
                        empty.innerHTML = `<span class="glyph">—</span><div class="app-info"><strong>No apps</strong><span>${subtitle}</span></div>`;
                        empty.style.opacity = '1';
                        empty.style.transform = 'none';
                        grid.appendChild(empty);
                    } else {
                        appsForDisplay.forEach((app, index) => {
                            const card = utils.createEl('button', 'start-menu-app');
                            card.dataset.appId = app.id;
                            card.style.setProperty('--item-index', String(index));
                            card.innerHTML = `<span class="glyph">${app.icon || '🪟'}</span><div class="app-info"><strong>${app.name}</strong><span>${app.hint || 'Open application'}</span></div>`;
                            card.addEventListener('click', () => this.openApp(app.id));
                            card.addEventListener('contextmenu', event => {
                                event.preventDefault();
                                this.showContextMenu(app.id, event.clientX, event.clientY);
                            });
                            grid.appendChild(card);
                        });
                    }
                    wrapper.appendChild(grid);

                    categoryEl.append(header, wrapper);
                    this.categoriesEl.appendChild(categoryEl);
                    this.applyWrapperHeight(categoryEl, category.expanded);
                    this.observeCategory(categoryEl);
                });

                if (!visibleCategoryCount) {
                    const emptyState = utils.createEl('div', 'start-menu-category');
                    emptyState.innerHTML = '<div class="start-menu-category-header"><div class="start-menu-category-meta"><span class="glyph">🔍</span><div><strong>No matches</strong><span>Try a different search.</span></div></div></div>';
                    this.categoriesEl.appendChild(emptyState);
                    this.observeCategory(emptyState);
                }
            }

            observeCategory(element) {
                if (!element) return;
                element.classList.remove('visible');
                if (this.categoryObserver) {
                    this.categoryObserver.observe(element);
                } else {
                    requestAnimationFrame(() => element.classList.add('visible'));
                }
            }

            renderSuggestions(insights) {
                if (!this.suggestionStrip) return;
                const trending = insights?.trending || [];
                const suggestedMoves = insights?.suggestedMoves || [];
                if (!trending.length && !suggestedMoves.length) {
                    this.suggestionStrip.classList.add('hidden');
                    this.suggestionStrip.innerHTML = '';
                    return;
                }
                this.suggestionStrip.classList.remove('hidden');
                this.suggestionStrip.innerHTML = '';

                if (trending.length) {
                    const group = utils.createEl('div', 'suggestion-group');
                    const header = document.createElement('header');
                    header.textContent = 'Trending Categories';
                    const row = utils.createEl('div', 'suggestion-chip-row');
                    trending.forEach(entry => {
                        const color = entry.category?.accent || 'var(--accent)';
                        const chip = utils.createEl('button', 'suggestion-chip');
                        chip.dataset.accent = color;
                        chip.style.setProperty('--chip-accent', color);
                        chip.style.color = color;
                        chip.innerHTML = `<span class="dot"></span><span>${entry.category?.name || 'Category'}</span>`;
                        chip.title = `${entry.count || 0} launches`;
                        chip.addEventListener('click', () => {
                            if (entry.category?.id) this.focusOnCategory(entry.category.id);
                        });
                        row.appendChild(chip);
                    });
                    group.append(header, row);
                    this.suggestionStrip.appendChild(group);
                }

                if (suggestedMoves.length) {
                    const group = utils.createEl('div', 'suggestion-group');
                    const header = document.createElement('header');
                    header.textContent = 'Suggested Moves';
                    group.appendChild(header);
                    suggestedMoves.forEach(item => {
                        const card = utils.createEl('div', 'suggestion-card');
                        const strong = document.createElement('strong');
                        strong.textContent = item.descriptor?.name || item.appId;
                        const info = document.createElement('p');
                        info.style.margin = '0';
                        const currentName = item.currentCategory?.name || 'Uncategorized';
                        info.textContent = `Frequently opened (${item.usage.count}) · currently in ${currentName}`;
                        const footer = document.createElement('footer');
                        item.suggestions.forEach(category => {
                            const btn = utils.createEl('button', 'primary', { text: category.name });
                            if (category.accent) {
                                btn.style.background = category.accent;
                                btn.style.color = '#fff';
                            }
                            btn.addEventListener('click', () => this.handleSuggestionAssign(item.appId, category.id));
                            footer.appendChild(btn);
                        });
                        const skip = utils.createEl('button', '', { text: 'Dismiss' });
                        skip.addEventListener('click', () => {
                            this.categoryManager.dismissSuggestionsForApp(item.appId);
                            this.renderSuggestions(this.categoryManager.getUsageInsights?.(6));
                        });
                        footer.appendChild(skip);
                        card.append(strong, info, footer);
                        group.appendChild(card);
                    });
                    this.suggestionStrip.appendChild(group);
                }
            }

            handleSuggestionAssign(appId, categoryId) {
                this.categoryManager.assignApp(appId, categoryId);
                this.categoryManager.dismissSuggestionsForApp(appId);
                const descriptor = APP_CATALOG.find(app => app.id === appId);
                const category = this.categoryManager.getCategoryById(categoryId);
                this.notifications?.notify('Start Menu', `${descriptor?.name || 'App'} moved to ${category?.name || 'category'}.`);
                this.render();
            }

            applyWrapperHeight(categoryEl, expanded) {
                const wrapper = categoryEl.querySelector('.start-menu-app-wrapper');
                if (!wrapper) return;
                const grid = wrapper.firstElementChild;
                requestAnimationFrame(() => {
                    if (expanded) {
                        wrapper.style.height = 'auto';
                        const target = grid.getBoundingClientRect().height + 18;
                        wrapper.style.height = '0px';
                        requestAnimationFrame(() => {
                            wrapper.style.height = `${target}px`;
                            wrapper.addEventListener('transitionend', function handler() {
                                wrapper.style.height = 'auto';
                                wrapper.removeEventListener('transitionend', handler);
                            });
                        });
                    } else {
                        const current = grid.getBoundingClientRect().height + 18;
                        wrapper.style.height = `${current}px`;
                        requestAnimationFrame(() => {
                            wrapper.style.height = '0px';
                        });
                    }
                });
            }

            toggleCategory(id, categoryEl) {
                const expanded = categoryEl.getAttribute('aria-expanded') === 'true';
                categoryEl.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                this.applyWrapperHeight(categoryEl, !expanded);
                this.categoryManager.setExpanded(id, !expanded);
            }

            promptCreateCategory() {
                try {
                    const name = prompt('Category name');
                    if (!name) return;
                    const icon = prompt('Category icon (emoji)', '🗂️');
                    const id = this.categoryManager.createCategory(name, icon || '🗂️');
                    this.notifications?.notify('Categories', `${name} created`);
                    this.render();
                    this.focusOnCategory(id);
                } catch (error) {
                    this.notifications?.notify('Categories', error.message || 'Unable to create category');
                }
            }

            focusOnCategory(id) {
                this.categoryManager.expandPath?.(id);
                requestAnimationFrame(() => {
                    const element = this.categoriesEl.querySelector(`[data-category-id="${id}"]`);
                    if (!element) return;
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 600);
                });
            }

            promptEditCategory(id) {
                const category = this.categoryManager.getCategoryById(id);
                if (!category) return;
                const name = prompt('Rename category', category.name);
                if (name && name.trim()) {
                    try {
                        this.categoryManager.renameCategory(id, name);
                        const icon = prompt('Update icon', category.icon || '🗂️');
                        if (icon) this.categoryManager.setCategoryIcon(id, icon);
                        const accent = prompt('Accent color (hex)', category.accent || '#7b8bff');
                        if (accent) this.categoryManager.setCategoryAccent(id, accent);
                        const smartChoice = confirm('Configure smart filters for this category?');
                        if (smartChoice) {
                            const keywords = prompt('Enter comma-separated keywords for auto-categorization', category.filters?.keywords?.join(', ') || '');
                            this.categoryManager.setCategoryFilters(id, keywords || []);
                        }
                        this.notifications?.notify('Categories', 'Category updated');
                    } catch (error) {
                        this.notifications?.notify('Categories', error.message || 'Unable to update category');
                    }
                }
            }

            openManageCategories() {
                if (!this.modals) return;
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '12px';
                const list = document.createElement('div');
                list.style.display = 'flex';
                list.style.flexDirection = 'column';
                list.style.gap = '10px';
                this.categoryManager.listCategories().forEach(category => {
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.gap = '12px';
                    const label = document.createElement('span');
                    label.textContent = `${category.icon || '🗂️'}  ${category.name}`;
                    label.style.flex = '1';
                    row.appendChild(label);
                    const toggleBtn = utils.createEl('button', 'btn-secondary', { text: category.expanded ? 'Collapse' : 'Expand' });
                    toggleBtn.addEventListener('click', () => {
                        this.categoryManager.toggleExpanded(category.id);
                        toggleBtn.textContent = this.categoryManager.getCategoryById(category.id).expanded ? 'Collapse' : 'Expand';
                        this.render();
                    });
                    row.appendChild(toggleBtn);
                    if (category.custom) {
                        const renameBtn = utils.createEl('button', 'btn-secondary', { text: 'Rename' });
                        renameBtn.addEventListener('click', () => {
                            this.modals.close();
                            this.promptEditCategory(category.id);
                        });
                        row.appendChild(renameBtn);
                        const deleteBtn = utils.createEl('button', 'btn-secondary', { text: 'Delete' });
                        deleteBtn.addEventListener('click', () => {
                            if (confirm(`Remove category "${category.name}"? Apps will move to Uncategorized.`)) {
                                try {
                                    this.categoryManager.deleteCategory(category.id);
                                    this.notifications?.notify('Categories', 'Category removed');
                                    this.render();
                                    this.modals.close();
                                } catch (error) {
                                    this.notifications?.notify('Categories', error.message || 'Unable to delete category');
                                }
                            }
                        });
                        row.appendChild(deleteBtn);
                    }
                    list.appendChild(row);
                });
                container.appendChild(list);
                this.modals.open({
                    title: 'Manage Categories',
                    body: container,
                    actions: [{ label: 'Close', primary: true }]
                });
            }

            openApp(appId) {
                this.hide();
                try {
                    this.appManager.open(appId);
                } catch (error) {
                    this.notifications?.notify('Start Menu', error.message || 'Unable to launch app');
                }
            }

            pinApp(appId) {
                if (!this.dockManager) return;
                this.dockManager.pin(appId);
            }

            promptMoveApp(appId) {
                const categories = this.categoryManager.listCategories();
                const options = categories.map(cat => `${cat.icon || '🗂️'} ${cat.name}`).join('\n');
                const choice = prompt(`Move app to category:\n${options}\n\nEnter category name or leave blank to cancel.`);
                if (!choice) return;
                const match = categories.find(cat => cat.name.toLowerCase() === choice.trim().toLowerCase());
                if (!match) {
                    this.notifications?.notify('Categories', 'Category not found');
                    return;
                }
                this.categoryManager.assignApp(appId, match.id);
                this.notifications?.notify('Categories', 'App moved');
                this.render();
            }
        }

        class ShortcutManager {
            constructor(windowManager, appManager, settings) {
                this.windowManager = windowManager;
                this.appManager = appManager;
                this.settings = settings;
                this.register();
            }

            register() {
                document.addEventListener('keydown', event => {
                    if (event.altKey && event.key.toLowerCase() === 'tab') {
                        event.preventDefault();
                        this.windowManager.cycle();
                    }
                    if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.key.toLowerCase() === 'n') {
                        event.preventDefault();
                        this.appManager.open('text-editor');
                    }
                    if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'b') {
                        event.preventDefault();
                        this.appManager.open('browser');
                    }
                    if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.key.toLowerCase() === 'd') {
                        event.preventDefault();
                        this.windowManager.windows.forEach((state, id) => this.windowManager.minimize(id));
                    }
                    if (event.key === 'F11') {
                        event.preventDefault();
                        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                        else document.exitFullscreen();
                    }
                });
            }
        }
        class AppManager {
            constructor(windowManager, fileSystem, notifications, settings, modals, categoryManager = null, permissionManager = null) {
                this.windowManager = windowManager;
                this.fileSystem = fileSystem;
                this.notifications = notifications;
                this.settings = settings;
                this.modals = modals;
                this.registry = new Map();
                this.categoryManager = categoryManager;
                this.dockManager = null;
                this.permissionManager = permissionManager;
            }

            register(id, descriptorOrLoader, options = {}) {
                if (!id) throw new Error('App id is required for registration');
                const baseMeta = APP_CATALOG.find(app => app.id === id) || { id, name: id, icon: '🧩', hint: '' };
                const entry = {
                    id,
                    name: options.name || baseMeta.name || id,
                    icon: options.icon || baseMeta.icon || '🧩',
                    hint: options.hint || baseMeta.hint || '',
                    loader: null,
                    descriptor: null,
                    options: { unloadOnClose: Boolean(options.unloadOnClose) },
                    instances: 0
                };

                if (typeof descriptorOrLoader === 'function') {
                    entry.loader = descriptorOrLoader;
                } else if (descriptorOrLoader && typeof descriptorOrLoader === 'object') {
                    entry.descriptor = descriptorOrLoader;
                    entry.name = descriptorOrLoader.name || entry.name;
                    entry.icon = descriptorOrLoader.icon || entry.icon;
                    entry.hint = descriptorOrLoader.hint || entry.hint;
                } else {
                    throw new Error(`Invalid descriptor for app ${id}`);
                }

                this.registry.set(id, entry);

                if (this.categoryManager) {
                    this.categoryManager.registerDescriptors([{ id: entry.id, name: entry.name, icon: entry.icon, hint: entry.hint }]);
                    if (entry.descriptor) this.categoryManager.registerDescriptors([entry.descriptor]);
                }
            }

            setDockManager(dockManager) {
                this.dockManager = dockManager;
            }

            async open(id, context = {}) {
                const entry = this.registry.get(id);
                if (!entry) throw new Error(`App not registered: ${id}`);

                if (!entry.descriptor && entry.loader) {
                    const loaded = entry.loader();
                    if (!loaded || typeof loaded !== 'object') throw new Error(`App loader for ${id} did not return a descriptor.`);
                    entry.descriptor = loaded;
                    entry.name = loaded.name || entry.name;
                    entry.icon = loaded.icon || entry.icon;
                    entry.hint = loaded.hint || entry.hint;
                    if (this.categoryManager) this.categoryManager.registerDescriptors([loaded]);
                }

                const descriptor = entry.descriptor;
                if (!descriptor) throw new Error(`App descriptor missing for ${id}`);

                if (descriptor.permissions && this.permissionManager) {
                    for (const capability of descriptor.permissions) {
                        const meta = descriptor.permissionMeta?.[capability] || {};
                        const granted = await this.permissionManager.request(id, capability, meta);
                        if (!granted) {
                            this.notifications?.notify(descriptor.name, `Permission denied for ${capability}.`);
                            return null;
                        }
                    }
                }
                const instance = descriptor.launch({
                    context,
                    fileSystem: this.fileSystem,
                    windowManager: this.windowManager,
                    notifications: this.notifications,
                    settings: this.settings,
                    modals: this.modals,
                    permissionManager: this.permissionManager,
                    appManager: this
                });
                const state = this.windowManager.create(id, {
                    title: instance.title || descriptor.name,
                    icon: descriptor.icon,
                    content: instance.element,
                    width: instance.width,
                    height: instance.height,
                    onClose: instance.onClose,
                    onFocus: instance.onFocus,
                    onBlur: instance.onBlur
                });
                instance.onMount?.(state);
                entry.instances = (entry.instances || 0) + 1;
                this.categoryManager?.recordAppUsage?.(id);
                this.dockManager?.handleAppUsage?.(id);
                return state;
            }

            openByFile(path, mime) {
                const ext = utils.ext(path);
                const lowerMime = (mime || '').toLowerCase();
                if (APP_ASSOCIATIONS.text.includes(ext) || lowerMime.startsWith('text')) {
                    this.open('text-editor', { path });
                } else if (APP_ASSOCIATIONS.image.includes(ext) || lowerMime.startsWith('image')) {
                    this.open('image-viewer', { path });
                } else if (APP_ASSOCIATIONS.audio.includes(ext) || APP_ASSOCIATIONS.video.includes(ext) || lowerMime.startsWith('audio') || lowerMime.startsWith('video')) {
                    this.open('media-player', { path });
                } else {
                    this.notifications.notify('Unsupported', `No application associated with ${ext || mime}`);
                }
            }

            listDescriptors() {
                return Array.from(this.registry.values()).map(entry => ({
                    id: entry.id,
                    name: entry.name,
                    icon: entry.icon,
                    hint: entry.hint
                }));
            }

            handleWindowClosed(state) {
                if (!state?.appId) return;
                const entry = this.registry.get(state.appId);
                if (!entry) return;
                entry.instances = Math.max(0, (entry.instances || 0) - 1);
                if (entry.instances === 0 && entry.options?.unloadOnClose && entry.descriptor) {
                    entry.descriptor.onDestroy?.();
                    entry.descriptor = null;
                }
            }
        }
        function createGameMetric(label, initial) {
            const wrapper = utils.createEl('div', 'game-metric');
            const lbl = document.createElement('label');
            lbl.textContent = label;
            lbl.setAttribute('aria-hidden', 'true');
            const value = document.createElement('strong');
            value.textContent = initial;
            wrapper.append(lbl, value);
            return { wrapper, value };
        }

        function createGameOverlay(message = '') {
            const overlay = utils.createEl('div', 'game-overlay');
            overlay.textContent = message;
            overlay.hidden = true;
            return overlay;
        }

        function createCanvasGameApp(config) {
            const {
                id,
                name,
                icon,
                hint = 'Arcade game',
                windowWidth = '980px',
                windowHeight = '720px',
                canvasWidth = 720,
                canvasHeight = 540,
                instructions = [],
                legend = [],
                difficulty = null,
                createGame
            } = config;

            if (typeof createGame !== 'function') {
                throw new Error(`createCanvasGameApp requires createGame factory for ${id}`);
            }

            return {
                id,
                name,
                icon,
                hint,
                launch({ notifications, settings }) {
                    const container = utils.createEl('div', 'game-app');

                    const header = utils.createEl('div', 'game-header');
                    const meta = utils.createEl('div', 'game-meta');
                    const title = document.createElement('h2');
                    title.style.margin = '0';
                    title.style.fontSize = '1.4rem';
                    title.textContent = name;
                    const subtitle = document.createElement('span');
                    subtitle.style.color = 'var(--text-muted)';
                    subtitle.style.fontSize = '0.85rem';
                    subtitle.textContent = hint;
                    meta.append(title, subtitle);

                    const controls = utils.createEl('div', 'game-controls');
                    const startBtn = utils.createEl('button', '', { text: 'Start' });
                    const pauseBtn = utils.createEl('button', '', { text: 'Pause' });
                    pauseBtn.disabled = true;
                    const resetBtn = utils.createEl('button', '', { text: 'Reset' });
                    resetBtn.disabled = true;
                    controls.append(startBtn, pauseBtn, resetBtn);

                    let difficultySelect = null;
                    if (Array.isArray(difficulty) && difficulty.length) {
                        difficultySelect = document.createElement('select');
                        difficultySelect.setAttribute('aria-label', 'Difficulty');
                        difficulty.forEach(level => {
                            const option = document.createElement('option');
                            if (typeof level === 'string') {
                                option.value = level;
                                option.textContent = level;
                            } else {
                                option.value = level.value;
                                option.textContent = level.label;
                            }
                            difficultySelect.appendChild(option);
                        });
                        controls.appendChild(difficultySelect);
                    }

                    header.append(meta, controls);

                    const metricsContainer = utils.createEl('div', 'game-metrics');
                    const metrics = {
                        score: createGameMetric('Score', '0'),
                        level: createGameMetric('Level', '1'),
                        status: createGameMetric('Status', 'Ready'),
                        lives: createGameMetric('Lives', '—')
                    };
                    Object.values(metrics).forEach(metric => metricsContainer.appendChild(metric.wrapper));
                    header.appendChild(metricsContainer);

                    const playfield = utils.createEl('div', 'game-playfield');
                    const canvasWrapper = utils.createEl('div', 'game-canvas-wrapper');
                    const canvas = document.createElement('canvas');
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;
                    canvas.tabIndex = 0;
                    canvasWrapper.appendChild(canvas);
                    const overlay = createGameOverlay();
                    canvasWrapper.appendChild(overlay);

                    const infoPanel = utils.createEl('aside', 'game-info-panel');
                    if (instructions.length) {
                        const instructionsHeader = document.createElement('h3');
                        instructionsHeader.textContent = 'How to Play';
                        const instructionsList = document.createElement('ul');
                        instructionsList.className = 'game-legend';
                        instructions.forEach(item => {
                            const li = document.createElement('li');
                            li.textContent = item;
                            instructionsList.appendChild(li);
                        });
                        infoPanel.append(instructionsHeader, instructionsList);
                    }

                    if (legend.length) {
                        const legendHeader = document.createElement('h3');
                        legendHeader.textContent = 'Legend';
                        const legendList = document.createElement('ul');
                        legendList.className = 'game-legend';
                        legend.forEach(entry => {
                            const li = document.createElement('li');
                            const swatch = document.createElement('span');
                            swatch.style.background = entry.color;
                            li.appendChild(swatch);
                            li.append(entry.label);
                            legendList.appendChild(li);
                        });
                        infoPanel.append(legendHeader, legendList);
                    }

                    const logHeader = document.createElement('h3');
                    logHeader.textContent = 'Activity';
                    const log = utils.createEl('div', 'game-log');
                    log.setAttribute('role', 'log');
                    log.setAttribute('aria-live', 'polite');
                    log.textContent = 'Game log will appear here.';
                    infoPanel.append(logHeader, log);

                    playfield.append(canvasWrapper, infoPanel);
                    container.append(header, playfield);

                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const metricState = { score: 0, level: 1, status: 'Ready', lives: '—' };
                    const setMetric = (key, value) => {
                        metricState[key] = value;
                        const formatted = typeof value === 'number' ? value.toString() : value;
                        metrics[key].value.textContent = formatted;
                    };
                    const addLog = message => {
                        const entry = document.createElement('div');
                        entry.textContent = message;
                        log.appendChild(entry);
                        while (log.childElementCount > 40) {
                            log.removeChild(log.firstElementChild);
                        }
                        log.scrollTop = log.scrollHeight;
                    };

                    let running = false;
                    let paused = false;
                    let destroyed = false;
                    let frameHandle = null;
                    let lastTimestamp = 0;
                    let gameInstance = null;

                    const showOverlay = message => {
                        overlay.textContent = message;
                        overlay.hidden = false;
                    };

                    const hideOverlay = () => {
                        overlay.hidden = true;
                    };

                    const stopLoop = () => {
                        if (frameHandle) cancelAnimationFrame(frameHandle);
                        frameHandle = null;
                    };

                    const loop = timestamp => {
                        if (!running || destroyed) return;
                        const delta = Math.min((timestamp - lastTimestamp) / 1000 || 0, 0.05);
                        lastTimestamp = timestamp;
                        if (!paused && typeof gameInstance?.update === 'function') {
                            gameInstance.update(delta, timestamp);
                        }
                        if (typeof gameInstance?.render === 'function') {
                            gameInstance.render(ctx, timestamp);
                        }
                        frameHandle = requestAnimationFrame(loop);
                    };

                    const endGame = message => {
                        running = false;
                        paused = false;
                        stopLoop();
                        showOverlay(message || 'Game Over');
                        pauseBtn.disabled = true;
                        pauseBtn.textContent = 'Pause';
                        resetBtn.disabled = false;
                        startBtn.disabled = false;
                        setMetric('status', message || 'Stopped');
                        addLog(message || 'Game ended.');
                    };

                    const baseApi = {
                        canvas,
                        ctx,
                        settings,
                        notifications,
                        setScore(value) {
                            const numeric = Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
                            setMetric('score', numeric);
                        },
                        addScore(delta) {
                            const next = Math.max(0, Math.floor(metricState.score + (delta || 0)));
                            setMetric('score', next);
                        },
                        setLevel(value) {
                            const numeric = Number.isFinite(value) ? value : metricState.level;
                            setMetric('level', numeric);
                        },
                        setLives(value) {
                            setMetric('lives', value);
                        },
                        setStatus(value) {
                            setMetric('status', value);
                        },
                        log: addLog,
                        overlay: {
                            show: showOverlay,
                            hide: hideOverlay
                        },
                        gameOver: endGame,
                        resetMetrics() {
                            setMetric('score', 0);
                            setMetric('level', 1);
                            setMetric('status', 'Ready');
                            setMetric('lives', '—');
                        }
                    };

                    const resetBoard = () => {
                        stopLoop();
                        running = false;
                        paused = false;
                        pauseBtn.textContent = 'Pause';
                        pauseBtn.disabled = true;
                        startBtn.disabled = false;
                        canvas.focus({ preventScroll: true });
                        hideOverlay();
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        baseApi.resetMetrics();
                        addLog('Board reset.');
                        if (gameInstance?.destroy) gameInstance.destroy();
                        const configValue = difficultySelect ? difficultySelect.value : null;
                        gameInstance = createGame({
                            ...baseApi,
                            difficulty: configValue,
                            width: canvas.width,
                            height: canvas.height,
                            notify: message => notifications?.notify(name, message)
                        });
                        if (typeof gameInstance?.init === 'function') {
                            gameInstance.init();
                        }
                        if (typeof gameInstance?.render === 'function') {
                            gameInstance.render(ctx, performance.now());
                        }
                    };

                    const startGame = () => {
                        if (!gameInstance) resetBoard();
                        running = true;
                        paused = false;
                        hideOverlay();
                        pauseBtn.disabled = false;
                        resetBtn.disabled = false;
                        startBtn.disabled = true;
                        setMetric('status', 'Running');
                        lastTimestamp = performance.now();
                        if (typeof gameInstance?.start === 'function') {
                            gameInstance.start();
                        }
                        stopLoop();
                        frameHandle = requestAnimationFrame(loop);
                        addLog('Game started.');
                    };

                    const togglePause = () => {
                        if (!running) return;
                        paused = !paused;
                        if (paused) {
                            showOverlay('Paused');
                            pauseBtn.textContent = 'Resume';
                            setMetric('status', 'Paused');
                            addLog('Game paused.');
                        } else {
                            hideOverlay();
                            pauseBtn.textContent = 'Pause';
                            setMetric('status', 'Running');
                            addLog('Game resumed.');
                        }
                    };

                    startBtn.addEventListener('click', startGame);
                    pauseBtn.addEventListener('click', togglePause);
                    resetBtn.addEventListener('click', () => {
                        resetBoard();
                        addLog('New game ready.');
                    });

                    if (difficultySelect) {
                        difficultySelect.addEventListener('change', () => {
                            resetBoard();
                            addLog(`Difficulty set to ${difficultySelect.value}.`);
                        });
                    }

                    const handleKeyDown = event => {
                        if (destroyed) return;
                        if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                        if (event.key === ' ' && !event.repeat) {
                            if (!running) {
                                startGame();
                            } else {
                                togglePause();
                            }
                            event.preventDefault();
                            return;
                        }
                        if (event.key === 'Escape' && running) {
                            togglePause();
                            event.preventDefault();
                            return;
                        }
                        if (!gameInstance?.handleKeyDown) return;
                        const handled = gameInstance.handleKeyDown(event, { running, paused });
                        if (handled) event.preventDefault();
                    };

                    const handleKeyUp = event => {
                        if (!gameInstance?.handleKeyUp || destroyed) return;
                        const handled = gameInstance.handleKeyUp(event, { running, paused });
                        if (handled) event.preventDefault();
                    };

                    const pointerHandler = type => event => {
                        if (!gameInstance?.handlePointer || destroyed) return;
                        gameInstance.handlePointer(type, event, { running, paused });
                    };

                    const pointerHandlers = {
                        down: pointerHandler('down'),
                        move: pointerHandler('move'),
                        up: pointerHandler('up'),
                        cancel: pointerHandler('cancel')
                    };

                    window.addEventListener('keydown', handleKeyDown);
                    window.addEventListener('keyup', handleKeyUp);
                    canvas.addEventListener('pointerdown', pointerHandlers.down);
                    canvas.addEventListener('pointermove', pointerHandlers.move);
                    canvas.addEventListener('pointerup', pointerHandlers.up);
                    canvas.addEventListener('pointercancel', pointerHandlers.cancel);

                    resetBoard();

                    return {
                        element: container,
                        width: windowWidth,
                        height: windowHeight,
                        onClose: () => {
                            destroyed = true;
                            stopLoop();
                            window.removeEventListener('keydown', handleKeyDown);
                            window.removeEventListener('keyup', handleKeyUp);
                            canvas.removeEventListener('pointerdown', pointerHandlers.down);
                            canvas.removeEventListener('pointermove', pointerHandlers.move);
                            canvas.removeEventListener('pointerup', pointerHandlers.up);
                            canvas.removeEventListener('pointercancel', pointerHandlers.cancel);
                            if (gameInstance?.destroy) gameInstance.destroy();
                        }
                    };
                }
            };
        }

        function createFileManagerApp(desktopManager) {
            const VIEW_STORAGE_KEY = 'webos.fileManager.view';
            const normalizeView = value => (value === 'list' || value === 'grid') ? value : 'grid';
            const entryIcon = entry => {
                if (entry.type === 'directory') return '📁';
                const mime = (entry.mime || '').toLowerCase();
                if (mime.startsWith('image')) return '🖼️';
                if (mime.startsWith('audio')) return '🎵';
                if (mime.startsWith('video')) return '🎬';
                if (mime.includes('pdf')) return '📄';
                if (mime.includes('zip') || mime.includes('compressed')) return '🗜️';
                if (mime.includes('text') || mime.includes('json')) return '📄';
                return '📦';
            };

            return {
                id: 'file-manager',
                name: 'File Manager',
                icon: '📂',
                launch({ context = {}, fileSystem, notifications, appManager }) {
                    const initialView = (() => {
                        try { return scopedStorage.get(VIEW_STORAGE_KEY) || 'grid'; }
                        catch { return 'grid'; }
                    })();
                    const state = {
                        currentPath: context.path || '/Documents',
                        viewMode: normalizeView(context.viewMode || initialView),
                        selection: new Set(),
                        searchTerm: '',
                        clipboard: null,
                        selectMode: typeof context.selectMode === 'function' ? context.selectMode : null
                    };

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    const actionButtons = [
                        { label: '⬆️ Up', action: 'up' },
                        { label: '➕ File', action: 'new-file' },
                        { label: '📁 Folder', action: 'new-folder' },
                        { label: '⬆️ Upload', action: 'upload' },
                        { label: '📋 Copy', action: 'copy' },
                        { label: '✂️ Cut', action: 'cut' },
                        { label: '📥 Paste', action: 'paste' },
                        { label: '✏️ Rename', action: 'rename' },
                        { label: '🗑️ Delete', action: 'delete' }
                    ];
                    actionButtons.forEach(def => {
                        const button = utils.createEl('button', '', { type: 'button' });
                        button.textContent = def.label;
                        button.dataset.action = def.action;
                        toolbar.appendChild(button);
                    });
                    const spacer = document.createElement('div');
                    spacer.style.flex = '1';
                    spacer.style.minWidth = '12px';
                    toolbar.appendChild(spacer);
                    const viewToggle = utils.createEl('div', 'file-view-toggle');
                    viewToggle.innerHTML = '<button data-view="grid" title="Grid view">▥</button><button data-view="list" title="List view">≣</button>';
                    toolbar.appendChild(viewToggle);
                    const searchInput = utils.createEl('input', '', { type: 'search', placeholder: 'Search files', 'aria-label': 'Search files' });
                    searchInput.style.minWidth = '180px';
                    searchInput.style.marginLeft = '12px';
                    toolbar.appendChild(searchInput);
                    const uploadInput = utils.createEl('input', '', { type: 'file', multiple: 'true', style: 'display:none' });

                    const layout = utils.createEl('div', 'file-explorer');
                    const treePane = utils.createEl('section', 'file-tree');
                    const contentPane = utils.createEl('section', 'file-list');
                    const previewPane = utils.createEl('section', 'file-preview');
                    previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                    layout.append(treePane, contentPane, previewPane);
                    shell.append(toolbar, layout, uploadInput);

                    const updateViewButtons = () => {
                        viewToggle.querySelectorAll('button').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.view === state.viewMode);
                        });
                    };

                    const setViewMode = mode => {
                        const next = normalizeView(mode);
                        if (next === state.viewMode) {
                            updateViewButtons();
                            return;
                        }
                        state.viewMode = next;
                        try { scopedStorage.set(VIEW_STORAGE_KEY, next); } catch {}
                        updateViewButtons();
                        renderContent();
                    };

                    const listEntries = () => {
                        const term = state.searchTerm;
                        const entries = fileSystem.listDirectory(state.currentPath);
                        if (!term) return entries;
                        return entries.filter(entry => entry.name.toLowerCase().includes(term));
                    };

                    const renderBreadcrumb = container => {
                        container.innerHTML = '';
                        const rootBtn = document.createElement('button');
                        rootBtn.textContent = 'Root';
                        rootBtn.addEventListener('click', () => {
                            if (state.currentPath === '/') return;
                            state.currentPath = '/';
                            state.selection.clear();
                            renderTree();
                            renderContent();
                        });
                        container.appendChild(rootBtn);
                        const segments = utils.normalize(state.currentPath).split('/').filter(Boolean);
                        let accumulator = '';
                        segments.forEach(segment => {
                            accumulator += `/${segment}`;
                            const separator = document.createElement('span');
                            separator.textContent = '›';
                            container.appendChild(separator);
                            const button = document.createElement('button');
                            button.textContent = segment;
                            const path = accumulator;
                            button.addEventListener('click', () => {
                                if (state.currentPath === path) return;
                                state.currentPath = path;
                                state.selection.clear();
                                renderTree();
                                renderContent();
                            });
                            container.appendChild(button);
                        });
                    };

                    const handleSelection = (path, event) => {
                        if (event && (event.shiftKey || event.metaKey || event.ctrlKey)) {
                            if (state.selection.has(path)) state.selection.delete(path); else state.selection.add(path);
                        } else {
                            state.selection.clear();
                            state.selection.add(path);
                        }
                        updateSelectionHighlights();
                        renderPreview();
                    };

                    const openEntry = entry => {
                        if (entry.type === 'directory') {
                            state.currentPath = entry.path;
                            state.selection.clear();
                            renderTree();
                            renderContent();
                            return;
                        }
                        if (state.selectMode) {
                            state.selectMode(entry.path);
                            state.selection.clear();
                            return;
                        }
                        appManager.openByFile(entry.path, entry.mime);
                    };

                    const renderGrid = entries => {
                        if (!entries.length) {
                            const empty = utils.createEl('div', 'preview-card');
                            empty.innerHTML = '<strong>No items</strong><div class="preview-body">Try creating or uploading something new.</div>';
                            contentPane.appendChild(empty);
                            return;
                        }
                        const grid = utils.createEl('div', 'file-grid');
                        entries.forEach(entry => {
                            const card = utils.createEl('div', 'file-card');
                            card.dataset.path = entry.path;
                            const icon = utils.createEl('div', 'file-card-icon', { text: entryIcon(entry) });
                            const name = document.createElement('strong');
                            name.textContent = entry.name;
                            const meta = utils.createEl('div', 'file-card-meta');
                            meta.innerHTML = `
                                <span>${entry.type === 'directory' ? 'Folder' : entry.mime || 'File'}</span>
                                <span>${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size || 0)} · ${utils.humanDate(entry.updatedAt)}</span>
                            `;
                            card.append(icon, name, meta);
                            card.addEventListener('click', event => handleSelection(entry.path, event));
                            card.addEventListener('dblclick', () => openEntry(entry));
                            grid.appendChild(card);
                        });
                        contentPane.appendChild(grid);
                    };

                    const renderListView = entries => {
                        if (!entries.length) {
                            const empty = utils.createEl('div', 'preview-card');
                            empty.innerHTML = '<strong>No items</strong><div class="preview-body">Use the toolbar to add files or folders.</div>';
                            contentPane.appendChild(empty);
                            return;
                        }
                        const table = utils.createEl('table', 'file-table');
                        table.innerHTML = '<thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th></tr></thead><tbody></tbody>';
                        const tbody = table.querySelector('tbody');
                        entries.forEach(entry => {
                            const row = utils.createEl('tr', 'file-row');
                            row.dataset.path = entry.path;
                            row.innerHTML = `
                                <td>${entry.name}</td>
                                <td>${entry.type === 'directory' ? 'Folder' : entry.mime || 'File'}</td>
                                <td>${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size || 0)}</td>
                                <td>${utils.humanDate(entry.updatedAt)}</td>
                            `;
                            row.addEventListener('click', event => handleSelection(entry.path, event));
                            row.addEventListener('dblclick', () => openEntry(entry));
                            tbody.appendChild(row);
                        });
                        contentPane.appendChild(table);
                    };

                    const updateSelectionHighlights = () => {
                        contentPane.querySelectorAll('[data-path]').forEach(el => {
                            el.classList.toggle('active', state.selection.has(el.dataset.path));
                        });
                    };

                    const renderPreview = () => {
                        const first = [...state.selection][0];
                        if (!first) {
                            previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                            return;
                        }
                        try {
                            const { entry } = fileSystem.resolve(first);
                            if (!entry) throw new Error('Item not found');
                            const card = utils.createEl('div', 'preview-card');
                            const header = document.createElement('div');
                            header.innerHTML = `
                                <strong>${entry.name}</strong>
                                <div>${entry.type === 'directory' ? 'Folder' : entry.mime || 'File'} · ${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size || 0)}</div>
                                <div>${utils.humanDate(entry.updatedAt)}</div>
                            `;
                            const body = utils.createEl('div', 'preview-body');
                            if (entry.type === 'file') {
                                if (entry.mime?.startsWith('text')) {
                                    body.textContent = fileSystem.readFile(first);
                                } else if (entry.mime?.startsWith('image')) {
                                    const img = new Image();
                                    img.src = `data:${entry.mime};base64,${entry.data}`;
                                    body.appendChild(img);
                                } else {
                                    body.textContent = 'Preview not available for this file type.';
                                }
                            } else {
                                const children = Object.keys(entry.children || {});
                                body.innerHTML = `<strong>${children.length}</strong> item${children.length === 1 ? '' : 's'} inside.`;
                            }
                            card.append(header, body);
                            previewPane.innerHTML = '';
                            previewPane.appendChild(card);
                        } catch (error) {
                            previewPane.innerHTML = `<div class="preview-card"><strong>Error</strong><div class="preview-body">${error.message}</div></div>`;
                        }
                    };

                    const renderContent = () => {
                        contentPane.innerHTML = '';
                        const entries = listEntries();
                        const header = document.createElement('div');
                        header.style.display = 'flex';
                        header.style.alignItems = 'center';
                        header.style.gap = '12px';
                        header.style.marginBottom = '12px';
                        const breadcrumb = utils.createEl('div', 'file-breadcrumb');
                        breadcrumb.style.flex = '1';
                        renderBreadcrumb(breadcrumb);
                        const count = document.createElement('span');
                        count.style.fontSize = '0.75rem';
                        count.style.color = 'var(--text-muted)';
                        count.textContent = `${entries.length} item${entries.length === 1 ? '' : 's'}`;
                        header.append(breadcrumb, count);
                        contentPane.appendChild(header);
                        if (state.viewMode === 'grid') renderGrid(entries); else renderListView(entries);
                        updateSelectionHighlights();
                        renderPreview();
                    };

                    const renderTree = () => {
                        treePane.innerHTML = '';
                        const rootItem = utils.createEl('div', 'tree-item', { text: 'Root' });
                        rootItem.dataset.path = '/';
                        if (state.currentPath === '/') rootItem.classList.add('active');
                        rootItem.addEventListener('click', () => {
                            state.currentPath = '/';
                            state.selection.clear();
                            renderTree();
                            renderContent();
                        });
                        treePane.appendChild(rootItem);
                        const walk = (path, depth) => {
                            fileSystem.listDirectory(path).filter(entry => entry.type === 'directory').forEach(entry => {
                                const item = utils.createEl('div', 'tree-item', { text: `${' '.repeat(depth * 2)}${entry.name}` });
                                item.dataset.path = entry.path;
                                if (entry.path === state.currentPath) item.classList.add('active');
                                item.addEventListener('click', () => {
                                    state.currentPath = entry.path;
                                    state.selection.clear();
                                    renderTree();
                                    renderContent();
                                });
                                treePane.appendChild(item);
                                walk(entry.path, depth + 1);
                            });
                        };
                        walk('/', 0);
                    };

                    toolbar.addEventListener('click', event => {
                        const button = event.target.closest('button[data-action]');
                        if (!button) return;
                        const action = button.dataset.action;
                        try {
                            switch (action) {
                                case 'up':
                                    if (state.currentPath !== '/') {
                                        state.currentPath = utils.dirname(state.currentPath);
                                        state.selection.clear();
                                        renderTree();
                                        renderContent();
                                    }
                                    break;
                                case 'new-file': {
                                    const name = prompt('File name', 'Untitled.txt');
                                    if (!name) break;
                                    fileSystem.createFile(utils.join(state.currentPath, name), '');
                                    renderContent();
                                    break;
                                }
                                case 'new-folder': {
                                    const name = prompt('Folder name', 'New Folder');
                                    if (!name) break;
                                    fileSystem.createDirectory(utils.join(state.currentPath, name));
                                    renderTree();
                                    renderContent();
                                    break;
                                }
                                case 'upload':
                                    uploadInput.click();
                                    break;
                                case 'copy':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'copy', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'copy');
                                    notifications.notify('Copied', `${state.selection.size} item(s) ready to paste`);
                                    break;
                                case 'cut':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'cut', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'cut');
                                    notifications.notify('Cut', `${state.selection.size} item(s) ready to move`);
                                    break;
                                case 'paste':
                                    if (state.clipboard) {
                                        state.clipboard.paths.forEach(path => {
                                            if (state.clipboard.mode === 'copy') fileSystem.copy(path, state.currentPath);
                                            else if (state.clipboard.mode === 'cut') fileSystem.move(path, state.currentPath);
                                        });
                                        if (state.clipboard.mode === 'cut') state.clipboard = null;
                                        renderTree();
                                        renderContent();
                                        break;
                                    }
                                    desktopManager?.pasteClipboard(state.currentPath);
                                    renderTree();
                                    renderContent();
                                    break;
                                case 'rename': {
                                    if (state.selection.size !== 1) break;
                                    const path = [...state.selection][0];
                                    const currentName = path.split('/').pop();
                                    const name = prompt('Rename to', currentName);
                                    if (!name || name === currentName) break;
                                    fileSystem.rename(path, name);
                                    state.selection.clear();
                                    renderTree();
                                    renderContent();
                                    break;
                                }
                                case 'delete':
                                    if (!state.selection.size) break;
                                    if (!confirm(`Delete ${state.selection.size} item(s)?`)) break;
                                    [...state.selection].forEach(path => fileSystem.delete(path));
                                    state.selection.clear();
                                    renderTree();
                                    renderContent();
                                    break;
                            }
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    });

                    viewToggle.addEventListener('click', event => {
                        const button = event.target.closest('button[data-view]');
                        if (!button) return;
                        setViewMode(button.dataset.view);
                    });

                    searchInput.addEventListener('input', utils.debounce(event => {
                        state.searchTerm = (event.target.value || '').trim().toLowerCase();
                        renderContent();
                    }, 160));

                    uploadInput.addEventListener('change', () => {
                        const files = Array.from(uploadInput.files || []);
                        if (!files.length) return;
                        Promise.all(files.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${files.length} file(s) uploaded`);
                            uploadInput.value = '';
                            renderContent();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    contentPane.addEventListener('dragover', event => event.preventDefault());
                    contentPane.addEventListener('drop', event => {
                        event.preventDefault();
                        const items = event.dataTransfer?.items;
                        if (!items) return;
                        const uploads = [];
                        for (const item of items) if (item.kind === 'file') uploads.push(item.getAsFile());
                        if (!uploads.length) return;
                        Promise.all(uploads.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${uploads.length} file(s) uploaded`);
                            renderContent();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    renderTree();
                    renderContent();
                    updateViewButtons();

                    const unsubscribeFs = fileSystem.on('change', () => {
                        renderTree();
                        renderContent();
                    });

                    return {
                        element: shell,
                        width: '980px',
                        height: '620px',
                        onClose: () => unsubscribeFs?.()
                    };
                }
            };
        }

        function createToastSearcherApp(desktopManager) {
            return {
                id: 'toastsearcher',
                name: 'ToastSearcher',
                icon: '🍞',
                launch({ context, fileSystem, notifications, appManager }) {
                    const state = {
                        currentPath: context.path || '/Documents',
                        selection: new Set(),
                        clipboard: null,
                        searchTerm: '',
                        selectMode: context.selectMode || null
                    };

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="up">⬆️ Up</button>
                        <button data-action="new-file">➕ File</button>
                        <button data-action="new-folder">📁 Folder</button>
                        <button data-action="upload">⬆️ Upload</button>
                        <button data-action="copy">📋 Copy</button>
                        <button data-action="cut">✂️ Cut</button>
                        <button data-action="paste">📥 Paste</button>
                        <button data-action="rename">✏️ Rename</button>
                        <button data-action="delete">🗑️ Delete</button>
                        <label for="toastsearcher-search" class="visually-hidden">Search files</label>
                        <input id="toastsearcher-search" name="toastsearcher-search" type="search" placeholder="Search" style="margin-left:auto; min-width:180px;" />
                    `;
                    const searchInput = toolbar.querySelector('#toastsearcher-search');
                    const uploadInput = utils.createEl('input', '', { type: 'file', style: 'display:none', multiple: 'true' });
                    const layout = utils.createEl('div', 'file-explorer');
                    const treePane = utils.createEl('section', 'file-tree');
                    const listPane = utils.createEl('section', 'file-list');
                    const previewPane = utils.createEl('section', 'file-preview');
                    previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                    layout.append(treePane, listPane, previewPane);
                    shell.append(toolbar, layout, uploadInput);

                    function renderTree() {
                        treePane.innerHTML = '';
                        const walk = (path, level = 0) => {
                            const entries = fileSystem.listDirectory(path);
                            entries.filter(entry => entry.type === 'directory').forEach(entry => {
                                const item = utils.createEl('div', 'tree-item', { text: `${' '.repeat(level * 2)}${entry.name}` });
                                item.dataset.path = entry.path;
                                if (entry.path === state.currentPath) item.classList.add('active');
                                item.addEventListener('click', () => {
                                    state.currentPath = entry.path;
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                });
                                treePane.appendChild(item);
                                walk(entry.path, level + 1);
                            });
                        };
                        fileSystem.listDirectory('/').filter(entry => entry.type === 'directory').forEach(entry => {
                            const rootItem = utils.createEl('div', 'tree-item', { text: entry.name });
                            rootItem.dataset.path = entry.path;
                            if (entry.path === state.currentPath) rootItem.classList.add('active');
                            rootItem.addEventListener('click', () => {
                                state.currentPath = entry.path;
                                state.selection.clear();
                                renderList();
                                renderTree();
                            });
                            treePane.appendChild(rootItem);
                            walk(entry.path, 1);
                        });
                    }

                    function renderList() {
                        listPane.innerHTML = '';
                        const table = utils.createEl('table', 'file-table');
                        table.innerHTML = '<thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th></tr></thead><tbody></tbody>';
                        const tbody = table.querySelector('tbody');
                        const entries = fileSystem.listDirectory(state.currentPath).filter(entry => entry.name.toLowerCase().includes(state.searchTerm));
                        entries.forEach(entry => {
                            const row = utils.createEl('tr', 'file-row');
                            row.dataset.path = entry.path;
                            row.dataset.type = entry.type;
                            row.innerHTML = `
                                <td>${entry.name}</td>
                                <td>${entry.type === 'directory' ? 'Folder' : entry.mime}</td>
                                <td>${entry.type === 'directory' ? '--' : utils.formatBytes(entry.size)}</td>
                                <td>${utils.humanDate(entry.updatedAt)}</td>
                            `;
                            row.addEventListener('click', event => {
                                if (event.shiftKey || event.metaKey || event.ctrlKey) {
                                    if (state.selection.has(entry.path)) state.selection.delete(entry.path); else state.selection.add(entry.path);
                                } else {
                                    state.selection.clear();
                                    state.selection.add(entry.path);
                                }
                                updateSelection();
                            });
                            row.addEventListener('dblclick', () => {
                                if (entry.type === 'directory') {
                                    state.currentPath = entry.path;
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                } else if (state.selectMode) {
                                    state.selectMode(entry.path);
                                    state.selection.clear();
                                } else {
                                    appManager.openByFile(entry.path, entry.mime);
                                }
                            });
                            tbody.appendChild(row);
                        });
                        listPane.appendChild(table);
                        updateSelection();
                    }

                    function updateSelection() {
                        listPane.querySelectorAll('.file-row').forEach(row => {
                            row.classList.toggle('active', state.selection.has(row.dataset.path));
                        });
                        const first = [...state.selection][0];
                        if (!first) {
                            previewPane.innerHTML = '<div class="preview-card"><strong>No selection</strong><div class="preview-body">Select a file to preview.</div></div>';
                            return;
                        }
                        try {
                            const meta = fileSystem.readFileMeta(first);
                            const card = utils.createEl('div', 'preview-card');
                            card.innerHTML = `
                                <div>
                                    <strong>${meta.name}</strong>
                                    <div>${meta.mime || 'Unknown'} · ${utils.formatBytes(meta.size || 0)}</div>
                                    <div>${utils.humanDate(meta.updatedAt)}</div>
                                </div>
                                <div class="preview-body"></div>
                            `;
                            const body = card.querySelector('.preview-body');
                            if (meta.mime?.startsWith('text')) {
                                body.textContent = fileSystem.readFile(first);
                            } else if (meta.mime?.startsWith('image')) {
                                const img = new Image();
                                img.src = `data:${meta.mime};base64,${meta.data}`;
                                body.appendChild(img);
                            } else {
                                body.textContent = 'Preview not available for this file type.';
                            }
                            previewPane.innerHTML = '';
                            previewPane.appendChild(card);
                        } catch (error) {
                            previewPane.innerHTML = `<div class="preview-card"><strong>Error</strong><div class="preview-body">${error.message}</div></div>`;
                        }
                    }

                    toolbar.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const action = button.dataset.action;
                        try {
                            switch (action) {
                                case 'up':
                                    if (state.currentPath !== '/') {
                                        state.currentPath = utils.dirname(state.currentPath);
                                        renderList();
                                        renderTree();
                                    }
                                    break;
                                case 'new-file': {
                                    const name = prompt('File name', 'Untitled.txt');
                                    if (!name) break;
                                    fileSystem.createFile(utils.join(state.currentPath, name), '');
                                    renderList();
                                    break;
                                }
                                case 'new-folder': {
                                    const name = prompt('Folder name', 'New Folder');
                                    if (!name) break;
                                    fileSystem.createDirectory(utils.join(state.currentPath, name));
                                    renderList();
                                    renderTree();
                                    break;
                                }
                                case 'upload':
                                    uploadInput.click();
                                    break;
                                case 'copy':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'copy', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'copy');
                                    notifications.notify('Copied', `${state.selection.size} item(s) ready to paste`);
                                    break;
                                case 'cut':
                                    if (!state.selection.size) break;
                                    state.clipboard = { mode: 'cut', paths: [...state.selection] };
                                    desktopManager?.setClipboard?.([...state.selection], 'cut');
                                    notifications.notify('Cut', `${state.selection.size} item(s) ready to move`);
                                    break;
                                case 'paste':
                                    if (state.clipboard) {
                                        state.clipboard.paths.forEach(path => {
                                            if (state.clipboard.mode === 'copy') fileSystem.copy(path, state.currentPath);
                                            if (state.clipboard.mode === 'cut') fileSystem.move(path, state.currentPath);
                                        });
                                        if (state.clipboard.mode === 'cut') state.clipboard = null;
                                        renderList();
                                        renderTree();
                                        break;
                                    }
                                    desktopManager?.pasteClipboard(state.currentPath);
                                    renderList();
                                    renderTree();
                                    break;
                                case 'rename': {
                                    if (state.selection.size !== 1) break;
                                    const path = [...state.selection][0];
                                    const currentName = path.split('/').pop();
                                    const name = prompt('Rename to', currentName);
                                    if (!name) break;
                                    fileSystem.rename(path, name);
                                    state.selection = new Set([utils.join(utils.dirname(path), name)]);
                                    renderList();
                                    renderTree();
                                    break;
                                }
                                case 'delete':
                                    if (!state.selection.size) break;
                                    if (!confirm(`Delete ${state.selection.size} item(s)?`)) break;
                                    state.selection.forEach(path => fileSystem.delete(path));
                                    state.selection.clear();
                                    renderList();
                                    renderTree();
                                    break;
                            }
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    });

                    searchInput.addEventListener('input', utils.debounce(event => {
                        state.searchTerm = event.target.value.toLowerCase();
                        renderList();
                    }, 160));

                    uploadInput.addEventListener('change', () => {
                        const files = Array.from(uploadInput.files || []);
                        Promise.all(files.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${files.length} file(s) uploaded`);
                            uploadInput.value = '';
                            renderList();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    listPane.addEventListener('dragover', event => event.preventDefault());
                    listPane.addEventListener('drop', event => {
                        event.preventDefault();
                        const items = event.dataTransfer?.items;
                        if (!items) return;
                        const uploads = [];
                        for (const item of items) if (item.kind === 'file') uploads.push(item.getAsFile());
                        Promise.all(uploads.map(file => file.arrayBuffer().then(buffer => {
                            fileSystem.createFile(utils.join(state.currentPath, file.name), new Uint8Array(buffer), { mime: file.type });
                        }))).then(() => {
                            notifications.notify('Upload complete', `${uploads.length} file(s) uploaded`);
                            renderList();
                        }).catch(error => notifications.notify('Upload failed', error.message));
                    });

                    renderTree();
                    renderList();

                    return {
                        element: shell,
                        title: `ToastSearcher — ${state.currentPath}`,
                        width: '940px',
                        height: '600px',
                        onFocus: win => {
                            win.element.querySelector('.window-title span:last-child').textContent = `ToastSearcher — ${state.currentPath}`;
                        }
                    };
                }
            };
        }

        function createCalendarApp() {
            const STORAGE_KEY = STORAGE_KEYS.CALENDAR_EVENTS;
            const WEEKDAY_LABELS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const toDateKey = date => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            const parseDateKey = key => {
                if (!key) return new Date();
                const [year, month, day] = key.split('-').map(Number);
                if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return new Date();
                return new Date(year, month - 1, day);
            };
            const eventKey = event => `${event.date || ''}T${event.time || '00:00'}`;
            const parseDateTime = event => {
                if (!event?.date) return null;
                const [year, month, day] = event.date.split('-').map(Number);
                if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;
                const [hour, minute] = (event.time || '00:00').split(':').map(Number);
                return new Date(year, month - 1, day, Number.isFinite(hour) ? hour : 0, Number.isFinite(minute) ? minute : 0);
            };
            const loadEvents = () => {
                try {
                    const raw = JSON.parse(scopedStorage.get(STORAGE_KEY) || '[]');
                    if (!Array.isArray(raw)) return [];
                    return raw.map(item => ({
                        id: item.id || utils.uuid(),
                        title: item.title || 'Untitled event',
                        date: item.date || toDateKey(new Date()),
                        time: item.time || '09:00',
                        reminderMinutes: Number.isFinite(Number(item.reminderMinutes)) ? Number(item.reminderMinutes) : 0,
                        description: item.description || '',
                        createdAt: item.createdAt || utils.nowISO(),
                        updatedAt: item.updatedAt || item.createdAt || utils.nowISO(),
                        lastReminderAt: item.lastReminderAt || null
                    }));
                } catch (error) {
                    console.warn('Failed to load calendar events', error);
                    return [];
                }
            };
            const formatEventLabel = (event, includeDate = false) => {
                const dt = parseDateTime(event);
                if (!dt) return event.time || event.date;
                const timePart = dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                if (!includeDate) return timePart;
                return `${dt.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} · ${timePart}`;
            };

            return {
                id: 'calendar',
                name: 'Agenda Planner',
                icon: '📆',
                hint: 'Schedule events & reminders',
                launch({ notifications, modals, context = {} }) {
                    const now = new Date();
                    const state = {
                        viewDate: context.date ? parseDateKey(context.date) : new Date(now.getFullYear(), now.getMonth(), 1),
                        selectedDate: context.date || toDateKey(now),
                        events: loadEvents()
                    };
                    if (Number.isNaN(state.viewDate.getTime())) state.viewDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    state.selectedDate = state.selectedDate || toDateKey(state.viewDate);

                    const container = utils.createEl('div', 'calendar-app');
                    const toolbar = utils.createEl('div', 'calendar-toolbar');
                    const prevBtn = utils.createEl('button', '', { type: 'button', title: 'Previous month' });
                    prevBtn.textContent = '◀';
                    const nextBtn = utils.createEl('button', '', { type: 'button', title: 'Next month' });
                    nextBtn.textContent = '▶';
                    const monthLabel = document.createElement('h2');
                    const spacer = utils.createEl('div', 'spacer');
                    const todayBtn = utils.createEl('button', '', { type: 'button', title: 'Jump to today' });
                    todayBtn.textContent = 'Today';
                    const addBtn = utils.createEl('button', '', { type: 'button', title: 'Add event' });
                    addBtn.textContent = '➕ Event';
                    toolbar.append(prevBtn, nextBtn, monthLabel, spacer, todayBtn, addBtn);

                    const body = utils.createEl('div', 'calendar-body');
                    const monthContainer = utils.createEl('div', 'calendar-month');
                    const weekdayRow = utils.createEl('div', 'calendar-weekday-row');
                    WEEKDAY_LABELS.forEach(label => {
                        const span = document.createElement('span');
                        span.textContent = label;
                        weekdayRow.appendChild(span);
                    });
                    const grid = utils.createEl('div', 'calendar-grid');
                    monthContainer.append(weekdayRow, grid);
                    const sidebar = utils.createEl('aside', 'calendar-sidebar');
                    body.append(monthContainer, sidebar);
                    container.append(toolbar, body);

                    const getEventsForDate = key => state.events.filter(event => event.date === key);
                    const persistEvents = (message = null) => {
                        state.events.sort((a, b) => eventKey(a).localeCompare(eventKey(b)));
                        try { scopedStorage.set(STORAGE_KEY, JSON.stringify(state.events)); } catch {}
                        if (message) notifications?.notify('Calendar', message);
                    };

                    const renderSidebar = () => {
                        sidebar.innerHTML = '';
                        const selectedSection = utils.createEl('div', 'calendar-section');
                        const selectedHeading = document.createElement('h3');
                        const selectedDateObj = parseDateKey(state.selectedDate);
                        selectedHeading.textContent = selectedDateObj.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' });
                        selectedSection.appendChild(selectedHeading);
                        const selectedEvents = getEventsForDate(state.selectedDate);
                        if (selectedEvents.length) {
                            const list = utils.createEl('ul', 'calendar-upcoming');
                            selectedEvents.forEach(event => {
                                const li = document.createElement('li');
                                const title = document.createElement('strong');
                                title.textContent = event.title;
                                const meta = document.createElement('span');
                                meta.textContent = formatEventLabel(event, false);
                                li.append(title, meta);
                                if (event.description) {
                                    const desc = document.createElement('span');
                                    desc.textContent = event.description;
                                    desc.style.opacity = '0.75';
                                    li.appendChild(desc);
                                }
                                li.addEventListener('click', () => openEventModal(event));
                                list.appendChild(li);
                            });
                            selectedSection.appendChild(list);
                        } else {
                            selectedSection.appendChild(utils.createEl('div', 'calendar-empty', { text: 'No events scheduled.' }));
                        }

                        const upcomingSection = utils.createEl('div', 'calendar-section');
                        const upcomingHeading = document.createElement('h3');
                        upcomingHeading.textContent = 'Upcoming';
                        upcomingSection.appendChild(upcomingHeading);
                        const nowTs = Date.now();
                        const upcoming = state.events
                            .map(event => ({ event, date: parseDateTime(event) }))
                            .filter(item => item.date && item.date.getTime() >= nowTs)
                            .sort((a, b) => a.date.getTime() - b.date.getTime())
                            .slice(0, 6);
                        if (upcoming.length) {
                            const list = utils.createEl('ul', 'calendar-upcoming');
                            upcoming.forEach(({ event, date }) => {
                                const li = document.createElement('li');
                                const title = document.createElement('strong');
                                title.textContent = event.title;
                                const meta = document.createElement('span');
                                meta.textContent = date.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                                li.append(title, meta);
                                if (event.description) {
                                    const desc = document.createElement('span');
                                    desc.textContent = event.description;
                                    desc.style.opacity = '0.75';
                                    li.appendChild(desc);
                                }
                                li.addEventListener('click', () => openEventModal(event));
                                list.appendChild(li);
                            });
                            upcomingSection.appendChild(list);
                        } else {
                            upcomingSection.appendChild(utils.createEl('div', 'calendar-empty', { text: 'Nothing on the horizon.' }));
                        }

                        sidebar.append(selectedSection, upcomingSection);
                    };

                    const renderCalendar = () => {
                        monthLabel.textContent = state.viewDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
                        grid.innerHTML = '';
                        const firstOfMonth = new Date(state.viewDate.getFullYear(), state.viewDate.getMonth(), 1);
                        const startOffset = firstOfMonth.getDay();
                        const firstCell = new Date(firstOfMonth);
                        firstCell.setDate(firstCell.getDate() - startOffset);
                        for (let index = 0; index < 42; index += 1) {
                            const cellDate = new Date(firstCell);
                            cellDate.setDate(firstCell.getDate() + index);
                            const dateKey = toDateKey(cellDate);
                            const cell = utils.createEl('div', 'calendar-cell');
                            if (cellDate.getMonth() !== state.viewDate.getMonth()) cell.classList.add('outside');
                            if (dateKey === toDateKey(new Date())) cell.classList.add('today');
                            if (dateKey === state.selectedDate) cell.classList.add('selected');
                            const header = document.createElement('header');
                            const number = document.createElement('span');
                            number.textContent = String(cellDate.getDate());
                            const indicator = document.createElement('span');
                            const dayEvents = getEventsForDate(dateKey);
                            indicator.textContent = dayEvents.length ? '●' : '';
                            indicator.style.color = 'var(--accent)';
                            indicator.style.fontSize = '0.65rem';
                            header.append(number, indicator);
                            cell.appendChild(header);
                            const stack = utils.createEl('div', 'calendar-events');
                            dayEvents.slice(0, 3).forEach(event => {
                                const pill = utils.createEl('div', 'calendar-event');
                                pill.dataset.past = parseDateTime(event)?.getTime() < Date.now() ? 'true' : 'false';
                                pill.textContent = `${event.time ? `${event.time} ` : ''}${event.title}`.trim();
                                pill.addEventListener('click', evt => {
                                    evt.stopPropagation();
                                    openEventModal(event);
                                });
                                stack.appendChild(pill);
                            });
                            if (dayEvents.length > 3) {
                                stack.appendChild(utils.createEl('div', 'calendar-more', { text: `+${dayEvents.length - 3} more` }));
                            }
                            cell.appendChild(stack);
                            cell.addEventListener('click', () => {
                                state.selectedDate = dateKey;
                                renderCalendar();
                            });
                            cell.addEventListener('dblclick', () => openEventModal(null, dateKey));
                            grid.appendChild(cell);
                        }
                        renderSidebar();
                    };

                    const openEventModal = (event = null, defaultDate = null) => {
                        const isEditing = Boolean(event);
                        const wrapper = document.createElement('div');
                        wrapper.style.display = 'flex';
                        wrapper.style.flexDirection = 'column';
                        wrapper.style.gap = '12px';

                        const buildField = (labelText, input) => {
                            const block = document.createElement('label');
                            block.style.display = 'flex';
                            block.style.flexDirection = 'column';
                            block.style.gap = '6px';
                            const span = document.createElement('span');
                            span.textContent = labelText;
                            span.style.fontSize = '0.82rem';
                            span.style.color = 'var(--text-muted)';
                            block.append(span, input);
                            return block;
                        };

                        const titleField = utils.createEl('input', '', { type: 'text', placeholder: 'Title', value: event?.title || '' });
                        titleField.required = true;
                        const dateField = utils.createEl('input', '', { type: 'date', value: event?.date || defaultDate || state.selectedDate || toDateKey(new Date()) });
                        dateField.required = true;
                        const timeField = utils.createEl('input', '', { type: 'time', value: event?.time || '09:00' });
                        timeField.required = true;
                        const reminderField = document.createElement('select');
                        [
                            { label: 'No reminder', value: 0 },
                            { label: '5 minutes before', value: 5 },
                            { label: '10 minutes before', value: 10 },
                            { label: '15 minutes before', value: 15 },
                            { label: '30 minutes before', value: 30 },
                            { label: '1 hour before', value: 60 },
                            { label: '1 day before', value: 1440 }
                        ].forEach(option => {
                            const opt = document.createElement('option');
                            opt.value = String(option.value);
                            opt.textContent = option.label;
                            reminderField.appendChild(opt);
                        });
                        reminderField.value = String(event?.reminderMinutes ?? 15);

                        const descriptionField = document.createElement('textarea');
                        descriptionField.placeholder = 'Notes';
                        descriptionField.rows = 3;
                        descriptionField.value = event?.description || '';

                        wrapper.append(
                            buildField('Title', titleField),
                            buildField('Date', dateField),
                            buildField('Time', timeField),
                            buildField('Reminder', reminderField),
                            buildField('Description', descriptionField)
                        );

                        const saveEvent = () => {
                            const title = titleField.value.trim();
                            if (!title) {
                                notifications?.notify('Calendar', 'Title is required');
                                return false;
                            }
                            if (!dateField.value) {
                                notifications?.notify('Calendar', 'Date is required');
                                return false;
                            }
                            if (!timeField.value) {
                                notifications?.notify('Calendar', 'Time is required');
                                return false;
                            }
                            const payload = {
                                ...(event || { id: utils.uuid(), createdAt: utils.nowISO(), lastReminderAt: null }),
                                title,
                                date: dateField.value,
                                time: timeField.value,
                                reminderMinutes: Number(reminderField.value) || 0,
                                description: descriptionField.value.trim(),
                                updatedAt: utils.nowISO()
                            };
                            if (event && (event.date !== payload.date || event.time !== payload.time)) {
                                payload.lastReminderAt = null;
                            }
                            if (event) {
                                const index = state.events.findIndex(item => item.id === event.id);
                                if (index >= 0) state.events[index] = payload;
                                persistEvents('Event updated');
                            } else {
                                state.events.push(payload);
                                persistEvents('Event added');
                            }
                            state.selectedDate = payload.date;
                            renderCalendar();
                            checkReminders();
                            return true;
                        };

                        const actions = [];
                        if (event) {
                            actions.push({
                                label: 'Delete',
                                onClick: () => {
                                    if (!confirm('Delete this event?')) return false;
                                    state.events = state.events.filter(item => item.id !== event.id);
                                    persistEvents('Event removed');
                                    renderCalendar();
                                    return true;
                                }
                            });
                        }
                        actions.push({ label: 'Cancel', onClick: () => true });
                        actions.push({ label: event ? 'Save' : 'Create', primary: true, onClick: saveEvent });

                        modals.open({
                            title: event ? 'Edit Event' : 'New Event',
                            body: wrapper,
                            actions
                        });
                    };

                    const changeMonth = offset => {
                        state.viewDate = new Date(state.viewDate.getFullYear(), state.viewDate.getMonth() + offset, 1);
                        renderCalendar();
                    };

                    prevBtn.addEventListener('click', () => changeMonth(-1));
                    nextBtn.addEventListener('click', () => changeMonth(1));
                    todayBtn.addEventListener('click', () => {
                        const today = new Date();
                        state.viewDate = new Date(today.getFullYear(), today.getMonth(), 1);
                        state.selectedDate = toDateKey(today);
                        renderCalendar();
                    });
                    addBtn.addEventListener('click', () => openEventModal(null, state.selectedDate || toDateKey(new Date())));

                    const checkReminders = () => {
                        const nowTs = Date.now();
                        let dirty = false;
                        state.events.forEach(event => {
                            if (!event.reminderMinutes) return;
                            const dt = parseDateTime(event);
                            if (!dt) return;
                            const eventTs = dt.getTime();
                            const reminderTs = eventTs - event.reminderMinutes * 60_000;
                            if (nowTs >= reminderTs && nowTs < eventTs) {
                                const last = event.lastReminderAt ? new Date(event.lastReminderAt).getTime() : 0;
                                if (!last || (nowTs - last) > 60_000) {
                                    notifications?.notify('Calendar', `${event.title} at ${dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`);
                                    event.lastReminderAt = new Date().toISOString();
                                    dirty = true;
                                }
                            }
                        });
                        if (dirty) persistEvents();
                    };

                    renderCalendar();
                    const reminderInterval = setInterval(checkReminders, 60_000);
                    checkReminders();

                    return {
                        element: container,
                        width: '980px',
                        height: '640px',
                        onClose: () => clearInterval(reminderInterval)
                    };
                }
            };
        }

        function createEmailClientApp() {
            const STORAGE_KEY = STORAGE_KEYS.EMAIL_STATE;
            const FOLDERS = [
                { id: 'inbox', label: 'Inbox', icon: '📥' },
                { id: 'sent', label: 'Sent', icon: '📤' },
                { id: 'drafts', label: 'Drafts', icon: '📝' },
                { id: 'archive', label: 'Archive', icon: '🗂️' }
            ];

            const cleanAccount = source => {
                const base = {
                    id: source?.id || utils.uuid(),
                    label: source?.label || source?.email || 'Mail Account',
                    email: source?.email || '',
                    signature: source?.signature || '',
                    incoming: {
                        protocol: source?.incoming?.protocol || 'IMAP',
                        host: source?.incoming?.host || '',
                        port: Number(source?.incoming?.port) || 993,
                        security: source?.incoming?.security || 'SSL/TLS',
                        username: source?.incoming?.username || source?.email || '',
                        password: source?.incoming?.password || ''
                    },
                    outgoing: {
                        host: source?.outgoing?.host || '',
                        port: Number(source?.outgoing?.port) || 587,
                        security: source?.outgoing?.security || 'STARTTLS',
                        username: source?.outgoing?.username || source?.email || '',
                        password: source?.outgoing?.password || ''
                    },
                    folders: {},
                    lastSync: source?.lastSync || null
                };
                FOLDERS.forEach(folder => {
                    const messages = Array.isArray(source?.folders?.[folder.id]) ? source.folders[folder.id] : [];
                    base.folders[folder.id] = messages.map(message => ({
                        id: message.id || utils.uuid(),
                        subject: message.subject || '(No subject)',
                        from: message.from || '',
                        to: message.to || '',
                        date: message.date || utils.nowISO(),
                        unread: message.unread !== undefined ? Boolean(message.unread) : true,
                        snippet: message.snippet || '',
                        body: message.body || ''
                    }));
                });
                return base;
            };

            const loadState = () => {
                const defaultState = {
                    accounts: [],
                    selectedAccountId: null,
                    selectedFolder: 'inbox',
                    selectedMessageId: null,
                    composeDraft: null
                };
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                    return {
                        accounts: Array.isArray(raw.accounts) ? raw.accounts.map(cleanAccount) : [],
                        selectedAccountId: raw.selectedAccountId || null,
                        selectedFolder: raw.selectedFolder || 'inbox',
                        selectedMessageId: raw.selectedMessageId || null,
                        composeDraft: raw.composeDraft || null
                    };
                } catch (error) {
                    console.warn('Failed to load mail state', error);
                    return defaultState;
                }
            };

            const createMessage = (account, overrides = {}) => ({
                id: overrides.id || utils.uuid(),
                subject: overrides.subject || '(No subject)',
                from: overrides.from || 'system@example.com',
                to: overrides.to || account.email,
                date: overrides.date || utils.nowISO(),
                unread: overrides.unread !== undefined ? overrides.unread : true,
                snippet: overrides.snippet || (overrides.body ? overrides.body.slice(0, 96) : ''),
                body: overrides.body || ''
            });

            const createDemoAccount = () => {
                const account = cleanAccount({
                    id: utils.uuid(),
                    label: 'Demo Account',
                    email: 'demo@example.com',
                    incoming: {
                        protocol: 'IMAP',
                        host: 'imap.example.com',
                        port: 993,
                        security: 'SSL/TLS',
                        username: 'demo@example.com',
                        password: ''
                    },
                    outgoing: {
                        host: 'smtp.example.com',
                        port: 587,
                        security: 'STARTTLS',
                        username: 'demo@example.com',
                        password: ''
                    }
                });
                account.folders.inbox.unshift(
                    createMessage(account, {
                        subject: 'Welcome to Mail Center',
                        from: 'webos@example.com',
                        body: 'Hi there!\n\nThis is a simulated inbox so you can explore the Mail Center without configuring a real account. Use the Compose button to draft a message or tap Sync to generate additional sample mail.\n\n— WebOS Team'
                    }),
                    createMessage(account, {
                        subject: 'Your POP3 & IMAP settings',
                        from: 'support@example.com',
                        body: 'Incoming (IMAP): imap.example.com : 993 (SSL)\nIncoming (POP3): pop.example.com : 995 (SSL)\nOutgoing (SMTP): smtp.example.com : 587 (STARTTLS)\n\nFeel free to adapt these placeholders to your provider. This app stores credentials locally only.'
                    })
                );
                account.lastSync = utils.nowISO();
                return account;
            };

            return {
                id: 'email',
                name: 'Mail Center',
                icon: '✉️',
                hint: 'Read & send mail',
                launch({ notifications, modals }) {
                    const state = loadState();
                    let viewMode = state.composeDraft ? 'compose' : 'preview';

                    if (!state.accounts.length) {
                        const demo = createDemoAccount();
                        state.accounts.push(demo);
                        state.selectedAccountId = demo.id;
                        state.selectedFolder = 'inbox';
                        state.selectedMessageId = demo.folders.inbox[0]?.id || null;
                    }

                    const saveState = (message = null) => {
                        const snapshot = {
                            accounts: state.accounts,
                            selectedAccountId: state.selectedAccountId,
                            selectedFolder: state.selectedFolder,
                            selectedMessageId: state.selectedMessageId,
                            composeDraft: state.composeDraft
                        };
                        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot)); } catch {}
                        if (message) notifications?.notify('Mail Center', message);
                    };

                    const currentAccount = () => state.accounts.find(account => account.id === state.selectedAccountId) || state.accounts[0] || null;

                    const ensureSelection = () => {
                        let account = currentAccount();
                        if (!account) {
                            state.selectedAccountId = null;
                            state.selectedMessageId = null;
                            return;
                        }
                        state.selectedAccountId = account.id;
                        if (!state.selectedFolder) state.selectedFolder = 'inbox';
                        const folder = account.folders[state.selectedFolder] || [];
                        if (!folder.some(message => message.id === state.selectedMessageId)) {
                            state.selectedMessageId = folder[0]?.id || null;
                        }
                    };

                    ensureSelection();

                    const container = utils.createEl('div', 'mail-app');
                    const toolbar = utils.createEl('div', 'mail-toolbar');
                    const syncBtn = utils.createEl('button', '', { type: 'button', title: 'Fetch new mail' });
                    syncBtn.textContent = '🔄 Sync';
                    const composeBtn = utils.createEl('button', '', { type: 'button', title: 'Compose message' });
                    composeBtn.textContent = '✉️ Compose';
                    const spacer = utils.createEl('div', 'spacer');
                    const addAccountBtn = utils.createEl('button', '', { type: 'button', title: 'Add account' });
                    addAccountBtn.textContent = '➕ Account';
                    toolbar.append(syncBtn, composeBtn, spacer, addAccountBtn);

                    const layout = utils.createEl('div', 'mail-layout');
                    const accountPane = utils.createEl('div', 'mail-pane');
                    const accountHeader = document.createElement('header');
                    accountHeader.style.display = 'flex';
                    accountHeader.style.justifyContent = 'space-between';
                    accountHeader.style.alignItems = 'center';
                    const accountTitle = document.createElement('strong');
                    accountTitle.textContent = 'Accounts';
                    const manageBtn = utils.createEl('button', '', { type: 'button', title: 'Manage accounts' });
                    manageBtn.textContent = '⚙️';
                    manageBtn.style.background = 'transparent';
                    manageBtn.style.border = 'none';
                    manageBtn.style.cursor = 'pointer';
                    accountHeader.append(accountTitle, manageBtn);
                    const accountList = utils.createEl('ul', 'mail-accounts');
                    const folderHeading = document.createElement('h3');
                    folderHeading.textContent = 'Folders';
                    folderHeading.style.margin = '4px 0 0';
                    const folderList = utils.createEl('div', 'mail-folder-list');
                    accountPane.append(accountHeader, accountList, folderHeading, folderList);

                    const messagePane = utils.createEl('div', 'mail-pane');
                    const messageHeader = document.createElement('header');
                    messageHeader.style.display = 'flex';
                    messageHeader.style.justifyContent = 'space-between';
                    messageHeader.style.alignItems = 'center';
                    const folderLabel = document.createElement('strong');
                    const messageMeta = document.createElement('span');
                    messageMeta.style.fontSize = '0.75rem';
                    messageMeta.style.color = 'var(--text-muted)';
                    messageHeader.append(folderLabel, messageMeta);
                    const messageList = utils.createEl('div', 'mail-message-list');
                    messagePane.append(messageHeader, messageList);

                    const detailPane = utils.createEl('div', 'mail-pane');

                    layout.append(accountPane, messagePane, detailPane);
                    container.append(toolbar, layout);

                    const openAccountModal = (account = null) => {
                        const isEdit = Boolean(account);
                        const data = isEdit ? JSON.parse(JSON.stringify(account)) : cleanAccount({ label: '', email: '' });
                        const form = document.createElement('div');
                        form.style.display = 'flex';
                        form.style.flexDirection = 'column';
                        form.style.gap = '12px';

                        const makeField = (label, input) => {
                            const wrapper = document.createElement('label');
                            wrapper.style.display = 'flex';
                            wrapper.style.flexDirection = 'column';
                            wrapper.style.gap = '4px';
                            const span = document.createElement('span');
                            span.textContent = label;
                            span.style.fontSize = '0.82rem';
                            span.style.color = 'var(--text-muted)';
                            wrapper.append(span, input);
                            return wrapper;
                        };

                        const nameField = utils.createEl('input', '', { type: 'text', value: data.label, placeholder: 'Display name' });
                        const emailField = utils.createEl('input', '', { type: 'email', value: data.email, placeholder: 'Email address' });
                        const protocolField = document.createElement('select');
                        ['IMAP', 'POP3'].forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            if (value === data.incoming.protocol) option.selected = true;
                            protocolField.appendChild(option);
                        });
                        const incomingHostField = utils.createEl('input', '', { type: 'text', value: data.incoming.host, placeholder: 'Incoming server host' });
                        const incomingPortField = utils.createEl('input', '', { type: 'number', value: String(data.incoming.port), placeholder: 'Port' });
                        const incomingSecurityField = document.createElement('select');
                        ['None', 'SSL/TLS', 'STARTTLS'].forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            if (value === data.incoming.security) option.selected = true;
                            incomingSecurityField.appendChild(option);
                        });
                        const incomingUserField = utils.createEl('input', '', { type: 'text', value: data.incoming.username, placeholder: 'Incoming username' });
                        const incomingPassField = utils.createEl('input', '', { type: 'password', value: data.incoming.password, placeholder: 'Incoming password' });
                        const outgoingHostField = utils.createEl('input', '', { type: 'text', value: data.outgoing.host, placeholder: 'SMTP server host' });
                        const outgoingPortField = utils.createEl('input', '', { type: 'number', value: String(data.outgoing.port), placeholder: 'Port' });
                        const outgoingSecurityField = document.createElement('select');
                        ['None', 'SSL/TLS', 'STARTTLS'].forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            if (value === data.outgoing.security) option.selected = true;
                            outgoingSecurityField.appendChild(option);
                        });
                        const outgoingUserField = utils.createEl('input', '', { type: 'text', value: data.outgoing.username, placeholder: 'SMTP username' });
                        const outgoingPassField = utils.createEl('input', '', { type: 'password', value: data.outgoing.password, placeholder: 'SMTP password' });
                        const signatureField = document.createElement('textarea');
                        signatureField.placeholder = 'Signature (optional)';
                        signatureField.rows = 3;
                        signatureField.value = data.signature || '';

                        form.append(
                            makeField('Display name', nameField),
                            makeField('Email address', emailField),
                            makeField('Incoming protocol', protocolField),
                            makeField('Incoming server', incomingHostField),
                            makeField('Incoming port', incomingPortField),
                            makeField('Incoming security', incomingSecurityField),
                            makeField('Incoming username', incomingUserField),
                            makeField('Incoming password', incomingPassField),
                            makeField('Outgoing server', outgoingHostField),
                            makeField('Outgoing port', outgoingPortField),
                            makeField('Outgoing security', outgoingSecurityField),
                            makeField('Outgoing username', outgoingUserField),
                            makeField('Outgoing password', outgoingPassField),
                            makeField('Signature', signatureField)
                        );

                        const applyChanges = () => {
                            const email = emailField.value.trim();
                            if (!email) {
                                notifications?.notify('Mail Center', 'Email address is required');
                                return false;
                            }
                            const payload = cleanAccount({
                                id: data.id,
                                label: nameField.value.trim() || email,
                                email,
                                signature: signatureField.value,
                                incoming: {
                                    protocol: protocolField.value,
                                    host: incomingHostField.value.trim(),
                                    port: Number(incomingPortField.value) || (protocolField.value === 'IMAP' ? 993 : 995),
                                    security: incomingSecurityField.value,
                                    username: incomingUserField.value.trim(),
                                    password: incomingPassField.value
                                },
                                outgoing: {
                                    host: outgoingHostField.value.trim(),
                                    port: Number(outgoingPortField.value) || 587,
                                    security: outgoingSecurityField.value,
                                    username: outgoingUserField.value.trim(),
                                    password: outgoingPassField.value
                                },
                                folders: data.folders,
                                lastSync: data.lastSync
                            });

                            if (isEdit) {
                                const index = state.accounts.findIndex(item => item.id === payload.id);
                                if (index >= 0) {
                                    // Preserve existing folders
                                    FOLDERS.forEach(folder => {
                                        payload.folders[folder.id] = state.accounts[index].folders[folder.id];
                                    });
                                    state.accounts[index] = payload;
                                }
                                state.selectedAccountId = payload.id;
                                saveState('Account updated');
                                renderAll();
                                return true;
                            }

                            FOLDERS.forEach(folder => {
                                if (!Array.isArray(payload.folders[folder.id])) payload.folders[folder.id] = [];
                            });
                            payload.folders.inbox.unshift(createMessage(payload, {
                                subject: 'Account connected',
                                from: 'welcome@example.com',
                                body: `Hello ${payload.label || payload.email},\n\nYour account has been added to Mail Center. Use Sync to simulate downloading messages or compose to draft a message.`,
                                unread: true
                            }));
                            state.accounts.push(payload);
                            state.selectedAccountId = payload.id;
                            state.selectedFolder = 'inbox';
                            state.selectedMessageId = payload.folders.inbox[0]?.id || null;
                            saveState('Account added');
                            renderAll();
                            return true;
                        };

                        const actions = [];
                        if (isEdit && state.accounts.length > 1) {
                            actions.push({
                                label: 'Remove',
                                onClick: () => {
                                    if (!confirm('Remove this account?')) return false;
                                    state.accounts = state.accounts.filter(item => item.id !== account.id);
                                    state.selectedAccountId = state.accounts[0]?.id || null;
                                    state.selectedMessageId = null;
                                    ensureSelection();
                                    saveState('Account removed');
                                    renderAll();
                                    return true;
                                }
                            });
                        }
                        actions.push({ label: 'Cancel', onClick: () => true });
                        actions.push({ label: isEdit ? 'Save' : 'Add Account', primary: true, onClick: applyChanges });

                        modals.open({
                            title: isEdit ? 'Edit Account' : 'Add Account',
                            body: form,
                            actions
                        });
                    };

                    manageBtn.addEventListener('click', () => {
                        const account = currentAccount();
                        if (!account) { openAccountModal(); return; }
                        openAccountModal(account);
                    });

                    addAccountBtn.addEventListener('click', () => openAccountModal());

                    const simulateFetch = account => {
                        const message = createMessage(account, {
                            subject: `Update ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`,
                            from: 'newsletter@example.com',
                            body: `Hello ${account.label || account.email},\n\nThis is a simulated message fetched via the Sync button. Replace this logic with real POP3/IMAP polling when integrating your provider.\n\nThanks for testing!`,
                            unread: true
                        });
                        account.folders.inbox.unshift(message);
                        account.lastSync = utils.nowISO();
                        state.selectedMessageId = state.selectedFolder === 'inbox' ? message.id : state.selectedMessageId;
                        saveState('Inbox updated');
                        renderFolders();
                        renderMessages();
                        if (state.selectedFolder === 'inbox') renderDetail();
                    };

                    const openCompose = (draft = null) => {
                        const account = currentAccount();
                        if (!account) {
                            notifications?.notify('Mail Center', 'Add an account first');
                            return;
                        }
                        state.composeDraft = draft || {
                            accountId: account.id,
                            draftId: null,
                            to: '',
                            subject: '',
                            body: ''
                        };
                        viewMode = 'compose';
                        renderDetail();
                        saveState();
                    };

                    syncBtn.addEventListener('click', () => {
                        const account = currentAccount();
                        if (!account) {
                            notifications?.notify('Mail Center', 'Add an account to sync');
                            return;
                        }
                        simulateFetch(account);
                    });

                    composeBtn.addEventListener('click', () => openCompose());

                    const renderAccounts = () => {
                        accountList.innerHTML = '';
                        state.accounts.forEach(account => {
                            const item = document.createElement('li');
                            item.classList.toggle('active', account.id === state.selectedAccountId);
                            const topRow = document.createElement('div');
                            topRow.style.display = 'flex';
                            topRow.style.justifyContent = 'space-between';
                            topRow.style.gap = '8px';
                            const name = document.createElement('strong');
                            name.textContent = account.label || account.email;
                            const edit = utils.createEl('button', '', { type: 'button', title: 'Edit account' });
                            edit.textContent = '✏️';
                            edit.style.background = 'transparent';
                            edit.style.border = 'none';
                            edit.style.cursor = 'pointer';
                            edit.addEventListener('click', event => {
                                event.stopPropagation();
                                openAccountModal(account);
                            });
                            topRow.append(name, edit);
                            const emailLine = document.createElement('span');
                            emailLine.textContent = account.email;
                            emailLine.style.fontSize = '0.75rem';
                            emailLine.style.color = 'var(--text-muted)';
                            const syncInfo = document.createElement('span');
                            syncInfo.textContent = account.lastSync ? `Last sync ${utils.relativeTime(account.lastSync)}` : 'Never synced';
                            syncInfo.style.fontSize = '0.7rem';
                            syncInfo.style.color = 'var(--text-muted)';
                            item.append(topRow, emailLine, syncInfo);
                            item.addEventListener('click', () => {
                                state.selectedAccountId = account.id;
                                state.selectedMessageId = null;
                                viewMode = 'preview';
                                ensureSelection();
                                saveState();
                                renderAll();
                            });
                            accountList.appendChild(item);
                        });
                    };

                    const renderFolders = () => {
                        folderList.innerHTML = '';
                        const account = currentAccount();
                        if (!account) {
                            folderList.appendChild(utils.createEl('div', 'mail-empty', { text: 'No accounts configured.' }));
                            return;
                        }
                        FOLDERS.forEach(folder => {
                            const button = document.createElement('button');
                            button.type = 'button';
                            const total = account.folders[folder.id]?.length || 0;
                            const unread = account.folders[folder.id]?.filter(message => message.unread).length || 0;
                            button.textContent = `${folder.icon} ${folder.label}${unread ? ` (${unread})` : ''}`;
                            button.classList.toggle('active', folder.id === state.selectedFolder);
                            button.addEventListener('click', () => {
                                state.selectedFolder = folder.id;
                                state.selectedMessageId = null;
                                viewMode = 'preview';
                                ensureSelection();
                                saveState();
                                renderMessages();
                                renderDetail();
                            });
                            folderList.appendChild(button);
                        });
                    };

                    const renderMessages = () => {
                        messageList.innerHTML = '';
                        const account = currentAccount();
                        if (!account) {
                            messageList.appendChild(utils.createEl('div', 'mail-empty', { text: 'Add an account to see messages.' }));
                            return;
                        }
                        const folder = FOLDERS.find(entry => entry.id === state.selectedFolder) || FOLDERS[0];
                        folderLabel.textContent = folder.label;
                        const messages = [...(account.folders[state.selectedFolder] || [])].sort((a, b) => new Date(b.date) - new Date(a.date));
                        messageMeta.textContent = messages.length ? `${messages.length} message${messages.length === 1 ? '' : 's'}` : 'No messages';
                        if (!messages.length) {
                            messageList.appendChild(utils.createEl('div', 'mail-empty', { text: 'Folder is empty.' }));
                            return;
                        }
                        messages.forEach(message => {
                            const card = utils.createEl('div', 'mail-message');
                            card.dataset.id = message.id;
                            if (message.unread) card.classList.add('unread');
                            if (message.id === state.selectedMessageId) card.classList.add('active');
                            const subject = document.createElement('strong');
                            subject.textContent = message.subject || '(No subject)';
                            const meta = utils.createEl('div', 'meta');
                            const from = document.createElement('span');
                            from.textContent = message.from || '(unknown sender)';
                            const when = document.createElement('span');
                            when.textContent = new Date(message.date).toLocaleString(undefined, { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                            meta.append(from, when);
                            const snippet = utils.createEl('div', 'snippet');
                            snippet.textContent = message.snippet || message.body.slice(0, 96);
                            card.append(subject, meta, snippet);
                            card.addEventListener('click', () => {
                                state.selectedMessageId = message.id;
                                message.unread = false;
                                viewMode = 'preview';
                                saveState();
                                renderMessages();
                                renderDetail();
                            });
                            messageList.appendChild(card);
                        });
                    };

                    const renderDetail = () => {
                        detailPane.innerHTML = '';
                        const account = currentAccount();
                        if (!account) {
                            detailPane.appendChild(utils.createEl('div', 'mail-empty', { text: 'Select or add an account.' }));
                            return;
                        }
                        if (viewMode === 'compose') {
                            renderComposeView(account);
                            return;
                        }

                        const messages = account.folders[state.selectedFolder] || [];
                        const message = messages.find(item => item.id === state.selectedMessageId);
                        if (!message) {
                            detailPane.appendChild(utils.createEl('div', 'mail-empty', { text: 'Select a message to read.' }));
                            return;
                        }
                        message.unread = false;
                        const header = document.createElement('header');
                        const subject = document.createElement('strong');
                        subject.textContent = message.subject || '(No subject)';
                        const fromLine = document.createElement('span');
                        fromLine.textContent = `From: ${message.from}`;
                        const toLine = document.createElement('span');
                        const toValue = Array.isArray(message.to) ? message.to.join(', ') : message.to || account.email;
                        toLine.textContent = `To: ${toValue}`;
                        const timeLine = document.createElement('span');
                        timeLine.textContent = new Date(message.date).toLocaleString();
                        timeLine.style.fontSize = '0.75rem';
                        timeLine.style.color = 'var(--text-muted)';
                        header.append(subject, fromLine, toLine, timeLine);
                        const body = document.createElement('article');
                        body.textContent = message.body || '(No content)';
                        const footer = document.createElement('footer');
                        footer.style.display = 'flex';
                        footer.style.gap = '10px';
                        footer.style.flexWrap = 'wrap';

                        if (state.selectedFolder === 'drafts') {
                            const editBtn = utils.createEl('button', '', { type: 'button', text: '✏️ Edit Draft' });
                            editBtn.addEventListener('click', () => {
                                openCompose({
                                    accountId: account.id,
                                    draftId: message.id,
                                    to: Array.isArray(message.to) ? message.to.join(', ') : message.to || '',
                                    subject: message.subject || '',
                                    body: message.body || ''
                                });
                            });
                            const discardBtn = utils.createEl('button', '', { type: 'button', text: '🗑 Discard' });
                            discardBtn.addEventListener('click', () => {
                                account.folders.drafts = account.folders.drafts.filter(item => item.id !== message.id);
                                state.selectedMessageId = null;
                                saveState('Draft discarded');
                                renderFolders();
                                renderMessages();
                                renderDetail();
                            });
                            footer.append(editBtn, discardBtn);
                        } else {
                            const replyBtn = utils.createEl('button', '', { type: 'button', text: '↩ Reply' });
                            replyBtn.addEventListener('click', () => {
                                openCompose({
                                    accountId: account.id,
                                    draftId: null,
                                    to: message.from || '',
                                    subject: message.subject && !message.subject.toLowerCase().startsWith('re:') ? `Re: ${message.subject}` : message.subject || 'Re:',
                                    body: `\n\n--- original message ---\n${message.body}`
                                });
                            });
                            const markBtn = utils.createEl('button', '', { type: 'button', text: message.unread ? 'Mark read' : 'Mark unread' });
                            markBtn.addEventListener('click', () => {
                                message.unread = !message.unread;
                                markBtn.textContent = message.unread ? 'Mark read' : 'Mark unread';
                                renderMessages();
                                renderFolders();
                                saveState();
                            });
                            const deleteBtn = utils.createEl('button', '', { type: 'button', text: '🗑 Delete' });
                            deleteBtn.addEventListener('click', () => {
                                const list = account.folders[state.selectedFolder] || [];
                                account.folders[state.selectedFolder] = list.filter(item => item.id !== message.id);
                                state.selectedMessageId = null;
                                saveState('Message removed');
                                renderFolders();
                                renderMessages();
                                renderDetail();
                            });
                            footer.append(replyBtn, markBtn, deleteBtn);
                        }

                        detailPane.append(header, body, footer);
                    };

                    const renderComposeView = account => {
                        detailPane.innerHTML = '';
                        const draft = state.composeDraft || { accountId: account.id, draftId: null, to: '', subject: '', body: '' };
                        draft.accountId = account.id;
                        const wrapper = utils.createEl('div', 'mail-compose');

                        const makeField = (label, element) => {
                            const field = document.createElement('label');
                            field.style.display = 'flex';
                            field.style.flexDirection = 'column';
                            field.style.gap = '6px';
                            const span = document.createElement('span');
                            span.textContent = label;
                            span.style.fontSize = '0.82rem';
                            span.style.color = 'var(--text-muted)';
                            field.append(span, element);
                            return field;
                        };

                        const fromDisplay = document.createElement('div');
                        fromDisplay.textContent = `${account.label || account.email} <${account.email}>`;
                        fromDisplay.style.fontSize = '0.85rem';
                        fromDisplay.style.color = 'var(--text-muted)';
                        const toField = utils.createEl('input', '', { type: 'email', value: draft.to || '', placeholder: 'Recipient' });
                        const subjectField = utils.createEl('input', '', { type: 'text', value: draft.subject || '', placeholder: 'Subject' });
                        const bodyField = document.createElement('textarea');
                        bodyField.value = draft.body || '';
                        bodyField.placeholder = 'Write your message…';
                        bodyField.minLength = 0;

                        const syncDraft = () => {
                            state.composeDraft = {
                                accountId: account.id,
                                draftId: draft.draftId || null,
                                to: toField.value.trim(),
                                subject: subjectField.value.trim(),
                                body: bodyField.value
                            };
                            saveState();
                        };
                        toField.addEventListener('input', syncDraft);
                        subjectField.addEventListener('input', syncDraft);
                        bodyField.addEventListener('input', syncDraft);

                        const buttons = document.createElement('div');
                        buttons.style.display = 'flex';
                        buttons.style.gap = '10px';
                        const sendBtn = utils.createEl('button', '', { type: 'button', text: 'Send' });
                        const saveDraftBtn = utils.createEl('button', '', { type: 'button', text: 'Save Draft' });
                        const cancelBtn = utils.createEl('button', '', { type: 'button', text: 'Cancel' });
                        buttons.append(sendBtn, saveDraftBtn, cancelBtn);

                        wrapper.append(
                            makeField('From', fromDisplay),
                            makeField('To', toField),
                            makeField('Subject', subjectField),
                            makeField('Message', bodyField),
                            buttons
                        );

                        const resetCompose = () => {
                            state.composeDraft = null;
                            viewMode = 'preview';
                            saveState();
                            renderDetail();
                        };

                        const persistDraft = (notifyLabel) => {
                            const folder = account.folders.drafts;
                            const payload = createMessage(account, {
                                id: draft.draftId || utils.uuid(),
                                subject: subjectField.value.trim() || '(No subject)',
                                from: account.email,
                                to: toField.value.trim(),
                                body: bodyField.value,
                                snippet: bodyField.value.slice(0, 96),
                                unread: false,
                                date: utils.nowISO()
                            });
                            if (draft.draftId) {
                                const index = folder.findIndex(item => item.id === draft.draftId);
                                if (index >= 0) folder[index] = payload;
                            } else {
                                folder.unshift(payload);
                            }
                            state.selectedFolder = 'drafts';
                            state.selectedMessageId = payload.id;
                            state.composeDraft = { accountId: account.id, draftId: payload.id, to: payload.to, subject: payload.subject, body: payload.body };
                            saveState(notifyLabel);
                            renderFolders();
                            renderMessages();
                        };

                        sendBtn.addEventListener('click', () => {
                            if (!toField.value.trim()) {
                                notifications?.notify('Mail Center', 'Recipient is required');
                                return;
                            }
                            const message = createMessage(account, {
                                subject: subjectField.value.trim() || '(No subject)',
                                from: account.email,
                                to: toField.value.trim(),
                                body: bodyField.value,
                                snippet: bodyField.value.slice(0, 96),
                                unread: false
                            });
                            account.folders.sent.unshift(message);
                            state.selectedFolder = 'sent';
                            state.selectedMessageId = message.id;
                            resetCompose();
                            renderFolders();
                            renderMessages();
                            saveState('Message queued for delivery (simulated)');
                        });

                        saveDraftBtn.addEventListener('click', () => {
                            persistDraft('Draft saved');
                        });

                        cancelBtn.addEventListener('click', () => {
                            resetCompose();
                        });

                        detailPane.appendChild(wrapper);
                    };

                    const renderAll = () => {
                        ensureSelection();
                        const account = currentAccount();
                        const hasAccount = Boolean(account);
                        syncBtn.disabled = !hasAccount;
                        composeBtn.disabled = !hasAccount;
                        renderAccounts();
                        renderFolders();
                        renderMessages();
                        // Ensure compose view still points to selected account
                        if (viewMode === 'compose' && state.composeDraft && state.composeDraft.accountId !== (account?.id || null)) {
                            viewMode = 'preview';
                            state.composeDraft = null;
                        }
                        renderDetail();
                    };

                    renderAll();

                    return {
                        element: container,
                        width: '1120px',
                        height: '680px',
                        onClose: () => saveState()
                    };
                }
            };
        }

        function createChatApp() {
            const STORAGE_KEY = 'webos.chat.threads.v1';
            const DEMO_THREADS = [
                {
                    id: utils.uuid(),
                    name: 'Product Team',
                    participants: ['You', 'Alex', 'Priya'],
                    messages: [
                        { id: utils.uuid(), author: 'Alex', text: 'Morning! Ready for standup?', timestamp: utils.nowISO() },
                        { id: utils.uuid(), author: 'You', text: 'Yep, just finishing notes.', timestamp: utils.nowISO() }
                    ]
                },
                {
                    id: utils.uuid(),
                    name: 'Support Bot',
                    participants: ['You', 'Helper'],
                    messages: [
                        { id: utils.uuid(), author: 'Helper', text: 'Hi! Ask me anything about WebOS.', timestamp: utils.nowISO() }
                    ]
                }
            ];

            const loadThreads = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    if (Array.isArray(raw) && raw.length) return raw;
                } catch (error) {
                    console.warn('Failed to load chat threads', error);
                }
                return JSON.parse(JSON.stringify(DEMO_THREADS));
            };

            const persistThreads = threads => {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(threads)); } catch {}
            };

            const randomReplies = [
                'Sounds good! 👍',
                'Let me check that for you.',
                'I love that idea.',
                'Can you send a screenshot?',
                'Thanks for the update!',
                'We should sync later today.'
            ];

            return {
                id: 'chat',
                name: 'Realtime Chat',
                icon: '💬',
                hint: 'Converse instantly',
                launch({ notifications, appManager }) {
                    let threads = loadThreads();
                    let activeThreadId = threads[0]?.id || null;
                    const pendingTimers = new Set();

                    const findThread = id => threads.find(thread => thread.id === id) || null;

                    const shell = utils.createEl('div', 'chat-app');
                    const toolbar = utils.createEl('div', 'chat-toolbar');
                    const newButton = utils.createEl('button', '', { type: 'button', text: 'New Conversation' });
                    const status = utils.createEl('div', 'chat-status', { text: 'Connected' });
                    toolbar.append(newButton, status);

                    const layout = utils.createEl('div', 'chat-layout');
                    const listPane = utils.createEl('div', 'chat-pane');
                    const listTitle = document.createElement('strong');
                    listTitle.textContent = 'Conversations';
                    const threadList = utils.createEl('ul', 'chat-thread-list');
                    listPane.append(listTitle, threadList);

                    const chatPane = utils.createEl('div', 'chat-pane');
                    const history = utils.createEl('div', 'chat-history');
                    const typingIndicator = utils.createEl('div', 'chat-status', { text: '' });
                    const inputWrap = utils.createEl('div', 'chat-input');
                    const input = document.createElement('textarea');
                    input.placeholder = 'Type a message…';
                    const sendButton = utils.createEl('button', '', { type: 'button', text: 'Send' });
                    inputWrap.append(input, sendButton);
                    chatPane.append(history, typingIndicator, inputWrap);

                    layout.append(listPane, chatPane);
                    shell.append(toolbar, layout);

                    const renderThreads = () => {
                        threadList.innerHTML = '';
                        if (!threads.length) {
                            threadList.appendChild(utils.createEl('div', 'chat-status', { text: 'No conversations yet.' }));
                            return;
                        }
                        threads.forEach(thread => {
                            const item = utils.createEl('li', 'chat-thread');
                            item.classList.toggle('active', thread.id === activeThreadId);
                            const title = document.createElement('strong');
                            title.textContent = thread.name;
                            const preview = utils.createEl('div', 'chat-status');
                            const last = thread.messages[thread.messages.length - 1];
                            preview.textContent = last ? `${last.author}: ${last.text.slice(0, 40)}` : 'No messages yet';
                            item.append(title, preview);
                            item.addEventListener('click', () => {
                                activeThreadId = thread.id;
                                thread.unread = false;
                                renderThreads();
                                renderMessages();
                            });
                            threadList.appendChild(item);
                        });
                    };

                    const formatTime = iso => new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                    const renderMessages = () => {
                        history.innerHTML = '';
                        const thread = findThread(activeThreadId);
                        if (!thread) {
                            history.appendChild(utils.createEl('div', 'chat-status', { text: 'Select a conversation.' }));
                            return;
                        }
                        thread.messages.forEach(message => {
                            const bubble = utils.createEl('div', 'chat-message');
                            const isUser = message.author === 'You';
                            bubble.classList.add(isUser ? 'user' : 'peer');
                            bubble.innerHTML = `<strong>${message.author}</strong><div>${message.text}</div><span style="font-size:0.7rem;opacity:0.7;display:block;margin-top:4px;">${formatTime(message.timestamp)}</span>`;
                            history.appendChild(bubble);
                        });
                        history.scrollTop = history.scrollHeight;
                        typingIndicator.textContent = '';
                    };

                    const appendMessage = (threadId, author, text, notify = false) => {
                        const thread = findThread(threadId);
                        if (!thread) return;
                        thread.messages.push({ id: utils.uuid(), author, text, timestamp: utils.nowISO() });
                        if (notify && author !== 'You') thread.unread = true;
                        persistThreads(threads);
                        renderThreads();
                        if (thread.id === activeThreadId) renderMessages();
                        if (notify && author !== 'You') notifications?.notify(thread.name, `${author}: ${text}`);
                    };

                    const randomRepliesAfterDelay = thread => {
                        const delay = 1500 + Math.random() * 2500;
                        typingIndicator.textContent = `${thread.name} is typing…`;
                        const timer = setTimeout(() => {
                            pendingTimers.delete(timer);
                            const reply = randomReplies[Math.floor(Math.random() * randomReplies.length)];
                            typingIndicator.textContent = '';
                            appendMessage(thread.id, thread.participants.find(name => name !== 'You') || 'Bot', reply, true);
                        }, delay);
                        pendingTimers.add(timer);
                    };

                    sendButton.addEventListener('click', () => {
                        const text = input.value.trim();
                        if (!text) return;
                        const thread = findThread(activeThreadId);
                        if (!thread) {
                            notifications?.notify('Chat', 'Select a conversation first.');
                            return;
                        }
                        appendMessage(thread.id, 'You', text, false);
                        input.value = '';
                        randomRepliesAfterDelay(thread);
                    });

                    input.addEventListener('keydown', event => {
                        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'enter') {
                            event.preventDefault();
                            sendButton.click();
                        }
                    });

                    newButton.addEventListener('click', () => {
                        const name = prompt('Conversation name', `Chat ${threads.length + 1}`);
                        if (!name) return;
                        const thread = {
                            id: utils.uuid(),
                            name,
                            participants: ['You', 'Helper'],
                            messages: [
                                { id: utils.uuid(), author: 'Helper', text: `Welcome to ${name}!`, timestamp: utils.nowISO() }
                            ]
                        };
                        threads.unshift(thread);
                        activeThreadId = thread.id;
                        persistThreads(threads);
                        renderThreads();
                        renderMessages();
                    });

                    renderThreads();
                    renderMessages();

                    return {
                        element: shell,
                        width: '960px',
                        height: '620px',
                        onClose: () => {
                            pendingTimers.forEach(timer => clearTimeout(timer));
                            pendingTimers.clear();
                        }
                    };
                }
            };
        }

        function createCodeEditorApp() {
            const STORAGE_KEY = 'webos.code.docs.v1';
            const DEFAULT_DOC = {
                id: utils.uuid(),
                name: 'hello-world.js',
                language: 'javascript',
                path: null,
                content: 'function greet(name) {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet("WebOS"));\n'
            };

            const loadDocs = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    if (Array.isArray(raw) && raw.length) return raw;
                } catch (error) {
                    console.warn('Failed to load code docs', error);
                }
                return [DEFAULT_DOC];
            };

            const persistDocs = docs => {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(docs)); } catch {}
            };

            const languages = {
                javascript: {
                    keywords: ['function', 'return', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'switch', 'case', 'break', 'class', 'new', 'this', 'import', 'export'],
                    comment: /\/\/.*$/gm,
                    multiline: /\/\*[\s\S]*?\*\//gm,
                    strings: /(['"`])(?:\\.|(?!\1).)*\1/g
                },
                html: {
                    keywords: ['div', 'span', 'script', 'style', 'link', 'meta', 'body', 'html', 'head'],
                    comment: /<!--([\s\S]*?)-->/gm,
                    strings: /("[^"]*"|'[^']*')/g
                },
                css: {
                    keywords: ['display', 'flex', 'grid', 'color', 'background', 'border', 'font', 'padding', 'margin'],
                    comment: /\/\*[\s\S]*?\*\//gm,
                    strings: /("[^"]*"|'[^']*')/g
                },
                json: {
                    keywords: [],
                    comment: null,
                    strings: /("(?:\\.|[^"\\])*")/g
                }
            };

            const escapeHtml = value => value
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            const highlight = (code, lang) => {
                if (!lang || !languages[lang]) return `<pre>${escapeHtml(code)}</pre>`;
                const rules = languages[lang];
                let result = escapeHtml(code);
                if (rules.comment) result = result.replace(rules.comment, match => `<span style="color:#8795ff;">${escapeHtml(match)}</span>`);
                if (rules.multiline) result = result.replace(rules.multiline, match => `<span style="color:#8795ff;">${escapeHtml(match)}</span>`);
                if (rules.strings) result = result.replace(rules.strings, match => `<span style="color:#f2a272;">${escapeHtml(match)}</span>`);
                if (rules.keywords.length) {
                    const keywordRegex = new RegExp(`\\b(${rules.keywords.join('|')})\\b`, 'g');
                    result = result.replace(keywordRegex, `<span style="color:#7dd3fc;">$1</span>`);
                }
                return `<pre>${result}</pre>`;
            };

            const inferLanguage = name => {
                const ext = utils.ext(name).slice(1).toLowerCase();
                if (ext === 'js' || ext === 'ts' || ext === 'jsx' || ext === 'tsx') return 'javascript';
                if (ext === 'json') return 'json';
                if (ext === 'css') return 'css';
                if (ext === 'html') return 'html';
                return 'javascript';
            };

            return {
                id: 'code-editor',
                name: 'Code Workshop',
                icon: '💡',
                hint: 'Hack on code',
                launch({ fileSystem, notifications }) {
                    let docs = loadDocs();
                    let activeId = docs[0]?.id || null;
                    let theme = 'dark';

                    const container = utils.createEl('div', 'code-editor');
                    const filePane = utils.createEl('div', 'code-files');
                    const fileToolbar = utils.createEl('div', 'code-editor-toolbar');
                    const newBtn = utils.createEl('button', '', { type: 'button', text: 'New File' });
                    const openBtn = utils.createEl('button', '', { type: 'button', text: 'Open Path' });
                    const saveBtn = utils.createEl('button', '', { type: 'button', text: 'Save' });
                    const themeBtn = utils.createEl('button', '', { type: 'button', text: 'Toggle Theme' });
                    fileToolbar.append(newBtn, openBtn, saveBtn, themeBtn);
                    const fileList = utils.createEl('ul', 'code-file-list');
                    filePane.append(fileToolbar, fileList);

                    const editorPane = utils.createEl('div', 'code-workspace');
                    const editorToolbar = utils.createEl('div', 'code-editor-toolbar');
                    const nameField = utils.createEl('input', '', { type: 'text', placeholder: 'Filename' });
                    const languageSelect = document.createElement('select');
                    Object.keys(languages).forEach(key => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = key.toUpperCase();
                        languageSelect.appendChild(option);
                    });
                    editorToolbar.append(nameField, languageSelect);

                    const editorBody = utils.createEl('div', 'code-editor-body');
                    const textarea = document.createElement('textarea');
                    const preview = utils.createEl('div', 'code-preview');
                    editorBody.append(textarea);
                    editorPane.append(editorToolbar, editorBody, preview);

                    container.append(filePane, editorPane);

                    const persist = () => persistDocs(docs);

                    const renderList = () => {
                        fileList.innerHTML = '';
                        docs.forEach(doc => {
                            const button = document.createElement('button');
                            button.type = 'button';
                            button.textContent = doc.name;
                            button.classList.toggle('active', doc.id === activeId);
                            button.addEventListener('click', () => {
                                activeId = doc.id;
                                renderList();
                                loadActiveDoc();
                            });
                            const li = document.createElement('li');
                            li.appendChild(button);
                            fileList.appendChild(li);
                        });
                    };

                    const loadActiveDoc = () => {
                        const doc = docs.find(item => item.id === activeId);
                        if (!doc) return;
                        nameField.value = doc.name;
                        languageSelect.value = doc.language;
                        textarea.value = doc.content;
                        textarea.style.background = theme === 'dark' ? 'rgba(7, 12, 28, 0.9)' : '#fff';
                        textarea.style.color = theme === 'dark' ? '#f7f9ff' : '#1a2238';
                        preview.innerHTML = highlight(doc.content, doc.language);
                    };

                    textarea.addEventListener('input', () => {
                        const doc = docs.find(item => item.id === activeId);
                        if (!doc) return;
                        doc.content = textarea.value;
                        preview.innerHTML = highlight(doc.content, doc.language);
                    });

                    nameField.addEventListener('change', () => {
                        const doc = docs.find(item => item.id === activeId);
                        if (!doc) return;
                        doc.name = nameField.value.trim() || doc.name;
                        renderList();
                        persist();
                    });

                    languageSelect.addEventListener('change', () => {
                        const doc = docs.find(item => item.id === activeId);
                        if (!doc) return;
                        doc.language = languageSelect.value;
                        preview.innerHTML = highlight(doc.content, doc.language);
                        persist();
                    });

                    newBtn.addEventListener('click', () => {
                        const doc = {
                            id: utils.uuid(),
                            name: `untitled-${docs.length + 1}.js`,
                            language: 'javascript',
                            path: null,
                            content: ''
                        };
                        docs.unshift(doc);
                        activeId = doc.id;
                        renderList();
                        loadActiveDoc();
                        persist();
                    });

                    openBtn.addEventListener('click', () => {
                        const path = prompt('Enter file path (e.g. /Documents/script.js)');
                        if (!path) return;
                        try {
                            const meta = fileSystem.readFileMeta(path);
                            const content = fileSystem.readFile(path);
                            const doc = {
                                id: utils.uuid(),
                                name: meta.name,
                                language: inferLanguage(meta.name),
                                path,
                                content
                            };
                            docs.unshift(doc);
                            activeId = doc.id;
                            renderList();
                            loadActiveDoc();
                            persist();
                            notifications?.notify('Code Workshop', `Loaded ${meta.name}`);
                        } catch (error) {
                            notifications?.notify('Code Workshop', error.message);
                        }
                    });

                    saveBtn.addEventListener('click', () => {
                        const doc = docs.find(item => item.id === activeId);
                        if (!doc) return;
                        let targetPath = doc.path;
                        if (!targetPath) {
                            targetPath = prompt('Save as (e.g. /Documents/my-file.js)', `/Documents/${doc.name}`);
                            if (!targetPath) return;
                        }
                        try {
                            fileSystem.createFile(targetPath, doc.content);
                        } catch (error) {
                            if (/already exists/i.test(error.message)) fileSystem.writeFile(targetPath, doc.content);
                            else {
                                notifications?.notify('Code Workshop', error.message);
                                return;
                            }
                        }
                        doc.path = targetPath;
                        doc.name = targetPath.split('/').pop();
                        renderList();
                        persist();
                        notifications?.notify('Code Workshop', `Saved to ${targetPath}`);
                    });

                    themeBtn.addEventListener('click', () => {
                        theme = theme === 'dark' ? 'light' : 'dark';
                        loadActiveDoc();
                    });

                    renderList();
                    loadActiveDoc();

                    return {
                        element: container,
                        width: '1080px',
                        height: '640px'
                    };
                }
            };
        }

        function createPaintApp() {
            return {
                id: 'paint',
                name: 'Canvas Studio',
                icon: '🎨',
                hint: 'Draw & sketch',
                launch({ fileSystem, notifications }) {
                    const container = utils.createEl('div', 'paint-app');
                    const toolbar = utils.createEl('div', 'paint-toolbar');
                    const colorInput = utils.createEl('input', '', { type: 'color', value: '#1e90ff' });
                    const sizeInput = utils.createEl('input', '', { type: 'range', min: '1', max: '40', value: '6' });
                    sizeInput.style.width = '160px';
                    const sizeLabel = utils.createEl('span', 'chat-status', { text: 'Brush: 6px' });
                    const clearBtn = utils.createEl('button', '', { type: 'button', text: 'Clear' });
                    const downloadBtn = utils.createEl('button', '', { type: 'button', text: 'Download' });
                    const saveBtn = utils.createEl('button', '', { type: 'button', text: 'Save to Pictures' });
                    toolbar.append(colorInput, sizeInput, sizeLabel, clearBtn, downloadBtn, saveBtn);

                    const canvasWrap = utils.createEl('div', 'paint-canvas-wrap');
                    const canvas = document.createElement('canvas');
                    canvas.className = 'paint-canvas';
                    canvas.width = 960;
                    canvas.height = 540;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    canvasWrap.appendChild(canvas);
                    container.append(toolbar, canvasWrap);

                    let drawing = false;
                    let lastX = 0;
                    let lastY = 0;

                    const toCanvasCoords = event => {
                        const rect = canvas.getBoundingClientRect();
                        return [event.clientX - rect.left, event.clientY - rect.top];
                    };

                    canvas.addEventListener('pointerdown', event => {
                        canvas.setPointerCapture(event.pointerId);
                        drawing = true;
                        [lastX, lastY] = toCanvasCoords(event);
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                    });

                    canvas.addEventListener('pointermove', event => {
                        if (!drawing) return;
                        const [x, y] = toCanvasCoords(event);
                        ctx.lineTo(x, y);
                        ctx.strokeStyle = colorInput.value;
                        ctx.lineWidth = Number(sizeInput.value);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.stroke();
                        [lastX, lastY] = [x, y];
                    });

                    canvas.addEventListener('pointerup', () => {
                        drawing = false;
                        ctx.closePath();
                    });

                    canvas.addEventListener('pointercancel', () => {
                        drawing = false;
                        ctx.closePath();
                    });

                    sizeInput.addEventListener('input', () => {
                        sizeLabel.textContent = `Brush: ${sizeInput.value}px`;
                    });

                    const toDataUrl = () => canvas.toDataURL('image/png');

                    clearBtn.addEventListener('click', () => {
                        if (!confirm('Clear the canvas?')) return;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    });

                    downloadBtn.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.href = toDataUrl();
                        link.download = 'canvas.png';
                        link.click();
                    });

                    saveBtn.addEventListener('click', () => {
                        try {
                            const dataUrl = toDataUrl();
                            const base64 = dataUrl.split(',')[1];
                            const name = `Canvas-${Date.now()}.png`;
                            fileSystem.createFile(`/Pictures/${name}`, utils.base64ToBytes(base64), { mime: 'image/png' });
                            notifications?.notify('Canvas Studio', `Saved to /Pictures/${name}`);
                        } catch (error) {
                            notifications?.notify('Canvas Studio', error.message);
                        }
                    });

                    return {
                        element: container,
                        width: '1040px',
                        height: '680px'
                    };
                }
            };
        }

        function createSpreadsheetApp() {
            const STORAGE_KEY = 'webos.sheets.state.v1';
            const COLS = 10;
            const ROWS = 20;

            const letters = Array.from({ length: COLS }, (_, index) => String.fromCharCode(65 + index));

            const loadState = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                    if (raw && typeof raw === 'object') return raw;
                } catch (error) {
                    console.warn('Failed to load sheet state', error);
                }
                return {};
            };

            const persistState = state => {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch {}
            };

            const cellId = (colIndex, rowIndex) => `${String.fromCharCode(65 + colIndex)}${rowIndex + 1}`;

            const evaluateCell = (map, id, stack = new Set()) => {
                if (stack.has(id)) return '#CYCLE';
                const record = map[id];
                if (!record) return '';
                if (!record.formula || !record.formula.startsWith('=')) return record.value || '';
                stack.add(id);
                const expr = record.formula.slice(1);
                const replaced = expr.replace(/[A-Z](?:[1-9]|1\d|2[0])?/gi, ref => {
                    const key = ref.toUpperCase();
                    const value = evaluateCell(map, key, stack);
                    const num = parseFloat(value);
                    return Number.isFinite(num) ? String(num) : '0';
                });
                if (!/^[0-9+\-*/().\s]*$/.test(replaced)) return '#ERR';
                try {
                    // eslint-disable-next-line no-new-func
                    const result = Function(`"use strict"; return (${replaced || '0'});`)();
                    return Number.isFinite(result) ? String(result) : '#ERR';
                } catch (error) {
                    return '#ERR';
                } finally {
                    stack.delete(id);
                }
            };

            return {
                id: 'spreadsheet',
                name: 'Grid Sheets',
                icon: '📈',
                hint: 'Organize data',
                launch({ notifications }) {
                    const state = loadState();
                    const container = utils.createEl('div', 'sheet-app');
                    const toolbar = utils.createEl('div', 'sheet-toolbar');
                    const addRowBtn = utils.createEl('button', '', { type: 'button', text: 'Add Row' });
                    const addColBtn = utils.createEl('button', '', { type: 'button', text: 'Add Column' });
                    const clearBtn = utils.createEl('button', '', { type: 'button', text: 'Clear Sheet' });
                    toolbar.append(addRowBtn, addColBtn, clearBtn);

                    const formulaBar = utils.createEl('div', 'sheet-formula');
                    const formulaLabel = document.createElement('span');
                    formulaLabel.textContent = 'fx';
                    const formulaInput = utils.createEl('input', '', { type: 'text', placeholder: '=A1+B2' });
                    formulaBar.append(formulaLabel, formulaInput);

                    const gridWrap = utils.createEl('div', 'sheet-grid');
                    const table = utils.createEl('table', 'sheet-table');
                    gridWrap.appendChild(table);
                    container.append(toolbar, formulaBar, gridWrap);

                    let columnCount = COLS;
                    let rowCount = ROWS;
                    let activeCell = 'A1';

                    const ensureCell = id => {
                        if (!state[id]) state[id] = { value: '', formula: '' };
                        return state[id];
                    };

                    const renderTable = () => {
                        table.innerHTML = '';
                        const thead = document.createElement('thead');
                        const headRow = document.createElement('tr');
                        headRow.appendChild(document.createElement('th'));
                        for (let col = 0; col < columnCount; col += 1) {
                            const th = document.createElement('th');
                            th.textContent = cellId(col, 0).replace(/[0-9]+/, '');
                            headRow.appendChild(th);
                        }
                        thead.appendChild(headRow);
                        table.appendChild(thead);

                        const tbody = document.createElement('tbody');
                        for (let row = 0; row < rowCount; row += 1) {
                            const tr = document.createElement('tr');
                            const indexCell = document.createElement('th');
                            indexCell.textContent = String(row + 1);
                            tr.appendChild(indexCell);
                            for (let col = 0; col < columnCount; col += 1) {
                                const id = cellId(col, row);
                                ensureCell(id);
                                const td = document.createElement('td');
                                td.dataset.cell = id;
                                td.contentEditable = 'true';
                                td.textContent = state[id].formula ? state[id].formula : state[id].value;
                                td.addEventListener('focus', () => {
                                    activeCell = id;
                                    formulaInput.value = state[id].formula ? state[id].formula : state[id].value;
                                });
                                td.addEventListener('blur', () => {
                                    const raw = td.textContent.trim();
                                    const record = ensureCell(id);
                                    if (raw.startsWith('=')) {
                                        record.formula = raw;
                                        record.value = evaluateCell(state, id);
                                    } else {
                                        record.formula = '';
                                        record.value = raw;
                                    }
                                    formulaInput.value = record.formula || record.value;
                                    persistState(state);
                                    renderTable();
                                });
                                tr.appendChild(td);
                            }
                            tbody.appendChild(tr);
                        }
                        table.appendChild(tbody);
                    };

                    formulaInput.addEventListener('change', () => {
                        const record = ensureCell(activeCell);
                        const raw = formulaInput.value.trim();
                        if (raw.startsWith('=')) {
                            record.formula = raw;
                            record.value = evaluateCell(state, activeCell);
                        } else {
                            record.formula = '';
                            record.value = raw;
                        }
                        persistState(state);
                        renderTable();
                    });

                    addRowBtn.addEventListener('click', () => {
                        rowCount += 1;
                        renderTable();
                    });

                    addColBtn.addEventListener('click', () => {
                        columnCount = Math.min(columnCount + 1, 26);
                        renderTable();
                    });

                    clearBtn.addEventListener('click', () => {
                        if (!confirm('Clear the entire sheet?')) return;
                        Object.keys(state).forEach(key => delete state[key]);
                        persistState(state);
                        renderTable();
                    });

                    renderTable();

                    return {
                        element: container,
                        width: '1040px',
                        height: '640px'
                    };
                }
            };
        }

        function createDatabaseApp() {
            const DATASET = {
                users: [
                    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'Admin', joined: '2023-02-12' },
                    { id: 2, name: 'Ben', email: 'ben@example.com', role: 'Editor', joined: '2023-07-03' },
                    { id: 3, name: 'Cara', email: 'cara@example.com', role: 'Viewer', joined: '2024-01-22' },
                    { id: 4, name: 'Dana', email: 'dana@example.com', role: 'Editor', joined: '2024-04-18' }
                ],
                orders: [
                    { id: 101, userId: 1, total: 129.99, status: 'shipped', placed: '2024-05-01' },
                    { id: 102, userId: 2, total: 79.49, status: 'processing', placed: '2024-05-03' },
                    { id: 103, userId: 3, total: 59.95, status: 'cancelled', placed: '2024-05-04' },
                    { id: 104, userId: 1, total: 199.99, status: 'processing', placed: '2024-05-06' }
                ]
            };

            const runQuery = sql => {
                const normalized = sql.trim();
                if (!normalized) return { kind: 'info', message: 'Enter a SQL select statement.' };
                const lower = normalized.toLowerCase();
                if (lower === 'show tables' || lower === 'show tables;') {
                    return { kind: 'result', columns: ['table'], rows: Object.keys(DATASET).map(name => ({ table: name })) };
                }
                const describeMatch = normalized.match(/^describe\s+(\w+);?$/i);
                if (describeMatch) {
                    const tableName = describeMatch[1].toLowerCase();
                    const table = DATASET[tableName];
                    if (!table) return { kind: 'error', message: `Unknown table ${tableName}` };
                    const sample = table[0] || {};
                    return {
                        kind: 'result',
                        columns: ['column', 'type'],
                        rows: Object.keys(sample).map(key => ({ column: key, type: typeof sample[key] }))
                    };
                }
                const selectMatch = normalized.match(/^select\s+(.+)\s+from\s+(\w+)(?:\s+where\s+(.+))?;?$/i);
                if (!selectMatch) return { kind: 'error', message: 'Only SELECT, SHOW TABLES and DESCRIBE are supported.' };
                const fields = selectMatch[1].trim();
                const tableName = selectMatch[2].toLowerCase();
                const whereClause = selectMatch[3] ? selectMatch[3].trim() : null;
                const table = DATASET[tableName];
                if (!table) return { kind: 'error', message: `Unknown table ${tableName}` };

                let columns;
                if (fields === '*') columns = Object.keys(table[0] || {});
                else columns = fields.split(',').map(col => col.trim()).filter(Boolean);

                let rows = table.slice();
                if (whereClause) {
                    const conditionMatch = whereClause.match(/(\w+)\s*=\s*(['"]?)([^'"]+)\2/i);
                    if (!conditionMatch) return { kind: 'error', message: 'Only simple equality WHERE clauses are supported.' };
                    const column = conditionMatch[1];
                    const value = conditionMatch[3];
                    rows = rows.filter(row => String(row[column]) === value);
                }

                const resultRows = rows.map(row => {
                    const output = {};
                    columns.forEach(column => {
                        output[column] = row[column];
                    });
                    return output;
                });

                return { kind: 'result', columns, rows: resultRows };
            };

            return {
                id: 'database',
                name: 'Data Explorer',
                icon: '🗄️',
                hint: 'Run SQL queries',
                launch({ notifications }) {
                    const container = utils.createEl('div', 'database-app');
                    const layout = utils.createEl('div', 'database-layout');
                    const schemaPane = utils.createEl('div', 'database-pane');
                    const schemaTitle = document.createElement('strong');
                    schemaTitle.textContent = 'Tables';
                    const schemaList = document.createElement('ul');
                    schemaList.style.listStyle = 'none';
                    schemaList.style.margin = '0';
                    schemaList.style.padding = '0';
                    schemaList.style.display = 'flex';
                    schemaList.style.flexDirection = 'column';
                    schemaList.style.gap = '6px';
                    Object.keys(DATASET).forEach(name => {
                        const li = document.createElement('li');
                        li.textContent = `${name} (${DATASET[name].length})`;
                        li.style.cursor = 'pointer';
                        li.style.padding = '6px 8px';
                        li.style.borderRadius = '10px';
                        li.addEventListener('click', () => {
                            queryInput.value = `SELECT * FROM ${name};`;
                            runAndRender();
                        });
                        schemaList.appendChild(li);
                    });
                    schemaPane.append(schemaTitle, schemaList);

                    const queryPane = utils.createEl('div', 'database-pane');
                    const queryControls = utils.createEl('div', 'database-query');
                    const queryInput = document.createElement('textarea');
                    queryInput.placeholder = 'SELECT * FROM users;';
                    queryInput.value = 'SELECT * FROM users;';
                    const runBtn = utils.createEl('button', '', { type: 'button', text: 'Run Query' });
                    queryControls.append(queryInput, runBtn);
                    const resultPane = utils.createEl('div', 'database-result');
                    queryPane.append(queryControls, resultPane);

                    layout.append(schemaPane, queryPane);
                    container.append(layout);

                    const renderResult = outcome => {
                        resultPane.innerHTML = '';
                        if (!outcome) return;
                        if (outcome.kind === 'error') {
                            const div = utils.createEl('div', 'chat-status', { text: outcome.message });
                            div.style.color = '#ff6b6b';
                            resultPane.appendChild(div);
                        } else if (outcome.kind === 'info') {
                            resultPane.appendChild(utils.createEl('div', 'chat-status', { text: outcome.message }));
                        } else {
                            if (!outcome.rows.length) {
                                resultPane.appendChild(utils.createEl('div', 'chat-status', { text: 'No rows returned.' }));
                                return;
                            }
                            const table = document.createElement('table');
                            table.style.width = '100%';
                            table.style.borderCollapse = 'collapse';
                            const thead = document.createElement('thead');
                            const headRow = document.createElement('tr');
                            outcome.columns.forEach(column => {
                                const th = document.createElement('th');
                                th.textContent = column;
                                th.style.border = '1px solid rgba(123,139,255,0.25)';
                                th.style.padding = '6px 8px';
                                th.style.textAlign = 'left';
                                headRow.appendChild(th);
                            });
                            thead.appendChild(headRow);
                            table.appendChild(thead);
                            const tbody = document.createElement('tbody');
                            outcome.rows.forEach(row => {
                                const tr = document.createElement('tr');
                                outcome.columns.forEach(column => {
                                    const td = document.createElement('td');
                                    td.textContent = row[column];
                                    td.style.border = '1px solid rgba(123,139,255,0.15)';
                                    td.style.padding = '6px 8px';
                                    tr.appendChild(td);
                                });
                                tbody.appendChild(tr);
                            });
                            table.appendChild(tbody);
                            resultPane.appendChild(table);
                        }
                    };

                    const runAndRender = () => {
                        const outcome = runQuery(queryInput.value);
                        renderResult(outcome);
                        if (outcome.kind === 'error') notifications?.notify('Data Explorer', outcome.message);
                    };

                    runBtn.addEventListener('click', runAndRender);
                    queryInput.addEventListener('keydown', event => {
                        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'enter') {
                            event.preventDefault();
                            runAndRender();
                        }
                    });

                    runAndRender();

                    return {
                        element: container,
                        width: '1040px',
                        height: '640px'
                    };
                }
            };
        }

        function createCloudSyncApp() {
            const STORAGE_KEY = 'webos.cloud.accounts.v1';

            const loadAccounts = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    if (Array.isArray(raw)) return raw;
                } catch (error) {
                    console.warn('Failed to load cloud accounts', error);
                }
                return [];
            };

            const persistAccounts = accounts => {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(accounts)); } catch {}
            };

            const providers = ['Google Drive', 'Dropbox', 'OneDrive', 'Box'];

            return {
                id: 'cloud-sync',
                name: 'Cloud Bridge',
                icon: '☁️',
                hint: 'Link cloud drives',
                launch({ notifications, fileSystem }) {
                    let accounts = loadAccounts();
                    const logs = [];

                    const container = utils.createEl('div', 'cloud-app');
                    const layout = utils.createEl('div', 'cloud-layout');
                    const accountPane = utils.createEl('div', 'cloud-pane');
                    const accountHeader = document.createElement('strong');
                    accountHeader.textContent = 'Accounts';
                    const addBtn = utils.createEl('button', '', { type: 'button', text: 'Add Account' });
                    const accountList = utils.createEl('ul', 'cloud-accounts');
                    accountPane.append(accountHeader, addBtn, accountList);

                    const consolePane = utils.createEl('div', 'cloud-pane');
                    const consoleHeader = document.createElement('strong');
                    consoleHeader.textContent = 'Activity';
                    const syncBtn = utils.createEl('button', '', { type: 'button', text: 'Sync Now' });
                    const logArea = utils.createEl('div', 'cloud-sync-log');
                    logArea.textContent = 'No sync operations yet.';
                    consolePane.append(consoleHeader, syncBtn, logArea);

                    layout.append(accountPane, consolePane);
                    container.append(layout);

                    const log = message => {
                        const entry = `${new Date().toLocaleTimeString()} · ${message}`;
                        logs.unshift(entry);
                        logArea.textContent = logs.slice(0, 50).join('\n');
                    };

                    const renderAccounts = () => {
                        accountList.innerHTML = '';
                        if (!accounts.length) {
                            accountList.appendChild(utils.createEl('div', 'mail-empty', { text: 'Connect a storage provider.' }));
                            return;
                        }
                        accounts.forEach(account => {
                            const li = document.createElement('li');
                            const title = document.createElement('strong');
                            title.textContent = `${account.provider} (${account.label})`;
                            const status = document.createElement('span');
                            status.textContent = account.lastSync ? `Last sync ${utils.relativeTime(account.lastSync)}` : 'Not synced';
                            status.style.fontSize = '0.75rem';
                            status.style.color = 'var(--text-muted)';
                            const actions = document.createElement('div');
                            actions.style.display = 'flex';
                            actions.style.gap = '6px';
                            const renameBtn = utils.createEl('button', '', { type: 'button', text: 'Rename' });
                            const removeBtn = utils.createEl('button', '', { type: 'button', text: 'Remove' });
                            renameBtn.addEventListener('click', () => {
                                const label = prompt('Account label', account.label);
                                if (!label) return;
                                account.label = label.trim();
                                persistAccounts(accounts);
                                renderAccounts();
                            });
                            removeBtn.addEventListener('click', () => {
                                if (!confirm(`Remove ${account.label}?`)) return;
                                accounts = accounts.filter(entry => entry.id !== account.id);
                                persistAccounts(accounts);
                                renderAccounts();
                                log(`Removed ${account.label}`);
                            });
                            actions.append(renameBtn, removeBtn);
                            li.append(title, status, actions);
                            accountList.appendChild(li);
                        });
                    };

                    addBtn.addEventListener('click', () => {
                        const provider = prompt(`Provider (${providers.join(', ')})`, providers[0]);
                        if (!provider) return;
                        const label = prompt('Account label (e.g. Personal)', 'Personal');
                        if (!label) return;
                        const account = {
                            id: utils.uuid(),
                            provider: provider.trim(),
                            label: label.trim(),
                            lastSync: null
                        };
                        accounts.push(account);
                        persistAccounts(accounts);
                        renderAccounts();
                        log(`Linked ${account.provider} (${account.label})`);
                    });

                    syncBtn.addEventListener('click', () => {
                        if (!accounts.length) {
                            notifications?.notify('Cloud Bridge', 'Add an account first.');
                            return;
                        }
                        accounts.forEach(account => {
                            account.lastSync = new Date().toISOString();
                            log(`Synced ${account.label}. Mirrored local workspace to cloud (simulated).`);
                        });
                        persistAccounts(accounts);
                        renderAccounts();
                        notifications?.notify('Cloud Bridge', 'Sync complete');
                    });

                    renderAccounts();

                    return {
                        element: container,
                        width: '960px',
                        height: '600px'
                    };
                }
            };
        }

        function createScreenRecorderApp() {
            return {
                id: 'screen-recorder',
                name: 'Screen Recorder',
                icon: '📹',
                hint: 'Capture screen video',
                launch({ notifications }) {
                    const container = utils.createEl('div', 'capture-app');
                    const toolbar = utils.createEl('div', 'capture-toolbar');
                    const startBtn = utils.createEl('button', '', { type: 'button', text: 'Start Recording' });
                    const stopBtn = utils.createEl('button', '', { type: 'button', text: 'Stop' });
                    stopBtn.disabled = true;
                    const status = utils.createEl('div', 'capture-status', { text: 'Idle' });
                    toolbar.append(startBtn, stopBtn, status);
                    const preview = utils.createEl('div', 'capture-preview');
                    const video = document.createElement('video');
                    video.autoplay = true;
                    video.playsInline = true;
                    video.muted = true;
                    preview.appendChild(video);
                    container.append(toolbar, preview);

                    let stream = null;
                    let recorder = null;
                    let chunks = [];

                    const reset = () => {
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                            stream = null;
                        }
                        recorder = null;
                        chunks = [];
                        video.srcObject = null;
                        stopBtn.disabled = true;
                        startBtn.disabled = false;
                        status.textContent = 'Idle';
                    };

                    startBtn.addEventListener('click', async () => {
                        try {
                            stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                            recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                            chunks = [];
                            recorder.ondataavailable = event => { if (event.data.size) chunks.push(event.data); };
                            recorder.onstop = () => {
                                const blob = new Blob(chunks, { type: 'video/webm' });
                                const url = URL.createObjectURL(blob);
                                const playback = document.createElement('video');
                                playback.controls = true;
                                playback.src = url;
                                playback.style.maxWidth = '100%';
                                preview.innerHTML = '';
                                preview.appendChild(playback);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = `screen-${Date.now()}.webm`;
                                link.textContent = 'Download recording';
                                link.style.marginTop = '12px';
                                preview.appendChild(link);
                            };
                            video.srcObject = stream;
                            recorder.start();
                            status.textContent = 'Recording…';
                            startBtn.disabled = true;
                            stopBtn.disabled = false;
                        } catch (error) {
                            notifications?.notify('Screen Recorder', error.message || 'Unable to start recording');
                            reset();
                        }
                    });

                    stopBtn.addEventListener('click', () => {
                        if (!recorder) return;
                        recorder.stop();
                        reset();
                    });

                    return {
                        element: container,
                        width: '920px',
                        height: '580px',
                        onClose: () => reset()
                    };
                }
            };
        }

        function createScreenshotToolApp() {
            return {
                id: 'screenshot-tool',
                name: 'Snapshot Tool',
                icon: '📸',
                hint: 'Capture regions',
                launch({ notifications, fileSystem }) {
                    const container = utils.createEl('div', 'capture-app');
                    const toolbar = utils.createEl('div', 'capture-toolbar');
                    const captureBtn = utils.createEl('button', '', { type: 'button', text: 'Capture Screen' });
                    const saveBtn = utils.createEl('button', '', { type: 'button', text: 'Save to Pictures' });
                    saveBtn.disabled = true;
                    const status = utils.createEl('div', 'capture-status', { text: 'Ready' });
                    toolbar.append(captureBtn, saveBtn, status);
                    const preview = utils.createEl('div', 'capture-preview');
                    container.append(toolbar, preview);

                    let dataUrl = null;

                    const releaseStream = stream => {
                        if (!stream) return;
                        stream.getTracks().forEach(track => track.stop());
                    };

                    captureBtn.addEventListener('click', async () => {
                        dataUrl = null;
                        preview.innerHTML = '';
                        saveBtn.disabled = true;
                        try {
                            const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                            const video = document.createElement('video');
                            video.srcObject = stream;
                            video.muted = true;
                            await video.play();
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(video, 0, 0);
                            dataUrl = canvas.toDataURL('image/png');
                            const img = new Image();
                            img.src = dataUrl;
                            img.alt = 'Screenshot';
                            img.style.borderRadius = '12px';
                            img.style.maxWidth = '100%';
                            preview.appendChild(img);
                            saveBtn.disabled = false;
                            status.textContent = 'Screenshot captured';
                            video.pause();
                            releaseStream(stream);
                        } catch (error) {
                            notifications?.notify('Snapshot Tool', error.message || 'Unable to capture screen');
                            status.textContent = 'Failed to capture';
                        }
                    });

                    saveBtn.addEventListener('click', () => {
                        if (!dataUrl) return;
                        try {
                            const base64 = dataUrl.split(',')[1];
                            const name = `Screenshot-${Date.now()}.png`;
                            fileSystem.createFile(`/Pictures/${name}`, utils.base64ToBytes(base64), { mime: 'image/png' });
                            notifications?.notify('Snapshot Tool', `Saved to /Pictures/${name}`);
                        } catch (error) {
                            notifications?.notify('Snapshot Tool', error.message);
                        }
                    });

                    return {
                        element: container,
                        width: '840px',
                        height: '520px'
                    };
                }
            };
        }

        function createPackageManagerApp() {
            const STORAGE_KEY = 'webos.packages.installed.v1';
            const loadInstalled = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    if (Array.isArray(raw)) return new Set(raw);
                } catch {}
                return new Set();
            };
            const persistInstalled = installed => {
                try { localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(installed))); } catch {}
            };

            return {
                id: 'package-manager',
                name: 'Package Manager',
                icon: '📦',
                hint: 'Manage components',
                launch({ notifications }) {
                    const installed = loadInstalled();
                    const registry = APP_CATALOG.filter(app => !GAME_APP_IDS.includes(app.id));

                    const container = utils.createEl('div', 'package-app');
                    const layout = utils.createEl('div', 'package-layout');
                    const filterPane = utils.createEl('div', 'package-pane');
                    const filterTitle = document.createElement('strong');
                    filterTitle.textContent = 'Filters';
                    const showInstalled = utils.createEl('input', '', { type: 'checkbox', id: 'pkg-installed' });
                    const showLabel = document.createElement('label');
                    showLabel.htmlFor = 'pkg-installed';
                    showLabel.textContent = 'Installed only';
                    showLabel.style.display = 'flex';
                    showLabel.style.alignItems = 'center';
                    showLabel.style.gap = '6px';
                    const status = utils.createEl('div', 'chat-status');
                    filterPane.append(filterTitle, showLabel);
                    showLabel.insertBefore(showInstalled, showLabel.firstChild);
                    filterPane.append(status);

                    const listPane = utils.createEl('div', 'package-pane');
                    const list = utils.createEl('div', 'package-list');
                    listPane.append(list);

                    layout.append(filterPane, listPane);
                    container.append(layout);

                    const render = () => {
                        const filtered = registry.filter(app => showInstalled.checked ? installed.has(app.id) : true);
                        status.textContent = `${installed.size} installed · ${filtered.length} shown`;
                        list.innerHTML = '';
                        if (!filtered.length) {
                            list.appendChild(utils.createEl('div', 'mail-empty', { text: 'No packages match the filter.' }));
                            return;
                        }
                        filtered.forEach(app => {
                            const card = utils.createEl('div', 'package-card');
                            const title = document.createElement('strong');
                            title.textContent = `${app.icon || '🧩'} ${app.name}`;
                            const hint = document.createElement('span');
                            hint.textContent = app.hint || 'Application';
                            hint.style.fontSize = '0.8rem';
                            hint.style.color = 'var(--text-muted)';
                            const actions = document.createElement('div');
                            actions.style.display = 'flex';
                            actions.style.gap = '10px';
                            const toggle = utils.createEl('button', '', { type: 'button', text: installed.has(app.id) ? 'Uninstall' : 'Install' });
                            const openBtn = utils.createEl('button', '', { type: 'button', text: 'Open' });
                            openBtn.addEventListener('click', () => {
                                try {
                                    appManager?.open(app.id);
                                } catch (error) {
                                    notifications?.notify('Package Manager', error.message || 'Unable to open');
                                }
                            });
                            toggle.addEventListener('click', () => {
                                if (installed.has(app.id)) {
                                    installed.delete(app.id);
                                    notifications?.notify('Package Manager', `${app.name} marked as uninstalled`);
                                } else {
                                    installed.add(app.id);
                                    notifications?.notify('Package Manager', `${app.name} installed (simulated)`);
                                }
                                persistInstalled(installed);
                                render();
                            });
                            actions.append(toggle, openBtn);
                            card.append(title, hint, actions);
                            list.appendChild(card);
                        });
                    };

                    showInstalled.addEventListener('change', render);
                    render();

                    return {
                        element: container,
                        width: '900px',
                        height: '620px'
                    };
                }
            };
        }

        function createAppStoreApp() {
            const INSTALLED_KEY = 'webos.packages.installed.v1';
            const loadInstalled = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(INSTALLED_KEY) || '[]');
                    if (Array.isArray(raw)) return new Set(raw);
                } catch {}
                return new Set();
            };
            const persistInstalled = installed => {
                try { localStorage.setItem(INSTALLED_KEY, JSON.stringify(Array.from(installed))); } catch {}
            };

            return {
                id: 'app-store',
                name: 'App Plaza',
                icon: '🛍️',
                hint: 'Discover applications',
                launch({ notifications, appManager }) {
                    const installed = loadInstalled();
                    const container = utils.createEl('div', 'store-app');
                    const searchRow = utils.createEl('div', 'store-search');
                    const searchInput = utils.createEl('input', '', { type: 'search', placeholder: 'Search apps' });
                    const installedToggle = utils.createEl('input', '', { type: 'checkbox', id: 'store-installed' });
                    const installedLabel = document.createElement('label');
                    installedLabel.htmlFor = 'store-installed';
                    installedLabel.textContent = 'Installed only';
                    installedLabel.style.display = 'flex';
                    installedLabel.style.alignItems = 'center';
                    installedLabel.style.gap = '6px';
                    searchRow.append(searchInput, installedLabel);
                    installedLabel.insertBefore(installedToggle, installedLabel.firstChild);
                    container.append(searchRow);

                    const grid = utils.createEl('div', 'store-grid');
                    container.appendChild(grid);

                    const render = () => {
                        const term = searchInput.value.trim().toLowerCase();
                        const filtered = APP_CATALOG.filter(app => {
                            if (installedToggle.checked && !installed.has(app.id)) return false;
                            if (!term) return true;
                            return [app.name, app.hint, app.id].some(value => (value || '').toLowerCase().includes(term));
                        });
                        grid.innerHTML = '';
                        if (!filtered.length) {
                            grid.appendChild(utils.createEl('div', 'mail-empty', { text: 'Nothing matches your search.' }));
                            return;
                        }
                        filtered.forEach(app => {
                            const card = utils.createEl('div', 'store-card');
                            const title = document.createElement('strong');
                            title.textContent = `${app.icon || '🧩'} ${app.name}`;
                            const hint = document.createElement('span');
                            hint.textContent = app.hint || '';
                            hint.style.color = 'var(--text-muted)';
                            hint.style.fontSize = '0.82rem';
                            const footer = document.createElement('footer');
                            const installBtn = utils.createEl('button', '', { type: 'button', text: installed.has(app.id) ? 'Installed' : 'Install' });
                            if (installed.has(app.id)) installBtn.disabled = true;
                            const openBtn = utils.createEl('button', '', { type: 'button', text: 'Open' });
                            openBtn.addEventListener('click', () => {
                                try {
                                    appManager.open(app.id);
                                } catch (error) {
                                    notifications?.notify('App Plaza', error.message || 'Unable to open app');
                                }
                            });
                            installBtn.addEventListener('click', () => {
                                installed.add(app.id);
                                persistInstalled(installed);
                                notifications?.notify('App Plaza', `${app.name} installed (simulated)`);
                                render();
                            });
                            footer.append(installBtn, openBtn);
                            card.append(title, hint, footer);
                            grid.appendChild(card);
                        });
                    };

                    searchInput.addEventListener('input', utils.debounce(render, 160));
                    installedToggle.addEventListener('change', render);
                    render();

                    return {
                        element: container,
                        width: '1080px',
                        height: '660px'
                    };
                }
            };
        }

        function createAssistantApp() {
            return {
                id: 'assistant',
                name: 'AI Assistant',
                icon: '🤖',
                hint: 'Chat & automate',
                launch({ appManager, notifications, fileSystem, modals, settings }) {
                    const cfgKey = STORAGE_KEYS.AI_SETTINGS;
                    let cfg = { baseUrl: 'https://api.openai.com/v1', model: 'gpt-4o-mini', apiKey: '' };
                    try { cfg = { ...cfg, ...(JSON.parse(localStorage.getItem(cfgKey) || '{}')) }; } catch {}

                    const root = utils.createEl('div', 'assistant');
                    const toolbar = utils.createEl('div', 'assistant-toolbar');
                    toolbar.innerHTML = `
                        <details>
                          <summary>Connection</summary>
                          <div class="assistant-settings">
                            <label>Base URL <input id="ai-base" type="url" placeholder="https://api.openai.com/v1"/></label>
                            <label>Model <input id="ai-model" type="text" placeholder="gpt-4o-mini"/></label>
                            <label>API Key <input id="ai-key" type="password" placeholder="sk-..."/></label>
                            <button id="ai-save">Save</button>
                          </div>
                        </details>
                        <div class="assistant-hint">Type /help for commands. Writes require confirmation and are restricted to /Documents or /Downloads.</div>
                    `;
                    const chat = utils.createEl('div', 'assistant-chat');
                    const list = utils.createEl('div', 'assistant-messages');
                    chat.appendChild(list);
                    const composer = utils.createEl('div', 'assistant-composer');
                    composer.innerHTML = `
                        <textarea id="assistant-input" rows="2" placeholder="Ask me anything..."></textarea>
                        <button id="assistant-send" title="Send">Send</button>
                    `;
                    root.append(toolbar, chat, composer);

                    // Apply config to inputs
                    toolbar.querySelector('#ai-base').value = cfg.baseUrl || '';
                    toolbar.querySelector('#ai-model').value = cfg.model || '';
                    toolbar.querySelector('#ai-key').value = cfg.apiKey || '';

                    const saveCfg = () => {
                        cfg.baseUrl = toolbar.querySelector('#ai-base').value.trim() || cfg.baseUrl;
                        cfg.model = toolbar.querySelector('#ai-model').value.trim() || cfg.model;
                        cfg.apiKey = toolbar.querySelector('#ai-key').value.trim();
                        localStorage.setItem(cfgKey, JSON.stringify(cfg));
                        notifications?.notify('AI Assistant', 'Connection settings saved.');
                    };
                    toolbar.querySelector('#ai-save').addEventListener('click', saveCfg);

                    const addMessage = (role, content) => {
                        const row = utils.createEl('div', `assistant-msg ${role}`);
                        row.innerHTML = `<div class="bubble"><pre>${content.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}</pre></div>`;
                        list.appendChild(row);
                        list.scrollTop = list.scrollHeight;
                    };

                    const messages = [];

                    const limitText = (text, max = 16384) => text.length > max ? text.slice(0, max) + `\n... [truncated ${text.length - max} bytes]` : text;
                    const isSafeWritePath = (path) => {
                        const p = utils.normalize(path);
                        return p.startsWith('/Documents/') || p === '/Documents' || p.startsWith('/Downloads/') || p === '/Downloads';
                    };
                    const confirmWrite = (title, preview, onConfirm) => {
                        const body = document.createElement('div');
                        const pre = document.createElement('pre');
                        pre.textContent = limitText(preview, 4096);
                        body.appendChild(pre);
                        modals.open({
                            title,
                            body,
                            actions: [
                                { label: 'Cancel', onClick: () => true },
                                { label: 'Confirm', primary: true, onClick: () => { onConfirm(); return true; } }
                            ]
                        });
                    };

                    const handleCommand = (text) => {
                        const [, cmd, rest] = text.match(/^\/(\w+)(?:\s+(.+))?$/) || [];
                        if (!cmd) return false;
                        if (cmd === 'open') {
                            const appId = (rest || '').trim();
                            if (!appId) { notifications?.notify('AI Assistant', 'Usage: /open <appId>'); return true; }
                            appManager.open(appId);
                            notifications?.notify('AI Assistant', `Opening ${appId}...`);
                            return true;
                        }
                        if (cmd === 'openurl') {
                            const url = (rest || '').trim();
                            if (!url) { notifications?.notify('AI Assistant', 'Usage: /openurl <url>'); return true; }
                            appManager.open('browser', { url });
                            notifications?.notify('AI Assistant', 'Opening URL in Browser...');
                            return true;
                        }
                        if (cmd === 'search') {
                            const term = (rest || '').trim();
                            if (!term) { notifications?.notify('AI Assistant', 'Usage: /search <term>'); return true; }
                            try {
                                const results = fileSystem.search(term).slice(0, 50);
                                const lines = results.map(r => `${r.type === 'directory' ? '📁' : '📄'} ${r.path}`);
                                addMessage('assistant', lines.length ? lines.join('\n') : 'No matches.');
                            } catch (e) {
                                addMessage('assistant', `Search error: ${e.message}`);
                            }
                            return true;
                        }
                        if (cmd === 'read') {
                            const path = (rest || '').trim();
                            if (!path) { notifications?.notify('AI Assistant', 'Usage: /read <path>'); return true; }
                            try {
                                const meta = fileSystem.readFileMeta(path);
                                const isText = /^text\//.test(meta.mime) || /json|xml|javascript|markdown|css|csv/.test(meta.mime);
                                if (!isText) {
                                    addMessage('assistant', `Not a text file (mime=${meta.mime}, size=${meta.size} bytes).`);
                                    return true;
                                }
                                const content = utils.base64ToText(meta.data);
                                addMessage('assistant', limitText(content, 16384));
                            } catch (e) {
                                addMessage('assistant', `Read error: ${e.message}`);
                            }
                            return true;
                        }
                        if (cmd === 'write' || cmd === 'append') {
                            const m = (rest || '').match(/^(\S+)\s+([\s\S]+)$/);
                            if (!m) { notifications?.notify('AI Assistant', `Usage: /${cmd} <path> <text>`); return true; }
                            const path = utils.normalize(m[1]);
                            const text = m[2];
                            if (!isSafeWritePath(path)) { addMessage('assistant', 'Write blocked: Only /Documents or /Downloads are allowed.'); return true; }
                            const doWrite = () => {
                                try {
                                    if (cmd === 'append') {
                                        let prev = '';
                                        try { prev = fileSystem.readFile(path); } catch {}
                                        fileSystem.writeFile(path, prev + text);
                                    } else {
                                        fileSystem.writeFile(path, text);
                                    }
                                    notifications?.notify('AI Assistant', `${cmd === 'append' ? 'Appended to' : 'Wrote'} ${path}`);
                                } catch (e) {
                                    addMessage('assistant', `Write error: ${e.message}`);
                                }
                            };
                            confirmWrite(`${cmd === 'append' ? 'Append to' : 'Write to'} ${path}?`, text, doWrite);
                            return true;
                        }
                        if (cmd === 'help') {
                            addMessage('assistant', [
                                'Commands:',
                                '/open <appId> — open an app (e.g., browser, text-editor, terminal, tasks, settings)',
                                '/openurl <url> — open a URL in the Browser app',
                                '/search <term> — search files/folders',
                                '/read <path> — read a text file (limited to ~16 KB output)',
                                '/write <path> <text> — write text to a file (only /Documents or /Downloads, confirmation required)',
                                '/append <path> <text> — append text to a file (same restrictions)',
                                '/help — show this help'
                            ].join('\n'));
                            return true;
                        }
                        notifications?.notify('AI Assistant', `Unknown command: /${cmd}`);
                        return true;
                    };

                    const send = async () => {
                        const input = composer.querySelector('#assistant-input');
                        const text = (input.value || '').trim();
                        if (!text) return;
                        input.value = '';

                        // Commands
                        if (text.startsWith('/')) {
                            if (handleCommand(text)) return;
                        }

                        addMessage('user', text);
                        messages.push({ role: 'user', content: text });

                        // Validate config
                        if (!cfg.apiKey) { notifications?.notify('AI Assistant', 'Please set your API key.'); return; }
                        const url = `${cfg.baseUrl.replace(/\/$/, '')}/chat/completions`;
                        try {
                            const res = await fetch(url, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${cfg.apiKey}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    model: cfg.model,
                                    messages
                                })
                            });
                            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
                            const data = await res.json();
                            const reply = data.choices?.[0]?.message?.content || '(no response)';
                            messages.push({ role: 'assistant', content: reply });
                            addMessage('assistant', reply);
                        } catch (error) {
                            addMessage('assistant', `Error: ${error.message}`);
                        }
                    };

                    composer.querySelector('#assistant-send').addEventListener('click', send);
                    composer.querySelector('#assistant-input').addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); }
                    });

                    // Basic styles
                    const style = document.createElement('style');
                    style.textContent = `
                      .assistant { display: flex; flex-direction: column; height: 100%; gap: 10px; }
                      .assistant-toolbar { display:flex; align-items:center; justify-content: space-between; gap: 12px; }
                      .assistant-settings { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 8px; padding: 8px 0; }
                      .assistant-settings label { display:flex; flex-direction: column; font-size: 12px; gap:4px; }
                      .assistant-hint { color: var(--text-muted); font-size: 12px; }
                      .assistant-chat { flex: 1; overflow: auto; border: var(--border-soft); border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.06); }
                      [data-theme="light"] .assistant-chat { background: rgba(0,0,0,0.04); }
                      .assistant-messages { display: flex; flex-direction: column; gap: 10px; }
                      .assistant-msg { display:flex; }
                      .assistant-msg.user { justify-content: flex-end; }
                      .assistant-msg .bubble { max-width: 70%; padding: 10px 12px; border-radius: 12px; white-space: pre-wrap; background: rgba(10,132,255,0.15); border: 1px solid rgba(10,132,255,0.25); }
                      .assistant-msg.user .bubble { background: rgba(88,110,255,0.18); border-color: rgba(88,110,255,0.28); }
                      .assistant-composer { display:flex; gap: 8px; }
                      .assistant-composer textarea { flex:1; resize: vertical; min-height: 42px; border-radius: 10px; border: var(--border-soft); padding: 8px; font-family: inherit; }
                    `;
                    root.appendChild(style);

                    return { element: root, width: '780px', height: '560px' };
                }
            };
        }
        function createNotesApp() {
            const STORAGE_KEY = STORAGE_KEYS.NOTES;
            const EXPORT_DIR = '/Documents/notes';
            const MAX_TITLE_LENGTH = 120;

            const createNoteObject = () => ({
                id: utils.uuid(),
                title: 'Untitled note',
                body: '',
                pinned: false,
                createdAt: utils.nowISO(),
                updatedAt: utils.nowISO()
            });

            const normalizeTitle = value => {
                if (!value) return 'Untitled note';
                const trimmed = String(value).trim();
                return trimmed || 'Untitled note';
            };

            const slugify = value => {
                if (!value) return 'note';
                return value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 48) || 'note';
            };

            const loadNotes = () => {
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (!raw) return [];
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) return [];
                    return parsed.map(note => ({
                        id: note.id || utils.uuid(),
                        title: normalizeTitle(note.title).slice(0, MAX_TITLE_LENGTH),
                        body: typeof note.body === 'string' ? note.body : '',
                        pinned: Boolean(note.pinned),
                        createdAt: note.createdAt || utils.nowISO(),
                        updatedAt: note.updatedAt || utils.nowISO()
                    }));
                } catch (error) {
                    console.warn('Failed to load notes', error);
                    return [];
                }
            };

            return {
                id: 'notes',
                name: 'Sticky Notes',
                icon: '📔',
                hint: 'Capture & organize ideas',
                launch({ context = {}, notifications, fileSystem, appManager }) {
                    let notes = loadNotes();
                    if (!notes.length) {
                        const starter = createNoteObject();
                        starter.body = 'Start typing to capture your thoughts.\n\nNotes autosave as you write.';
                        notes.push(starter);
                    }

                    let selectedId = null;
                    let filterText = (context.query || '').toLowerCase();
                    let showPinnedOnly = Boolean(context.filter === 'pinned');
                    let isApplyingEditorState = false;

                    const normalizeOrder = () => {
                        notes.sort((a, b) => {
                            if (a.pinned !== b.pinned) return a.pinned ? -1 : 1;
                            return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
                        });
                    };

                    const persist = () => {
                        normalizeOrder();
                        try {
                            localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
                        } catch (error) {
                            console.warn('Failed to save notes', error);
                        }
                    };

                    const getNoteById = id => notes.find(note => note.id === id) || null;

                    normalizeOrder();

                    if (context.create) {
                        const newNote = createNoteObject();
                        notes.unshift(newNote);
                        selectedId = newNote.id;
                        persist();
                        notifications?.notify('Sticky Notes', 'New note created.');
                    }

                    if (!selectedId) {
                        if (context.noteId && getNoteById(context.noteId)) {
                            selectedId = context.noteId;
                        } else if (context.openLast && notes.length) {
                            const newest = [...notes].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())[0];
                            selectedId = newest?.id || notes[0]?.id || null;
                        } else {
                            selectedId = notes[0]?.id || null;
                        }
                    }

                    const root = utils.createEl('div', 'notes-app');
                    const sidebar = utils.createEl('aside', 'notes-sidebar');
                    const editor = utils.createEl('section', 'notes-editor');

                    const header = document.createElement('header');
                    const newButton = utils.createEl('button', '', { text: '＋ New' });
                    const pinnedToggle = utils.createEl('button', '', { text: 'Only pinned', 'aria-pressed': 'false' });
                    header.append(newButton, pinnedToggle);

                    const searchInput = utils.createEl('input', 'notes-search', {
                        type: 'search',
                        placeholder: 'Search notes',
                        autocomplete: 'off'
                    });
                    const listEl = utils.createEl('div', 'notes-list');
                    sidebar.append(header, searchInput, listEl);

                    const toolbar = utils.createEl('div', 'notes-toolbar');
                    const exportButton = utils.createEl('button', '', { text: 'Export to file' });
                    const editorButton = utils.createEl('button', '', { text: 'Open in Text Studio' });
                    const deleteButton = utils.createEl('button', '', { text: 'Delete note' });
                    toolbar.append(exportButton, editorButton, deleteButton);

                    const titleInput = utils.createEl('input', 'notes-title', {
                        type: 'text',
                        placeholder: 'Untitled note'
                    });
                    const bodyInput = utils.createEl('textarea', 'notes-body', {
                        placeholder: 'Start typing…'
                    });
                    const metaEl = utils.createEl('div', 'notes-meta');
                    editor.append(toolbar, titleInput, bodyInput, metaEl);

                    root.append(sidebar, editor);

                    const refreshMeta = note => {
                        if (!note) {
                            metaEl.textContent = 'No note selected.';
                            return;
                        }
                        const parts = [];
                        parts.push(`Updated ${utils.relativeTime(note.updatedAt)}`);
                        parts.push(`Created ${new Date(note.createdAt).toLocaleString()}`);
                        if (note.pinned) parts.push('Pinned');
                        metaEl.textContent = parts.join(' · ');
                    };

                    const ensureSelection = matches => {
                        if (matches.length && !matches.some(note => note.id === selectedId)) {
                            selectedId = matches[0].id;
                            return true;
                        }
                        if (!matches.length) {
                            selectedId = null;
                            return true;
                        }
                        return false;
                    };

                    const renderList = () => {
                        normalizeOrder();
                        const query = filterText.trim().toLowerCase();
                        const matches = notes.filter(note => {
                            if (showPinnedOnly && !note.pinned) return false;
                            if (!query) return true;
                            return note.title.toLowerCase().includes(query) || note.body.toLowerCase().includes(query);
                        });
                        const selectionChanged = ensureSelection(matches);
                        const scrollTop = listEl.scrollTop;
                        listEl.innerHTML = '';
                        if (!matches.length) {
                            listEl.appendChild(utils.createEl('div', 'notes-empty', { text: query ? 'No notes match your search.' : 'No notes yet.' }));
                        } else {
                            matches.forEach(note => {
                                const item = utils.createEl('div', 'note-list-item');
                                if (note.id === selectedId) item.classList.add('active');
                                const itemHeader = utils.createEl('div', 'note-item-header');
                                const title = utils.createEl('span', 'note-item-title', { text: note.title });
                                const pin = utils.createEl('button', 'note-pin', { text: note.pinned ? '★' : '☆', title: note.pinned ? 'Unpin note' : 'Pin note' });
                                pin.addEventListener('click', event => {
                                    event.stopPropagation();
                                    const target = getNoteById(note.id);
                                    if (!target) return;
                                    target.pinned = !target.pinned;
                                    target.updatedAt = utils.nowISO();
                                    persist();
                                    refreshMeta(getNoteById(selectedId));
                                    renderList();
                                    notifications?.notify('Sticky Notes', target.pinned ? 'Note pinned.' : 'Pin removed.');
                                });
                                itemHeader.append(title, pin);
                                const meta = utils.createEl('div', 'note-item-meta');
                                const preview = note.body.replace(/\s+/g, ' ').trim().slice(0, 70);
                                const relative = utils.relativeTime(note.updatedAt);
                                meta.textContent = preview ? `${relative} · ${preview}` : relative;
                                item.append(itemHeader, meta);
                                item.addEventListener('click', () => {
                                    if (selectedId === note.id) return;
                                    selectedId = note.id;
                                    renderList();
                                    renderEditor();
                                });
                                listEl.appendChild(item);
                            });
                        }
                        listEl.scrollTop = scrollTop;
                        pinnedToggle.textContent = showPinnedOnly ? 'Show all' : 'Only pinned';
                        pinnedToggle.setAttribute('aria-pressed', showPinnedOnly ? 'true' : 'false');
                        if (selectionChanged) renderEditor();
                    };

                    const renderEditor = () => {
                        const note = getNoteById(selectedId);
                        const enabled = Boolean(note);
                        [titleInput, bodyInput, exportButton, editorButton, deleteButton].forEach(control => {
                            control.disabled = !enabled;
                        });
                        if (!note) {
                            isApplyingEditorState = true;
                            titleInput.value = '';
                            bodyInput.value = '';
                            isApplyingEditorState = false;
                            refreshMeta(null);
                            return;
                        }
                        isApplyingEditorState = true;
                        titleInput.value = note.title;
                        bodyInput.value = note.body;
                        isApplyingEditorState = false;
                        refreshMeta(note);
                    };

                    const saveTitle = utils.debounce(value => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        note.title = value.slice(0, MAX_TITLE_LENGTH);
                        note.updatedAt = utils.nowISO();
                        persist();
                        refreshMeta(note);
                        renderList();
                    }, 180);

                    const saveBody = utils.debounce(value => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        note.body = value;
                        note.updatedAt = utils.nowISO();
                        persist();
                        refreshMeta(note);
                        renderList();
                    }, 220);

                    const ensureFile = note => {
                        try {
                            if (!fileSystem.exists(EXPORT_DIR)) fileSystem.createDirectory(EXPORT_DIR);
                        } catch (error) {
                            console.warn('Failed to ensure notes directory', error);
                        }
                        const slug = slugify(note.title || 'note') || note.id;
                        const path = `${EXPORT_DIR}/${slug}.md`;
                        const content = `# ${normalizeTitle(note.title)}\n\n${note.body}`;
                        try {
                            if (fileSystem.exists(path)) fileSystem.writeFile(path, content, { encoding: 'utf-8', mime: 'text/markdown' });
                            else fileSystem.createFile(path, content, { encoding: 'utf-8', mime: 'text/markdown' });
                            return path;
                        } catch (error) {
                            notifications?.notify('Sticky Notes', error.message || 'Unable to export note.');
                            return null;
                        }
                    };

                    newButton.addEventListener('click', () => {
                        const note = createNoteObject();
                        notes.unshift(note);
                        selectedId = note.id;
                        persist();
                        renderList();
                        renderEditor();
                        notifications?.notify('Sticky Notes', 'New note created.');
                        setTimeout(() => titleInput.focus(), 60);
                    });

                    pinnedToggle.addEventListener('click', () => {
                        showPinnedOnly = !showPinnedOnly;
                        renderList();
                    });

                    searchInput.value = filterText;
                    searchInput.addEventListener('input', utils.debounce(() => {
                        filterText = searchInput.value;
                        renderList();
                    }, 140));

                    titleInput.addEventListener('input', () => {
                        if (isApplyingEditorState) return;
                        saveTitle(titleInput.value);
                    });
                    titleInput.addEventListener('blur', () => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        note.title = normalizeTitle(titleInput.value).slice(0, MAX_TITLE_LENGTH);
                        persist();
                        renderList();
                        refreshMeta(note);
                        if (titleInput.value !== note.title) {
                            isApplyingEditorState = true;
                            titleInput.value = note.title;
                            isApplyingEditorState = false;
                        }
                    });

                    bodyInput.addEventListener('input', () => {
                        if (isApplyingEditorState) return;
                        saveBody(bodyInput.value);
                    });

                    exportButton.addEventListener('click', () => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        const path = ensureFile(note);
                        if (path) notifications?.notify('Sticky Notes', `Exported to ${path}`);
                    });

                    editorButton.addEventListener('click', () => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        const path = ensureFile(note);
                        if (path) appManager.open('text-editor', { path });
                    });

                    deleteButton.addEventListener('click', () => {
                        const note = getNoteById(selectedId);
                        if (!note) return;
                        if (!confirm(`Delete "${note.title}"? This cannot be undone.`)) return;
                        notes = notes.filter(entry => entry.id !== note.id);
                        persist();
                        selectedId = notes[0]?.id || null;
                        renderList();
                        renderEditor();
                        notifications?.notify('Sticky Notes', 'Note deleted.');
                    });

                    renderList();
                    renderEditor();
                    if (context.create) setTimeout(() => titleInput.focus(), 80);

                    return {
                        element: root,
                        width: '840px',
                        height: '560px',
                        onClose: () => persist()
                    };
                }
            };
        }
        function createSystemMonitorApp() {
            const formatDuration = ms => {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                const segments = [];
                if (hours) segments.push(`${hours}h`);
                segments.push(`${minutes}m`);
                segments.push(`${seconds}s`);
                return segments.join(' ');
            };

            const createRow = label => {
                const li = document.createElement('li');
                const name = document.createElement('span');
                name.textContent = label;
                const value = document.createElement('span');
                li.append(name, value);
                return { li, value };
            };

            const createCard = title => {
                const card = utils.createEl('div', 'monitor-card');
                const heading = document.createElement('h3');
                heading.textContent = title;
                card.appendChild(heading);
                return card;
            };

            return {
                id: 'system-monitor',
                name: 'System Monitor',
                icon: '📊',
                hint: 'Runtime diagnostics',
                launch({ context = {}, notifications }) {
                    const app = utils.createEl('div', 'monitor-app');
                    const actions = utils.createEl('div', 'monitor-actions');
                    const snapshotButton = utils.createEl('button', '', { text: 'Copy snapshot' });
                    const resetButton = utils.createEl('button', '', { text: 'Reset history' });
                    actions.append(snapshotButton, resetButton);
                    const grid = utils.createEl('div', 'monitor-grid');
                    app.append(actions, grid);

                    const overviewCard = createCard('Runtime');
                    const uptimeDisplay = utils.createEl('div', 'monitor-highlight', { text: '0s' });
                    const overviewList = utils.createEl('ul', 'monitor-list');
                    const lagRow = createRow('Event loop lag');
                    const fpsRow = createRow('Approx FPS');
                    const loadRow = createRow('Loop load');
                    overviewList.append(lagRow.li, fpsRow.li, loadRow.li);
                    overviewCard.append(uptimeDisplay, overviewList);

                    const resourcesCard = createCard('Resources');
                    const resourcesList = utils.createEl('ul', 'monitor-list');
                    const memoryRow = createRow('Memory usage');
                    const heapRow = createRow('JS heap limit');
                    const coresRow = createRow('CPU cores');
                    const deviceRow = createRow('Device memory');
                    resourcesList.append(memoryRow.li, heapRow.li, coresRow.li, deviceRow.li);
                    resourcesCard.append(resourcesList);

                    const environmentCard = createCard('Environment');
                    const environmentList = utils.createEl('ul', 'monitor-list');
                    const networkRow = createRow('Network');
                    const downlinkRow = createRow('Downlink');
                    const batteryRow = createRow('Battery');
                    const userAgentRow = createRow('User agent');
                    environmentList.append(networkRow.li, downlinkRow.li, batteryRow.li, userAgentRow.li);
                    environmentCard.append(environmentList);

                    const timelineCard = createCard('Event loop history');
                    const chartCanvas = document.createElement('canvas');
                    chartCanvas.className = 'monitor-chart';
                    timelineCard.appendChild(chartCanvas);

                    grid.append(overviewCard, resourcesCard, environmentCard, timelineCard);

                    const metrics = {
                        lag: 0,
                        fps: 0,
                        memoryUsed: null,
                        memoryLimit: null,
                        battery: null,
                        downlink: null
                    };

                    const lagSamples = [];
                    const cleanupFns = [];
                    let lagTimer = null;
                    let updateTimer = null;
                    let rafId = null;

                    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

                    const adjustCanvas = () => {
                        const ratio = window.devicePixelRatio || 1;
                        const width = chartCanvas.clientWidth || 480;
                        const height = chartCanvas.clientHeight || 140;
                        chartCanvas.width = Math.floor(width * ratio);
                        chartCanvas.height = Math.floor(height * ratio);
                    };

                    const drawChart = () => {
                        const ctx = chartCanvas.getContext('2d');
                        if (!ctx) return;
                        const ratio = window.devicePixelRatio || 1;
                        const width = chartCanvas.width / ratio;
                        const height = chartCanvas.height / ratio;
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        ctx.scale(ratio, ratio);
                        ctx.clearRect(0, 0, width, height);
                        ctx.strokeStyle = 'rgba(123, 139, 255, 0.65)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const max = Math.max(16, ...lagSamples, 16);
                        lagSamples.forEach((value, index) => {
                            const x = (index / Math.max(1, lagSamples.length - 1)) * width;
                            const y = height - (value / max) * height;
                            if (index === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        });
                        ctx.stroke();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, height * 0.5);
                        ctx.lineTo(width, height * 0.5);
                        ctx.stroke();
                    };

                    const pushLagSample = value => {
                        lagSamples.push(value);
                        const limit = 220;
                        if (lagSamples.length > limit) lagSamples.splice(0, lagSamples.length - limit);
                        drawChart();
                    };

                    const updateOverview = () => {
                        uptimeDisplay.textContent = formatDuration(performance.now());
                        lagRow.value.textContent = `${metrics.lag.toFixed(1)} ms`;
                        fpsRow.value.textContent = metrics.fps ? `${metrics.fps} fps` : 'Measuring…';
                        const load = Math.min(100, Math.round((metrics.lag / 50) * 100));
                        loadRow.value.textContent = `${load}%`;
                    };

                    const updateResources = () => {
                        const memory = performance.memory;
                        if (memory) {
                            metrics.memoryUsed = memory.usedJSHeapSize;
                            metrics.memoryLimit = memory.jsHeapSizeLimit;
                            memoryRow.value.textContent = `${utils.formatBytes(metrics.memoryUsed)} / ${utils.formatBytes(metrics.memoryLimit)}`;
                            heapRow.value.textContent = utils.formatBytes(memory.totalJSHeapSize || memory.jsHeapSizeLimit);
                        } else {
                            memoryRow.value.textContent = 'Unavailable';
                            heapRow.value.textContent = 'Unavailable';
                        }
                        coresRow.value.textContent = navigator.hardwareConcurrency ? `${navigator.hardwareConcurrency} cores` : 'Unknown';
                        deviceRow.value.textContent = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';
                    };

                    const updateEnvironment = () => {
                        networkRow.value.textContent = navigator.onLine ? 'Online' : 'Offline';
                        if (connection) {
                            const down = typeof connection.downlink === 'number' ? connection.downlink : null;
                            metrics.downlink = down ? `${down.toFixed(1)} Mbps` : 'Unknown';
                            const typeLabel = connection.effectiveType ? ` (${connection.effectiveType})` : '';
                            downlinkRow.value.textContent = down ? `${metrics.downlink}${typeLabel}` : `Unknown${typeLabel}`;
                        } else {
                            downlinkRow.value.textContent = 'Unavailable';
                        }
                        if (metrics.battery) {
                            const level = `${Math.round(metrics.battery.level * 100)}%`;
                            batteryRow.value.textContent = metrics.battery.charging ? `${level} · Charging` : level;
                        } else {
                            batteryRow.value.textContent = 'Unavailable';
                        }
                        const agent = navigator.userAgent || 'Unknown';
                        userAgentRow.value.textContent = agent.length > 80 ? `${agent.slice(0, 77)}…` : agent;
                    };

                    const updateNetworkStatus = () => {
                        updateEnvironment();
                    };

                    const copySnapshot = () => {
                        updateResources();
                        updateEnvironment();
                        updateOverview();
                        const typeLabel = connection?.effectiveType ? ` (${connection.effectiveType})` : '';
                        const lines = [
                            `Uptime: ${formatDuration(performance.now())}`,
                            `Event loop lag: ${metrics.lag.toFixed(1)} ms`,
                            `Approx FPS: ${metrics.fps || 'Measuring'}`,
                            metrics.memoryUsed ? `Memory: ${utils.formatBytes(metrics.memoryUsed)} of ${utils.formatBytes(metrics.memoryLimit)}` : 'Memory: Unavailable',
                            `Cores: ${navigator.hardwareConcurrency || 'Unknown'}`,
                            `Network: ${navigator.onLine ? 'Online' : 'Offline'}${typeLabel}`,
                            metrics.downlink ? `Downlink: ${metrics.downlink}` : 'Downlink: Unavailable',
                            metrics.battery ? `Battery: ${Math.round(metrics.battery.level * 100)}%${metrics.battery.charging ? ' (charging)' : ''}` : 'Battery: Unavailable',
                            `User agent: ${navigator.userAgent || 'Unknown'}`
                        ].join('\n');
                        if (navigator.clipboard?.writeText) {
                            navigator.clipboard.writeText(lines).then(() => {
                                notifications?.notify('System Monitor', 'Snapshot copied to clipboard.');
                            }).catch(() => {
                                notifications?.notify('System Monitor', 'Unable to copy snapshot.');
                            });
                        } else {
                            prompt('Copy system snapshot', lines);
                        }
                    };

                    const resetHistory = () => {
                        lagSamples.length = 0;
                        drawChart();
                        notifications?.notify('System Monitor', 'Event loop history cleared.');
                    };

                    snapshotButton.addEventListener('click', copySnapshot);
                    resetButton.addEventListener('click', resetHistory);

                    const handleConnectionChange = () => {
                        updateEnvironment();
                    };

                    if (connection?.addEventListener) {
                        connection.addEventListener('change', handleConnectionChange, { passive: true });
                        cleanupFns.push(() => connection.removeEventListener('change', handleConnectionChange));
                    }

                    if (navigator.getBattery) {
                        navigator.getBattery().then(battery => {
                            metrics.battery = battery;
                            updateEnvironment();
                            const rerender = () => {
                                metrics.battery = battery;
                                updateEnvironment();
                            };
                            battery.addEventListener('levelchange', rerender);
                            battery.addEventListener('chargingchange', rerender);
                            cleanupFns.push(() => {
                                battery.removeEventListener('levelchange', rerender);
                                battery.removeEventListener('chargingchange', rerender);
                            });
                        }).catch(() => {
                            metrics.battery = null;
                        });
                    }

                    window.addEventListener('online', updateNetworkStatus);
                    window.addEventListener('offline', updateNetworkStatus);
                    cleanupFns.push(() => {
                        window.removeEventListener('online', updateNetworkStatus);
                        window.removeEventListener('offline', updateNetworkStatus);
                    });

                    const measureLag = () => {
                        let lastTick = performance.now();
                        lagTimer = setInterval(() => {
                            const now = performance.now();
                            const lag = Math.max(0, now - lastTick - 1000);
                            lastTick = now;
                            metrics.lag = lag;
                            pushLagSample(lag);
                            updateOverview();
                        }, 1000);
                    };

                    const measureFps = () => {
                        let frames = 0;
                        let lastTime = performance.now();
                        const loop = timestamp => {
                            frames += 1;
                            if (timestamp - lastTime >= 1000) {
                                metrics.fps = Math.round((frames * 1000) / (timestamp - lastTime));
                                frames = 0;
                                lastTime = timestamp;
                                updateOverview();
                            }
                            rafId = requestAnimationFrame(loop);
                        };
                        rafId = requestAnimationFrame(loop);
                    };

                    measureLag();
                    measureFps();
                    updateResources();
                    updateEnvironment();
                    adjustCanvas();
                    drawChart();

                    const resizeHandler = utils.debounce(() => {
                        adjustCanvas();
                        drawChart();
                    }, 180);
                    window.addEventListener('resize', resizeHandler);
                    cleanupFns.push(() => window.removeEventListener('resize', resizeHandler));

                    updateTimer = setInterval(() => {
                        updateResources();
                        updateEnvironment();
                        updateOverview();
                    }, 2000);

                    if (context.snapshot) {
                        setTimeout(copySnapshot, 600);
                    }

                    return {
                        element: app,
                        width: '820px',
                        height: '540px',
                        onClose: () => {
                            if (lagTimer) clearInterval(lagTimer);
                            if (updateTimer) clearInterval(updateTimer);
                            if (rafId) cancelAnimationFrame(rafId);
                            cleanupFns.forEach(fn => fn());
                        }
                    };
                }
            };
        }
        function createTasksApp() {
            return {
                id: 'tasks',
                name: 'Task Command',
                icon: '✅',
                launch({ context = {}, fileSystem, notifications }) {
                    const TASKS_FILE = '/System/tasks.json';
                    const DEFAULT_PROJECTS = [
                        { id: 'inbox', name: 'Inbox', color: '#7b8bff', builtIn: true }
                    ];
                    const PRIORITIES = [
                        { id: 'low', label: 'Low' },
                        { id: 'normal', label: 'Normal' },
                        { id: 'high', label: 'High' },
                        { id: 'urgent', label: 'Urgent' }
                    ];
                    const priorityWeight = { low: 0, normal: 1, high: 2, urgent: 3 };

                    const load = () => {
                        try {
                            const raw = localStorage.getItem(STORAGE_KEYS.TASKS);
                            if (raw) return JSON.parse(raw);
                        } catch (error) {
                            console.warn('Failed to parse stored tasks', error);
                        }
                        try {
                            if (fileSystem.exists(TASKS_FILE)) {
                                const text = fileSystem.readFile(TASKS_FILE, { encoding: 'utf-8' });
                                const parsed = JSON.parse(text);
                                localStorage.setItem(STORAGE_KEYS.TASKS, JSON.stringify(parsed));
                                return parsed;
                            }
                        } catch (error) {
                            console.warn('Failed to load tasks from file system', error);
                        }
                        return { projects: DEFAULT_PROJECTS.map(project => ({ ...project })), tasks: [] };
                    };

                    const normalize = (raw) => {
                        const result = { projects: [], tasks: [] };
                        const seen = new Map();
                        const ensureProject = (project, forceBuiltIn = false) => {
                            if (!project || !project.id) return;
                            if (seen.has(project.id)) {
                                const existing = seen.get(project.id);
                                existing.name = project.name || existing.name;
                                if (project.color) existing.color = project.color;
                                if (forceBuiltIn || project.builtIn) existing.builtIn = true;
                                return;
                            }
                            const entry = {
                                id: project.id,
                                name: project.name || 'Untitled',
                                color: project.color || '#7b8bff',
                                builtIn: Boolean(project.builtIn || forceBuiltIn)
                            };
                            seen.set(entry.id, entry);
                            result.projects.push(entry);
                        };
                        DEFAULT_PROJECTS.forEach(project => ensureProject(project, true));
                        (raw?.projects || []).forEach(project => ensureProject(project));
                        const projectSet = new Set(result.projects.map(project => project.id));
                        (raw?.tasks || []).forEach(task => {
                            if (!task) return;
                            const id = task.id || utils.uuid();
                            const title = (task.title ? String(task.title).trim() : '') || 'Untitled Task';
                            const dueValid = task.dueAt && !Number.isNaN(new Date(task.dueAt).getTime()) ? task.dueAt : null;
                            const completedValid = task.completedAt && !Number.isNaN(new Date(task.completedAt).getTime()) ? task.completedAt : null;
                            result.tasks.push({
                                id,
                                title,
                                notes: task.notes ? String(task.notes) : '',
                                projectId: projectSet.has(task.projectId) ? task.projectId : 'inbox',
                                dueAt: dueValid,
                                priority: PRIORITIES.some(entry => entry.id === task.priority) ? task.priority : 'normal',
                                focus: Boolean(task.focus),
                                createdAt: task.createdAt || utils.nowISO(),
                                updatedAt: task.updatedAt || utils.nowISO(),
                                completedAt: completedValid
                            });
                        });
                        return result;
                    };

                    const state = {
                        data: normalize(load()),
                        filter: { type: 'smart', value: 'all' },
                        search: '',
                        selectedTaskId: null,
                        focusSessionActive: false,
                        focusSkipped: new Set()
                    };

                    const initial = state.data.tasks.find(task => !task.completedAt) || state.data.tasks[0];
                    state.selectedTaskId = initial ? initial.id : null;

                    const shell = utils.createEl('div', 'app-shell task-app');
                    const sidebar = utils.createEl('aside', 'task-sidebar');
                    const main = utils.createEl('section', 'task-main');
                    const detail = utils.createEl('aside', 'task-detail');
                    shell.append(sidebar, main, detail);

                    const sidebarHeader = document.createElement('header');
                    const sidebarTitle = document.createElement('h3');
                    sidebarTitle.textContent = 'Navigator';
                    const captureButton = utils.createEl('button', '', { type: 'button', text: 'New Task' });
                    sidebarHeader.append(sidebarTitle, captureButton);
                    const filterList = utils.createEl('ul', 'task-filter-list');
                    const projectsTitle = document.createElement('h3');
                    projectsTitle.textContent = 'Projects';
                    const projectList = utils.createEl('ul', 'task-project-list');
                    const projectForm = utils.createEl('form', 'task-new-project');
                    const projectNameInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-project-name',
                        name: 'project-name',
                        placeholder: 'Project name',
                        required: 'true'
                    });
                    const projectNameLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-project-name',
                        text: 'Project name'
                    });
                    const projectColorInput = utils.createEl('input', '', {
                        type: 'color',
                        id: 'task-project-colour',
                        name: 'project-colour',
                        value: '#64b5ff'
                    });
                    const projectColorLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-project-colour',
                        text: 'Project colour'
                    });
                    const projectAddButton = utils.createEl('button', '', { type: 'submit', text: 'Add' });
                    projectForm.append(projectNameLabel, projectNameInput, projectColorLabel, projectColorInput, projectAddButton);
                    sidebar.append(sidebarHeader, filterList, projectsTitle, projectList, projectForm);

                    const toolbar = utils.createEl('div', 'task-toolbar');
                    const quickAddInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-quick-add',
                        name: 'task-quick-add',
                        placeholder: 'Capture a task and press Enter',
                        autocomplete: 'off'
                    });
                    const quickAddLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-quick-add',
                        text: 'Quick add task'
                    });
                    const focusButton = utils.createEl('button', '', { type: 'button', text: 'Start Focus' });
                    const searchInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-search',
                        name: 'task-search',
                        placeholder: 'Search tasks'
                    });
                    const searchLabel = utils.createEl('label', 'visually-hidden', {
                        for: 'task-search',
                        text: 'Search tasks'
                    });
                    searchInput.style.flex = '0 0 220px';
                    searchInput.value = state.search;
                    toolbar.append(quickAddLabel, quickAddInput, focusButton, searchLabel, searchInput);
                    const taskList = utils.createEl('div', 'task-list');
                    const focusPanel = utils.createEl('div', 'task-focus-panel');
                    main.append(toolbar, taskList, focusPanel);

                    const detailHeader = document.createElement('h3');
                    detailHeader.textContent = 'Task Detail';
                    const detailEmpty = utils.createEl('div', 'task-detail-empty', { text: 'Select a task or capture a new one to get started.' });
                    const detailForm = utils.createEl('div', 'task-detail-form');
                    const titleInput = utils.createEl('input', '', {
                        type: 'text',
                        id: 'task-detail-title',
                        name: 'task-title'
                    });
                    const projectSelect = document.createElement('select');
                    projectSelect.id = 'task-detail-project';
                    projectSelect.name = 'task-project';
                    const prioritySelect = document.createElement('select');
                    prioritySelect.id = 'task-detail-priority';
                    prioritySelect.name = 'task-priority';
                    PRIORITIES.forEach(priority => {
                        const option = document.createElement('option');
                        option.value = priority.id;
                        option.textContent = priority.label;
                        prioritySelect.appendChild(option);
                    });
                    const dueInput = utils.createEl('input', '', {
                        type: 'datetime-local',
                        id: 'task-detail-due',
                        name: 'task-due'
                    });
                    const focusToggleRow = utils.createEl('div', 'task-detail-row');
                    const focusLabel = document.createElement('label');
                    focusLabel.setAttribute('for', 'task-detail-focus');
                    const focusInput = document.createElement('input');
                    focusInput.type = 'checkbox';
                    focusInput.id = 'task-detail-focus';
                    focusInput.name = 'task-focus';
                    focusLabel.append(focusInput, document.createTextNode(' Add to focus queue'));
                    focusToggleRow.append(focusLabel);
                    const notesInput = document.createElement('textarea');
                    notesInput.id = 'task-detail-notes';
                    notesInput.name = 'task-notes';
                    const metaBlock = utils.createEl('div', 'task-meta');
                    const footer = document.createElement('footer');
                    const completeButton = document.createElement('button');
                    const deleteButton = document.createElement('button');
                    deleteButton.classList.add('danger');
                    deleteButton.textContent = 'Delete';
                    completeButton.type = 'button';
                    deleteButton.type = 'button';
                    footer.append(completeButton, deleteButton);

                    const createRow = (labelText, control) => {
                        const row = utils.createEl('div', 'task-detail-row');
                        const label = document.createElement('label');
                        label.textContent = labelText;
                        if (control.id) label.setAttribute('for', control.id);
                        row.append(label, control);
                        return row;
                    };

                    detailForm.append(
                        createRow('Title', titleInput),
                        createRow('Project', projectSelect),
                        createRow('Priority', prioritySelect),
                        createRow('Due', dueInput),
                        focusToggleRow,
                        createRow('Notes', notesInput),
                        metaBlock,
                        footer
                    );
                    detail.append(detailHeader, detailEmpty, detailForm);

                    const getProjectById = (id) => state.data.projects.find(project => project.id === id) || null;

                    function getDateBounds() {
                        const now = new Date();
                        const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                        const endOfToday = new Date(startOfToday.getTime() + 86_400_000);
                        const upcomingLimit = new Date(startOfToday.getTime() + 8 * 86_400_000);
                        return { startOfToday, endOfToday, upcomingLimit };
                    }

                    function sortTasks(tasks) {
                        return tasks.sort((a, b) => {
                            const completedDiff = (a.completedAt ? 1 : 0) - (b.completedAt ? 1 : 0);
                            if (completedDiff !== 0) return completedDiff;
                            const aDue = a.dueAt ? new Date(a.dueAt).getTime() : Infinity;
                            const bDue = b.dueAt ? new Date(b.dueAt).getTime() : Infinity;
                            if (aDue !== bDue) return aDue - bDue;
                            const priorityDiff = priorityWeight[b.priority] - priorityWeight[a.priority];
                            if (priorityDiff !== 0) return priorityDiff;
                            const updatedDiff = new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
                            if (updatedDiff !== 0) return updatedDiff;
                            return a.title.localeCompare(b.title);
                        });
                    }

                    function getDueInfo(task) {
                        if (!task.dueAt) return null;
                        const due = new Date(task.dueAt);
                        if (Number.isNaN(due.getTime())) return null;
                        const diff = due.getTime() - Date.now();
                        if (Math.abs(diff) < 60_000) return { label: 'Due now', className: 'due-soon' };
                        if (diff < -60_000) return { label: utils.relativeTime(due), className: 'overdue' };
                        if (diff < 3 * 86_400_000) return { label: utils.relativeTime(due), className: 'due-soon' };
                        return { label: due.toLocaleDateString(), className: '' };
                    }

                    function countForFilter(id) {
                        const { endOfToday, upcomingLimit } = getDateBounds();
                        switch (id) {
                            case 'all':
                                return state.data.tasks.filter(task => !task.completedAt).length;
                            case 'today':
                                return state.data.tasks.filter(task => {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due < endOfToday;
                                }).length;
                            case 'upcoming':
                                return state.data.tasks.filter(task => {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due >= endOfToday && due < upcomingLimit;
                                }).length;
                            case 'focus':
                                return state.data.tasks.filter(task => task.focus && !task.completedAt).length;
                            case 'completed':
                                return state.data.tasks.filter(task => task.completedAt).length;
                            default:
                                return 0;
                        }
                    }

                    function getFilteredTasks() {
                        const { endOfToday, upcomingLimit } = getDateBounds();
                        const query = state.search.trim().toLowerCase();
                        return state.data.tasks.filter(task => {
                            const matchesQuery = !query || task.title.toLowerCase().includes(query) || task.notes.toLowerCase().includes(query);
                            if (!matchesQuery) return false;
                            if (state.filter.type === 'project') {
                                if (task.projectId !== state.filter.value) return false;
                                return !task.completedAt;
                            }
                            switch (state.filter.value) {
                                case 'all':
                                    return !task.completedAt;
                                case 'today': {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due < endOfToday;
                                }
                                case 'upcoming': {
                                    if (task.completedAt || !task.dueAt) return false;
                                    const due = new Date(task.dueAt);
                                    if (Number.isNaN(due.getTime())) return false;
                                    return due >= endOfToday && due < upcomingLimit;
                                }
                                case 'focus':
                                    return task.focus && !task.completedAt;
                                case 'completed':
                                    return Boolean(task.completedAt);
                                default:
                                    return !task.completedAt;
                            }
                        });
                    }

                    function renderFilters() {
                        const filters = [
                            { id: 'all', label: 'All tasks', icon: '📋' },
                            { id: 'today', label: 'Today', icon: '🗓️' },
                            { id: 'upcoming', label: 'Upcoming', icon: '📅' },
                            { id: 'focus', label: 'Focus', icon: '🎯' },
                            { id: 'completed', label: 'Completed', icon: '✅' }
                        ];
                        filterList.innerHTML = '';
                        filters.forEach(filter => {
                            const item = utils.createEl('li', 'task-filter-item');
                            if (state.filter.type === 'smart' && state.filter.value === filter.id) item.classList.add('active');
                            const icon = document.createElement('span');
                            icon.textContent = filter.icon;
                            const label = document.createElement('strong');
                            label.textContent = filter.label;
                            const count = utils.createEl('span', 'count', { text: String(countForFilter(filter.id)) });
                            item.append(icon, label, count);
                            item.addEventListener('click', () => {
                                if (state.filter.type === 'smart' && state.filter.value === filter.id) return;
                                setFilter('smart', filter.id);
                            });
                            filterList.appendChild(item);
                        });
                    }

                    function renderProjects() {
                        projectList.innerHTML = '';
                        state.data.projects.forEach(project => {
                            const item = utils.createEl('li', 'task-project-item');
                            if (state.filter.type === 'project' && state.filter.value === project.id) item.classList.add('active');
                            const colorDot = utils.createEl('span', 'task-project-color');
                            colorDot.style.background = project.color;
                            const label = document.createElement('strong');
                            label.textContent = project.name;
                            const count = utils.createEl('span', 'count', { text: String(state.data.tasks.filter(task => task.projectId === project.id && !task.completedAt).length) });
                            item.append(colorDot, label, count);
                            if (!project.builtIn) {
                                const remove = document.createElement('button');
                                remove.type = 'button';
                                remove.textContent = '✕';
                                remove.title = 'Delete project';
                                remove.addEventListener('click', event => {
                                    event.stopPropagation();
                                    if (confirm(`Remove project "${project.name}"? Tasks will move to Inbox.`)) {
                                        deleteProject(project.id);
                                    }
                                });
                                item.appendChild(remove);
                            }
                            item.addEventListener('click', () => setFilter('project', project.id));
                            projectList.appendChild(item);
                        });
                    }

                    function renderTaskList() {
                        const visibleTasks = sortTasks(getFilteredTasks().slice());
                        taskList.innerHTML = '';
                        taskList.style.display = state.focusSessionActive ? 'none' : 'flex';
                        if (state.focusSessionActive) return;
                        if (!visibleTasks.some(task => task.id === state.selectedTaskId)) {
                            state.selectedTaskId = visibleTasks[0]?.id || null;
                        }
                        if (!visibleTasks.length) {
                            const emptyMessage = state.search ? 'No tasks match your filters yet.' : 'No tasks here yet. Capture something above.';
                            taskList.appendChild(utils.createEl('div', 'task-detail-empty', { text: emptyMessage }));
                            return;
                        }
                        visibleTasks.forEach(task => {
                            const card = utils.createEl('div', 'task-card');
                            card.dataset.id = task.id;
                            if (task.id === state.selectedTaskId) card.classList.add('active');
                            if (task.completedAt) card.classList.add('completed');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = Boolean(task.completedAt);
                            card.appendChild(checkbox);
                            const body = document.createElement('div');
                            const title = document.createElement('h4');
                            title.textContent = task.title;
                            body.appendChild(title);
                            const meta = utils.createEl('div', 'task-meta');
                            const project = getProjectById(task.projectId);
                            if (project) meta.appendChild(utils.createEl('span', 'task-chip', { text: project.name }));
                            const dueInfo = getDueInfo(task);
                            if (dueInfo) {
                                const chip = utils.createEl('span', 'task-chip', { text: dueInfo.label });
                                if (dueInfo.className) chip.classList.add(dueInfo.className);
                                meta.appendChild(chip);
                            }
                            if (task.priority === 'high' || task.priority === 'urgent') {
                                const chip = utils.createEl('span', 'task-chip', { text: task.priority === 'high' ? 'High priority' : 'Urgent' });
                                chip.classList.add(task.priority === 'high' ? 'priority-high' : 'priority-urgent');
                                meta.appendChild(chip);
                            }
                            if (task.focus && !task.completedAt) meta.appendChild(utils.createEl('span', 'task-chip', { text: 'Focus' }));
                            body.appendChild(meta);
                            card.appendChild(body);
                            const actions = utils.createEl('div', 'task-actions');
                            const focusToggle = document.createElement('button');
                            focusToggle.title = task.focus ? 'Remove from focus queue' : 'Add to focus queue';
                            focusToggle.textContent = task.focus ? '★' : '☆';
                            actions.appendChild(focusToggle);
                            card.appendChild(actions);
                            checkbox.addEventListener('click', event => {
                                event.stopPropagation();
                                softSync.flush?.();
                                setTaskCompleted(task.id, checkbox.checked);
                            });
                            focusToggle.addEventListener('click', event => {
                                event.stopPropagation();
                                softSync.flush?.();
                                task.focus = !task.focus;
                                if (task.focus) task.completedAt = null;
                                task.updatedAt = utils.nowISO();
                                state.focusSkipped.delete(task.id);
                                persist();
                                syncUI();
                            });
                            card.addEventListener('click', () => {
                                if (state.selectedTaskId !== task.id) {
                                    state.selectedTaskId = task.id;
                                    renderTaskList();
                                    renderDetail();
                                }
                            });
                            taskList.appendChild(card);
                        });
                    }

                    function getSelectedTask() {
                        return state.data.tasks.find(task => task.id === state.selectedTaskId) || null;
                    }

                    function formatDateInput(iso) {
                        if (!iso) return '';
                        const date = new Date(iso);
                        if (Number.isNaN(date.getTime())) return '';
                        const pad = (value) => String(value).padStart(2, '0');
                        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
                    }

                    function buildMetaLine(task) {
                        const parts = [];
                        if (task.createdAt) parts.push(`Created ${utils.relativeTime(task.createdAt)}`);
                        if (task.updatedAt) parts.push(`Updated ${utils.relativeTime(task.updatedAt)}`);
                        if (task.completedAt) parts.push(`Completed ${utils.relativeTime(task.completedAt)}`);
                        return parts.filter(Boolean).join(' · ');
                    }

                    function renderDetail() {
                        const task = getSelectedTask();
                        if (!task) {
                            detailEmpty.style.display = 'block';
                            detailForm.style.display = 'none';
                            [titleInput, projectSelect, prioritySelect, dueInput, focusInput, notesInput, completeButton, deleteButton].forEach(control => control.disabled = true);
                            metaBlock.textContent = '';
                            return;
                        }
                        detailEmpty.style.display = 'none';
                        detailForm.style.display = 'flex';
                        [titleInput, projectSelect, prioritySelect, dueInput, focusInput, notesInput, completeButton, deleteButton].forEach(control => control.disabled = false);
                        if (document.activeElement !== titleInput) titleInput.value = task.title;
                        if (projectSelect.value !== task.projectId) projectSelect.value = task.projectId;
                        prioritySelect.value = task.priority;
                        dueInput.value = formatDateInput(task.dueAt);
                        focusInput.checked = Boolean(task.focus);
                        if (document.activeElement !== notesInput) notesInput.value = task.notes || '';
                        metaBlock.textContent = buildMetaLine(task);
                        completeButton.textContent = task.completedAt ? 'Reopen Task' : 'Mark Complete';
                        completeButton.dataset.complete = task.completedAt ? 'true' : 'false';
                    }

                    function getNextFocusTask() {
                        const pool = state.data.tasks.filter(task => task.focus && !task.completedAt && !state.focusSkipped.has(task.id));
                        if (!pool.length) return null;
                        return sortTasks(pool).shift() || null;
                    }

                    function renderFocusPanel() {
                        focusPanel.innerHTML = '';
                        focusPanel.classList.toggle('active', state.focusSessionActive);
                        if (!state.focusSessionActive) return;
                        const next = getNextFocusTask();
                        if (!next) {
                            const empty = utils.createEl('div', 'task-focus-card');
                            empty.innerHTML = '<h2>Focus queue is clear</h2><p>Flag tasks with ★ to prepare your next focus sprint.</p>';
                            focusPanel.appendChild(empty);
                            return;
                        }
                        state.selectedTaskId = next.id;
                        const card = utils.createEl('div', 'task-focus-card');
                        const title = document.createElement('h2');
                        title.textContent = next.title;
                        card.appendChild(title);
                        const meta = utils.createEl('div', 'task-meta');
                        const project = getProjectById(next.projectId);
                        if (project) meta.appendChild(utils.createEl('span', 'task-chip', { text: project.name }));
                        const dueInfo = getDueInfo(next);
                        if (dueInfo) {
                            const chip = utils.createEl('span', 'task-chip', { text: dueInfo.label });
                            if (dueInfo.className) chip.classList.add(dueInfo.className);
                            meta.appendChild(chip);
                        }
                        if (next.priority === 'high' || next.priority === 'urgent') {
                            const chip = utils.createEl('span', 'task-chip', { text: next.priority === 'high' ? 'High priority' : 'Urgent' });
                            chip.classList.add(next.priority === 'high' ? 'priority-high' : 'priority-urgent');
                            meta.appendChild(chip);
                        }
                        card.appendChild(meta);
                        const notes = document.createElement('p');
                        notes.textContent = next.notes ? next.notes : 'No notes for this task yet.';
                        notes.style.opacity = next.notes ? '1' : '0.6';
                        card.appendChild(notes);
                        const actions = utils.createEl('div', 'task-focus-actions');
                        const completeBtn = document.createElement('button');
                        completeBtn.textContent = 'Complete';
                        const skipBtn = document.createElement('button');
                        skipBtn.classList.add('secondary');
                        skipBtn.textContent = 'Skip';
                        actions.append(completeBtn, skipBtn);
                        card.appendChild(actions);
                        focusPanel.appendChild(card);
                        completeBtn.addEventListener('click', () => {
                            softSync.flush?.();
                            setTaskCompleted(next.id, true);
                        });
                        skipBtn.addEventListener('click', () => {
                            state.focusSkipped.add(next.id);
                            renderFocusPanel();
                        });
                    }

                    function updateFocusButton() {
                        focusButton.textContent = state.focusSessionActive ? 'End Focus' : 'Start Focus';
                        focusButton.classList.toggle('active', state.focusSessionActive);
                    }

                    function syncUI() {
                        renderFilters();
                        renderProjects();
                        renderTaskList();
                        renderFocusPanel();
                        renderDetail();
                        updateFocusButton();
                    }

                    function persist() {
                        const payload = JSON.stringify(state.data, null, 2);
                        localStorage.setItem(STORAGE_KEYS.TASKS, payload);
                        try {
                            if (!fileSystem.exists('/System')) fileSystem.createDirectory('/System');
                        } catch (error) {}
                        try {
                            if (fileSystem.exists(TASKS_FILE)) {
                                fileSystem.writeFile(TASKS_FILE, payload, { encoding: 'utf-8', mime: 'application/json' });
                            } else {
                                fileSystem.createFile(TASKS_FILE, payload, { encoding: 'utf-8', mime: 'application/json' });
                            }
                        } catch (error) {
                            console.warn('Failed to persist tasks file', error);
                        }
                    }

                    function setFilter(type, value) {
                        state.filter = { type, value };
                        if (type !== 'smart' || value !== 'focus') {
                            state.focusSessionActive = false;
                            state.focusSkipped.clear();
                        }
                        syncUI();
                    }

                    function populateProjectSelect() {
                        projectSelect.innerHTML = '';
                        state.data.projects.forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.id;
                            option.textContent = project.name;
                            projectSelect.appendChild(option);
                        });
                    }

                    function createProject(name, color) {
                        const trimmed = name.trim();
                        if (!trimmed) return;
                        const base = trimmed.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
                        let id = base || `project-${Math.random().toString(16).slice(2, 6)}`;
                        while (state.data.projects.some(project => project.id === id)) {
                            id = `${base || 'project'}-${Math.random().toString(16).slice(2, 6)}`;
                        }
                        state.data.projects.push({ id, name: trimmed, color, builtIn: false });
                        softSync.cancel?.();
                        persist();
                        populateProjectSelect();
                        notifications.notify('Project added', trimmed);
                        setFilter('project', id);
                    }

                    function deleteProject(projectId) {
                        const project = state.data.projects.find(entry => entry.id === projectId);
                        if (!project || project.builtIn) return;
                        state.data.tasks.forEach(task => {
                            if (task.projectId === projectId) {
                                task.projectId = 'inbox';
                                task.updatedAt = utils.nowISO();
                            }
                        });
                        state.data.projects = state.data.projects.filter(entry => entry.id !== projectId);
                        softSync.cancel?.();
                        persist();
                        populateProjectSelect();
                        notifications.notify('Project removed', `${project.name} archived`);
                        if (state.filter.type === 'project' && state.filter.value === projectId) {
                            setFilter('smart', 'all');
                        } else {
                            syncUI();
                        }
                    }

                    function createTask({ title, projectId }) {
                        const trimmed = title.trim();
                        if (!trimmed) return;
                        softSync.flush?.();
                        const projectExists = state.data.projects.some(project => project.id === projectId);
                        const now = utils.nowISO();
                        const task = {
                            id: utils.uuid(),
                            title: trimmed,
                            notes: '',
                            projectId: projectExists ? projectId : 'inbox',
                            dueAt: null,
                            priority: 'normal',
                            focus: false,
                            createdAt: now,
                            updatedAt: now,
                            completedAt: null
                        };
                        state.data.tasks.unshift(task);
                        state.selectedTaskId = task.id;
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task captured', trimmed);
                        syncUI();
                    }

                    function setTaskCompleted(taskId, completed) {
                        const task = state.data.tasks.find(entry => entry.id === taskId);
                        if (!task) return;
                        if (completed) {
                            task.completedAt = utils.nowISO();
                            task.focus = false;
                        } else {
                            task.completedAt = null;
                        }
                        task.updatedAt = utils.nowISO();
                        state.focusSkipped.delete(taskId);
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task updated', completed ? `${task.title} completed` : `${task.title} reopened`);
                        syncUI();
                    }

                    function deleteTask(taskId) {
                        const index = state.data.tasks.findIndex(entry => entry.id === taskId);
                        if (index === -1) return;
                        softSync.flush?.();
                        const [removed] = state.data.tasks.splice(index, 1);
                        state.focusSkipped.delete(taskId);
                        if (state.selectedTaskId === taskId) {
                            const replacement = state.data.tasks.find(task => !task.completedAt) || state.data.tasks[0];
                            state.selectedTaskId = replacement ? replacement.id : null;
                        }
                        softSync.cancel?.();
                        persist();
                        notifications.notify('Task deleted', removed.title);
                        syncUI();
                    }

                    const softSync = utils.debounce(() => {
                        persist();
                        syncUI();
                    }, 260);

                    captureButton.addEventListener('click', () => quickAddInput.focus());
                    projectForm.addEventListener('submit', event => {
                        event.preventDefault();
                        createProject(projectNameInput.value, projectColorInput.value || '#7b8bff');
                        projectNameInput.value = '';
                    });
                    quickAddInput.addEventListener('keydown', event => {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            const targetProject = state.filter.type === 'project' ? state.filter.value : 'inbox';
                            createTask({ title: quickAddInput.value, projectId: targetProject });
                            quickAddInput.value = '';
                        }
                    });
                    searchInput.addEventListener('input', () => {
                        state.search = searchInput.value;
                        renderTaskList();
                        if (!state.focusSessionActive) renderDetail();
                    });
                    focusButton.addEventListener('click', () => {
                        softSync.flush?.();
                        state.focusSessionActive = !state.focusSessionActive;
                        if (state.focusSessionActive) {
                            state.focusSkipped.clear();
                            if (!getNextFocusTask()) notifications.notify('Focus', 'No tasks flagged for focus yet.');
                        } else {
                            state.focusSkipped.clear();
                        }
                        syncUI();
                    });

                    titleInput.addEventListener('input', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.title = titleInput.value;
                        task.updatedAt = utils.nowISO();
                        softSync();
                    });
                    titleInput.addEventListener('blur', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        const trimmed = titleInput.value.trim();
                        if (!trimmed) {
                            task.title = 'Untitled Task';
                            titleInput.value = task.title;
                        } else if (task.title !== trimmed) {
                            task.title = trimmed;
                            titleInput.value = trimmed;
                        }
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    notesInput.addEventListener('input', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.notes = notesInput.value;
                        task.updatedAt = utils.nowISO();
                        softSync();
                    });
                    prioritySelect.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.priority = prioritySelect.value;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    projectSelect.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.projectId = projectSelect.value;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    dueInput.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.dueAt = dueInput.value ? new Date(dueInput.value).toISOString() : null;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    focusInput.addEventListener('change', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        task.focus = focusInput.checked;
                        if (task.focus) task.completedAt = null;
                        task.updatedAt = utils.nowISO();
                        softSync.flush?.();
                    });
                    completeButton.addEventListener('click', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        setTaskCompleted(task.id, !task.completedAt);
                    });
                    deleteButton.addEventListener('click', () => {
                        const task = getSelectedTask();
                        if (!task) return;
                        if (confirm(`Delete "${task.title}"? This cannot be undone.`)) {
                            deleteTask(task.id);
                        }
                    });

                    populateProjectSelect();
                    if (context?.projectId && state.data.projects.some(project => project.id === context.projectId)) {
                        state.filter = { type: 'project', value: context.projectId };
                    } else if (context?.showCompleted) {
                        state.filter = { type: 'smart', value: 'completed' };
                    }
                    if (context?.focus) state.focusSessionActive = true;

                    syncUI();

                    return {
                        element: shell,
                        title: 'Task Command',
                        width: '960px',
                        height: '640px',
                        onClose: () => {
                            softSync.flush?.();
                            persist();
                        }
                    };
                }
            };
        }
        function createTextEditorApp() {
            return {
                id: 'text-editor',
                name: 'Text Studio',
                icon: '📝',
                launch({ context, fileSystem, notifications, appManager }) {
                    const state = {
                        path: context.path || null,
                        dirty: false,
                        encoding: 'utf-8'
                    };

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="new">🆕 New</button>
                        <button data-action="open">📂 Open</button>
                        <button data-action="save">💾 Save</button>
                        <button data-action="save-as">📝 Save As</button>
                        <button data-action="find">🔍 Find</button>
                        <button data-action="print">🖨️ Print</button>
                        <select data-role="encoding">
                            <option value="utf-8">UTF-8</option>
                        </select>
                        <span style="margin-left:auto">${state.path || 'New document'}</span>
                    `;
                    const encodingSelect = toolbar.querySelector('select');
                    const statusLabel = toolbar.querySelector('span:last-child');
                    const editor = utils.createEl('textarea', 'editor-area');
                    const status = utils.createEl('div', 'editor-status');
                    status.innerHTML = '<span>Ln 1, Col 1</span><span>UTF-8</span>';
                    shell.append(toolbar, editor, status);

                    const updateCursor = () => {
                        const pos = editor.selectionStart;
                        const text = editor.value.slice(0, pos);
                        const lines = text.split('\n');
                        const line = lines.length;
                        const column = lines[lines.length - 1].length + 1;
                        status.firstChild.textContent = `Ln ${line}, Col ${column}`;
                    };

                    editor.addEventListener('input', () => {
                        state.dirty = true;
                        updateCursor();
                    });
                    editor.addEventListener('click', updateCursor);
                    editor.addEventListener('keyup', updateCursor);

                    function loadFile(path) {
                        try {
                            const content = fileSystem.readFile(path, { encoding: state.encoding });
                            editor.value = content;
                            state.path = path;
                            state.dirty = false;
                            statusLabel.textContent = path;
                            notifications.notify('File opened', path);
                            updateCursor();
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    if (state.path) loadFile(state.path);

                    function saveFile() {
                        if (!state.path) return saveAs();
                        try {
                            fileSystem.writeFile(state.path, editor.value, { encoding: state.encoding });
                            state.dirty = false;
                            notifications.notify('Saved', state.path);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    function saveAs() {
                        const name = prompt('Save as', state.path ? state.path.split('/').pop() : 'New file.txt');
                        if (!name) return;
                        const target = `/Documents/${name}`;
                        try {
                            if (fileSystem.exists(target)) {
                                if (!confirm('Overwrite existing file?')) return;
                                fileSystem.writeFile(target, editor.value, { encoding: state.encoding });
                            } else {
                                fileSystem.createFile(target, editor.value, { encoding: state.encoding, mime: utils.mimeFromName(name) });
                            }
                            state.path = target;
                            state.dirty = false;
                            statusLabel.textContent = target;
                            notifications.notify('Saved', target);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    function openFileDialog() {
                        appManager.open('toastsearcher', {
                            path: '/Documents',
                            selectMode: selectedPath => {
                                loadFile(selectedPath);
                            }
                        });
                    }

                    function findDialog() {
                        const query = prompt('Find text');
                        if (!query) return;
                        const start = editor.selectionEnd;
                        const index = editor.value.indexOf(query, start);
                        if (index !== -1) {
                            editor.focus();
                            editor.setSelectionRange(index, index + query.length);
                        } else {
                            notifications.notify('Find', 'No more matches found.');
                        }
                    }

                    toolbar.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'new':
                                if (state.dirty && !confirm('Discard unsaved changes?')) return;
                                editor.value = '';
                                state.path = null;
                                state.dirty = false;
                                statusLabel.textContent = 'New document';
                                break;
                            case 'open':
                                openFileDialog();
                                break;
                            case 'save':
                                saveFile();
                                break;
                            case 'save-as':
                                saveAs();
                                break;
                            case 'find':
                                findDialog();
                                break;
                            case 'print':
                                window.print();
                                break;
                        }
                    });

                    encodingSelect.addEventListener('change', () => {
                        state.encoding = encodingSelect.value;
                        status.lastChild.textContent = state.encoding.toUpperCase();
                        if (state.path) loadFile(state.path);
                    });

                    return {
                        element: shell,
                        title: state.path ? `Text Studio — ${state.path.split('/').pop()}` : 'Text Studio',
                        width: '840px',
                        height: '580px',
                        onClose: () => {
                            if (state.dirty && !confirm('Close without saving?')) return false;
                        }
                    };
                }
            };
        }
        function createCalculatorApp() {
            const keys = [
                'MC','MR','M+','M-','C',
                '7','8','9','/','sin',
                '4','5','6','*','cos',
                '1','2','3','-','tan',
                '0','.','=','+','√',
                '(',')','log','^','π'
            ];
            return {
                id: 'calculator',
                name: 'ScientiCalc',
                icon: '🧮',
                launch({ notifications }) {
                    let memory = 0;
                    let expression = '0';
                    const history = [];

                    const container = utils.createEl('div', 'calculator');
                    const display = utils.createEl('div', 'calc-display', { text: expression });
                    const grid = utils.createEl('div', 'calc-grid');
                    const historyPanel = utils.createEl('div', 'preview-card');
                    historyPanel.style.maxHeight = '140px';
                    historyPanel.style.overflow = 'auto';
                    historyPanel.innerHTML = '<strong>History</strong><div class="preview-body"></div>';
                    const historyBody = historyPanel.querySelector('.preview-body');

                    const updateDisplay = value => { expression = value; display.textContent = value || '0'; };

                    const commitHistory = (expr, result) => {
                        history.unshift({ expr, result });
                        historyBody.innerHTML = history.slice(0, 12).map(item => `<div><strong>${item.expr}</strong><br>${item.result}</div>`).join('');
                    };

                    const evaluate = () => {
                        try {
                            const expr = expression
                                .replace(/π/g, Math.PI.toString())
                                .replace(/√/g, 'Math.sqrt')
                                .replace(/sin/g, 'Math.sin')
                                .replace(/cos/g, 'Math.cos')
                                .replace(/tan/g, 'Math.tan')
                                .replace(/log/g, 'Math.log10')
                                .replace(/\^/g, '**');
                            const result = Function(`"use strict"; return (${expr});`)();
                            commitHistory(expression, result);
                            updateDisplay(String(result));
                        } catch (error) {
                            notifications.notify('Calculator', 'Invalid expression');
                            updateDisplay('0');
                        }
                    };

                    keys.forEach(key => {
                        const button = utils.createEl('button', '', { text: key });
                        button.addEventListener('click', () => {
                            switch (key) {
                                case 'C':
                                    updateDisplay('0');
                                    break;
                                case '=':
                                    evaluate();
                                    break;
                                case 'MC':
                                    memory = 0;
                                    notifications.notify('Memory', 'Cleared');
                                    break;
                                case 'MR':
                                    updateDisplay(memory.toString());
                                    break;
                                case 'M+':
                                    memory += Number(expression || 0);
                                    notifications.notify('Memory', `Stored ${memory}`);
                                    break;
                                case 'M-':
                                    memory -= Number(expression || 0);
                                    notifications.notify('Memory', `Stored ${memory}`);
                                    break;
                                default:
                                    if (expression === '0' && !isNaN(Number(key))) updateDisplay(key);
                                    else updateDisplay(expression + key);
                                    break;
                            }
                        });
                        grid.appendChild(button);
                    });

                    container.append(display, grid, historyPanel);
                    return {
                        element: container,
                        width: '420px',
                        height: '520px'
                    };
                }
            };
        }
        function createTerminalApp(desktopManager) {
            return {
                id: 'terminal',
                name: 'Terminal',
                icon: '💻',
                launch({ context, fileSystem, notifications, settings, appManager }) {
                    const terminal = utils.createEl('div', 'terminal');
                    const output = utils.createEl('div', 'terminal-output');
                    const inputBar = utils.createEl('div', 'terminal-input');
                    const promptLabel = utils.createEl('span', '', { text: 'webos> ', style: 'color:#6ff76f;font-weight:600;' });
                    const input = utils.createEl('input', '', { type: 'text', autocomplete: 'off' });
                    inputBar.append(promptLabel, input);
                    terminal.append(output, inputBar);

                    const history = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMINAL_HISTORY) || '[]');
                    let historyIndex = history.length;
                    const env = {
                        PWD: context.path || '/Documents',
                        USER: 'user',
                        HOME: '/Documents'
                    };

                    function writeLine(line = '') {
                        const div = utils.createEl('div');
                        div.innerHTML = line;
                        output.appendChild(div);
                        output.scrollTop = output.scrollHeight;
                    }

                    writeLine('WebOS Terminal — type \"help\" for available commands.');

                    const commands = {
                        help() {
                            return 'Commands: help, clear, pwd, ls, cd, mkdir, rm, cat, touch, write, date, about, theme, open, exportfs, importfs';
                        },
                        clear() {
                            output.innerHTML = '';
                            return '';
                        },
                        pwd() {
                            return env.PWD;
                        },
                        ls(args) {
                            const target = args[0] ? utils.join(env.PWD, args[0]) : env.PWD;
                            try {
                                const entries = fileSystem.listDirectory(target);
                                return entries.map(entry => entry.type === 'directory' ? `<span style="color:#6fa7ff">${entry.name}/</span>` : entry.name).join('  ');
                            } catch (error) {
                                return error.message;
                            }
                        },
                        cd(args) {
                            const target = args[0] ? utils.join(env.PWD, args[0]) : env.HOME;
                            try {
                                fileSystem.ensureDirectory(target);
                                env.PWD = target;
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        mkdir(args) {
                            if (!args[0]) return 'Usage: mkdir <name>';
                            try {
                                fileSystem.createDirectory(utils.join(env.PWD, args[0]));
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        rm(args) {
                            if (!args[0]) return 'Usage: rm <path>';
                            try {
                                fileSystem.delete(utils.join(env.PWD, args[0]));
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        cat(args) {
                            if (!args[0]) return 'Usage: cat <file>';
                            try {
                                return `<pre>${fileSystem.readFile(utils.join(env.PWD, args[0]))}</pre>`;
                            } catch (error) {
                                return error.message;
                            }
                        },
                        touch(args) {
                            if (!args[0]) return 'Usage: touch <file>';
                            const target = utils.join(env.PWD, args[0]);
                            try {
                                if (fileSystem.exists(target)) fileSystem.writeFile(target, fileSystem.readFile(target));
                                else fileSystem.createFile(target, '');
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        write(args) {
                            if (!args[0]) return 'Usage: write <file>';
                            const target = utils.join(env.PWD, args[0]);
                            const content = args.slice(1).join(' ');
                            try {
                                if (fileSystem.exists(target)) fileSystem.writeFile(target, content);
                                else fileSystem.createFile(target, content);
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        date() {
                            return new Date().toString();
                        },
                        about() {
                            return 'WebOS Terminal v1.0 — simulated environment.';
                        },
                        theme(args) {
                            const mode = args[0];
                            if (!['dark', 'light', 'auto'].includes(mode)) return 'Usage: theme <dark|light|auto>';
                            settings.update({ theme: mode });
                            return `Theme set to ${mode}`;
                        },
                        open(args) {
                            if (!args[0]) return 'Usage: open <file>';
                            const target = utils.join(env.PWD, args[0]);
                            try {
                                const meta = fileSystem.readFileMeta(target);
                                appManager.openByFile(target, meta.mime);
                                return '';
                            } catch (error) {
                                return error.message;
                            }
                        },
                        exportfs() {
                            const data = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM);
                            const blob = new Blob([data], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const anchor = document.createElement('a');
                            anchor.href = url;
                            anchor.download = 'webos-filesystem.json';
                            anchor.click();
                            URL.revokeObjectURL(url);
                            return 'File system exported.';
                        },
                        importfs() {
                            const picker = document.createElement('input');
                            picker.type = 'file';
                            picker.accept = 'application/json';
                            picker.onchange = async () => {
                                const file = picker.files[0];
                                const text = await file.text();
                                localStorage.setItem(STORAGE_KEYS.FILE_SYSTEM, text);
                                fileSystem.load();
                                notifications.notify('File system', 'Imported from backup');
                            };
                            picker.click();
                            return 'Import started (choose file).';
                        }
                    };

                    function runCommand(line) {
                        if (!line.trim()) return;
                        writeLine(`<span style="color:#7bdcff">${env.USER}@webos</span>:<span style="color:#c5b7ff">${env.PWD}</span>$ ${line}`);
                        const parts = line.split('|').map(part => part.trim());
                        let previous = '';
                        for (const part of parts) {
                            const tokens = part.split(' ').filter(Boolean);
                            const command = tokens.shift();
                            if (!command) continue;
                            const handler = commands[command];
                            if (!handler) {
                                previous = `Command not found: ${command}`;
                                break;
                            }
                            previous = handler(tokens, previous) ?? '';
                            if (previous) writeLine(previous);
                        }
                    }

                    input.addEventListener('keydown', event => {
                        if (event.key === 'Enter') {
                            const line = input.value;
                            runCommand(line);
                            history.push(line);
                            localStorage.setItem(STORAGE_KEYS.TERMINAL_HISTORY, JSON.stringify(history.slice(-200)));
                            historyIndex = history.length;
                            input.value = '';
                        } else if (event.key === 'ArrowUp') {
                            if (historyIndex > 0) historyIndex--;
                            input.value = history[historyIndex] || '';
                            setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            event.preventDefault();
                        } else if (event.key === 'ArrowDown') {
                            if (historyIndex < history.length - 1) historyIndex++;
                            else historyIndex = history.length;
                            input.value = history[historyIndex] || '';
                            event.preventDefault();
                        } else if (event.key === 'Tab') {
                            event.preventDefault();
                            const partial = input.value;
                            const entries = fileSystem.listDirectory(env.PWD).map(entry => entry.name);
                            const matches = entries.filter(name => name.startsWith(partial));
                            if (matches.length === 1) input.value = matches[0];
                        }
                    });

                    setTimeout(() => input.focus(), 120);

                    return {
                        element: terminal,
                        width: '760px',
                        height: '540px'
                    };
                }
            };
        }
        function createBrowserApp() {
            return {
                id: 'browser',
                name: 'Web Navigator',
                icon: '🌐',
                launch({ context = {}, fileSystem, notifications, settings }) {
                    const state = {
                        history: [],
                        index: -1,
                        bookmarks: [],
                        downloads: [],
                        currentUrl: '',
                        useProxy: settings.state.useBrowserProxy !== false
                    };

                    const bookmarksFile = '/System/bookmarks.json';

                    const loadBookmarks = () => {
                        try {
                            state.bookmarks = JSON.parse(fileSystem.readFile(bookmarksFile));
                        } catch (error) {
                            state.bookmarks = [];
                        }
                    };

                    const saveBookmarks = () => {
                        try {
                            fileSystem.writeFile(bookmarksFile, JSON.stringify(state.bookmarks, null, 2));
                        } catch (error) {
                            notifications.notify('Bookmarks', `Unable to save bookmarks: ${error.message}`);
                        }
                    };

                    loadBookmarks();

                    const shell = utils.createEl('div', 'app-shell');
                    const toolbar = utils.createEl('div', 'app-toolbar');
                    toolbar.innerHTML = `
                        <button data-action="back" title="Back">⬅️</button>
                        <button data-action="forward" title="Forward">➡️</button>
                        <button data-action="reload" title="Reload">🔄</button>
                        <button data-action="home" title="Home">🏠</button>
                        <label for="browser-url-input" class="visually-hidden">Address bar</label>
                        <input id="browser-url-input" name="browser-url" type="url" placeholder="Enter address" style="flex:1" />
                        <button data-action="go">Go</button>
                        <button data-action="bookmark" title="Add bookmark">⭐</button>
                        <button data-action="download" title="Save to downloads">⬇️</button>
                        <button data-action="toggle-proxy" title="Toggle proxy"></button>
                        <button data-action="external" title="Open in new tab">↗️</button>
                    `;
                    const urlInput = toolbar.querySelector('#browser-url-input');
                    const proxyButton = toolbar.querySelector('[data-action="toggle-proxy"]');
                    const layout = utils.createEl('div', 'browser-layout');
                    const viewport = utils.createEl('div', 'browser-viewport');
                    const iframe = utils.createEl('iframe');
                    iframe.setAttribute('allow', 'fullscreen; geolocation *; microphone *; camera *');
                    iframe.referrerPolicy = 'no-referrer';
                    viewport.appendChild(iframe);

                    const sidebar = utils.createEl('aside', 'browser-sidebar');
                    sidebar.innerHTML = `
                        <div class="browser-panel">
                            <h3>Bookmarks</h3>
                            <ul class="browser-list" id="browser-bookmarks"></ul>
                        </div>
                        <div class="browser-panel">
                            <h3>History</h3>
                            <ul class="browser-list" id="browser-history"></ul>
                        </div>
                        <div class="browser-panel">
                            <h3>Downloads</h3>
                            <ul class="browser-list" id="browser-downloads"></ul>
                        </div>
                        <div class="browser-status" id="browser-status"></div>
                    `;

                    layout.append(viewport, sidebar);
                    shell.append(toolbar, layout);

                    const bookmarksList = sidebar.querySelector('#browser-bookmarks');
                    const historyList = sidebar.querySelector('#browser-history');
                    const downloadsList = sidebar.querySelector('#browser-downloads');
                    const statusLabel = sidebar.querySelector('#browser-status');

                    const ensureProtocol = (url) => {
                        if (!url) return '';
                        return /^https?:\/\//i.test(url) ? url : `https://${url}`;
                    };

                    const proxiedUrl = (url) => state.useProxy ? `https://r.jina.ai/${url}` : url;

                    const updateProxyButton = () => {
                        proxyButton.textContent = state.useProxy ? '🔒 Proxy' : '🌐 Direct';
                        statusLabel.textContent = state.useProxy ? 'Proxy mode: Improved compatibility for embedded sites.' : 'Direct mode: Sites that block embeds may not load.';
                    };

                    const updateToolbarState = () => {
                        toolbar.querySelector('[data-action="back"]').disabled = state.index <= 0;
                        toolbar.querySelector('[data-action="forward"]').disabled = state.index >= state.history.length - 1;
                        toolbar.querySelector('[data-action="reload"]').disabled = !state.history.length;
                        toolbar.querySelector('[data-action="external"]').disabled = !state.currentUrl;
                        toolbar.querySelector('[data-action="download"]').disabled = !state.currentUrl;
                    };

                    const renderBookmarks = () => {
                        bookmarksList.innerHTML = '';
                        if (!state.bookmarks.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No bookmarks yet</span>';
                            li.style.opacity = '0.7';
                            bookmarksList.appendChild(li);
                            return;
                        }
                        state.bookmarks.forEach((bookmark, index) => {
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = bookmark.title;
                            li.appendChild(span);
                            const openBtn = document.createElement('button');
                            openBtn.dataset.role = 'open-bookmark';
                            openBtn.dataset.index = index;
                            openBtn.textContent = 'Open';
                            const removeBtn = document.createElement('button');
                            removeBtn.dataset.role = 'remove-bookmark';
                            removeBtn.dataset.index = index;
                            removeBtn.textContent = '✕';
                            li.append(openBtn, removeBtn);
                            bookmarksList.appendChild(li);
                        });
                    };

                    const renderHistory = () => {
                        historyList.innerHTML = '';
                        if (!state.history.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No history yet</span>';
                            li.style.opacity = '0.7';
                            historyList.appendChild(li);
                            return;
                        }
                        state.history.slice().reverse().slice(0, 30).forEach((entry, offset) => {
                            const actualIndex = state.history.length - 1 - offset;
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = entry.title || entry.url;
                            li.appendChild(span);
                            const button = document.createElement('button');
                            button.dataset.role = 'open-history';
                            button.dataset.index = actualIndex;
                            button.textContent = 'Open';
                            li.appendChild(button);
                            historyList.appendChild(li);
                        });
                    };

                    const renderDownloads = () => {
                        downloadsList.innerHTML = '';
                        if (!state.downloads.length) {
                            const li = document.createElement('li');
                            li.innerHTML = '<span>No downloads yet</span>';
                            li.style.opacity = '0.7';
                            downloadsList.appendChild(li);
                            return;
                        }
                        state.downloads.forEach((item, index) => {
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = `${item.name} · ${new Date(item.time).toLocaleTimeString()}`;
                            li.appendChild(span);
                            const button = document.createElement('button');
                            button.dataset.role = 'open-download';
                            button.dataset.index = index;
                            button.textContent = 'Open';
                            li.appendChild(button);
                            downloadsList.appendChild(li);
                        });
                    };

                    const recordHistory = (url, title) => {
                        state.history = state.history.slice(0, state.index + 1);
                        state.history.push({ url, title, timestamp: Date.now() });
                        state.index = state.history.length - 1;
                        renderHistory();
                    };

                    const navigate = (inputUrl, { push = true } = {}) => {
                        const normalized = ensureProtocol(inputUrl.trim());
                        if (!normalized) return;
                        state.currentUrl = normalized;
                        urlInput.value = normalized;
                        iframe.src = proxiedUrl(normalized);
                        if (push) recordHistory(normalized, normalized);
                        updateToolbarState();
                    };

                    toolbar.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const action = button.dataset.action;
                        switch (action) {
                            case 'back':
                                if (state.index > 0) {
                                    state.index--;
                                    const entry = state.history[state.index];
                                    iframe.src = proxiedUrl(entry.url);
                                    state.currentUrl = entry.url;
                                    urlInput.value = entry.url;
                                }
                                break;
                            case 'forward':
                                if (state.index < state.history.length - 1) {
                                    state.index++;
                                    const entry = state.history[state.index];
                                    iframe.src = proxiedUrl(entry.url);
                                    state.currentUrl = entry.url;
                                    urlInput.value = entry.url;
                                }
                                break;
                            case 'reload':
                                if (state.currentUrl) iframe.src = proxiedUrl(state.currentUrl);
                                break;
                            case 'home':
                                navigate('https://www.example.com');
                                break;
                            case 'go':
                                navigate(urlInput.value);
                                break;
                            case 'bookmark':
                                if (!state.currentUrl) break;
                                const title = prompt('Bookmark title', state.currentUrl) || state.currentUrl;
                                state.bookmarks.push({ title, url: state.currentUrl });
                                saveBookmarks();
                                renderBookmarks();
                                notifications.notify('Bookmark added', title);
                                break;
                            case 'download':
                                if (!state.currentUrl) break;
                                let name;
                                try {
                                    name = new URL(state.currentUrl).hostname || state.currentUrl;
                                } catch {
                                    name = state.currentUrl;
                                }
                                state.downloads.unshift({ name, url: state.currentUrl, time: Date.now() });
                                renderDownloads();
                                notifications.notify('Download saved', name);
                                break;
                            case 'toggle-proxy':
                                settings.update({ useBrowserProxy: !state.useProxy });
                                break;
                            case 'external':
                                if (state.currentUrl) window.open(state.currentUrl, '_blank', 'noopener');
                                break;
                        }
                        updateToolbarState();
                    });

                    urlInput.addEventListener('keydown', event => {
                        if (event.key === 'Enter') navigate(urlInput.value);
                    });

                    bookmarksList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        const index = Number(button.dataset.index);
                        if (button.dataset.role === 'open-bookmark') {
                            const bookmark = state.bookmarks[index];
                            if (bookmark) navigate(bookmark.url);
                        } else if (button.dataset.role === 'remove-bookmark') {
                            const [removed] = state.bookmarks.splice(index, 1);
                            saveBookmarks();
                            renderBookmarks();
                            notifications.notify('Bookmark removed', removed?.title || 'Bookmark');
                        }
                    });

                    historyList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button || button.dataset.role !== 'open-history') return;
                        const entry = state.history[Number(button.dataset.index)];
                        if (entry) navigate(entry.url);
                    });

                    downloadsList.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button || button.dataset.role !== 'open-download') return;
                        const item = state.downloads[Number(button.dataset.index)];
                        if (item) window.open(item.url, '_blank', 'noopener');
                    });

                    const unsubscribe = settings.on('change', newState => {
                        if (newState.useBrowserProxy !== state.useProxy) {
                            state.useProxy = newState.useBrowserProxy !== false;
                            updateProxyButton();
                            if (state.currentUrl) iframe.src = proxiedUrl(state.currentUrl);
                        }
                    });

                    iframe.addEventListener('load', () => {
                        try {
                            const doc = iframe.contentDocument;
                            const title = doc?.title?.trim();
                            if (title && state.history[state.index]) {
                                state.history[state.index].title = title;
                                renderHistory();
                            }
                        } catch {}
                    });

                    updateProxyButton();
                    renderBookmarks();
                    renderHistory();
                    renderDownloads();
                    const initialUrl = context.url || 'https://www.example.com';
                    navigate(initialUrl, { push: true });

                    return {
                        element: shell,
                        width: '980px',
                        height: '640px',
                        onClose: () => unsubscribe()
                    };
                }
            };
        }
        function createMediaPlayerApp() {
            return {
                id: 'media-player',
                name: 'Media Player',
                icon: '🎵',
                launch({ context, fileSystem, notifications }) {
                    const state = {
                        playlist: JSON.parse(localStorage.getItem(STORAGE_KEYS.MEDIA_PLAYLIST) || '[]'),
                        currentIndex: -1
                    };

                    const container = utils.createEl('div', 'media-player');
                    const stage = utils.createEl('div', 'media-stage');
                    const screen = utils.createEl('div', 'media-screen');
                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.style.width = '100%';
                    const video = document.createElement('video');
                    video.controls = true;
                    video.style.maxWidth = '100%';
                    video.style.maxHeight = '100%';
                    screen.appendChild(audio);
                    const controls = utils.createEl('div', 'app-toolbar');
                    controls.innerHTML = '<button data-action="add">➕ Add</button><button data-action="remove">🗑️ Remove</button><button data-action="clear">Clear Playlist</button>';
                    stage.append(screen, controls);
                    const playlistPane = utils.createEl('div', 'playlist');
                    playlistPane.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center"><strong>Playlist</strong><button data-action="save">💾 Save</button></div><div id="playlist-items"></div>';
                    const playlistItems = playlistPane.querySelector('#playlist-items');
                    container.append(stage, playlistPane);

                    function renderPlaylist() {
                        playlistItems.innerHTML = '';
                        state.playlist.forEach((item, index) => {
                            const row = utils.createEl('div', 'playlist-item');
                            row.innerHTML = `<span>${item.name}</span><button data-index="${index}" data-role="delete">✕</button>`;
                            if (index === state.currentIndex) row.classList.add('active');
                            row.addEventListener('click', event => {
                                if (event.target.dataset.role === 'delete') return;
                                playIndex(index);
                            });
                            playlistItems.appendChild(row);
                        });
                        localStorage.setItem(STORAGE_KEYS.MEDIA_PLAYLIST, JSON.stringify(state.playlist));
                    }

                    function playIndex(index) {
                        const item = state.playlist[index];
                        if (!item) return;
                        state.currentIndex = index;
                        const meta = fileSystem.readFileMeta(item.path);
                        const source = `data:${meta.mime};base64,${meta.data}`;
                        if (meta.mime.startsWith('video')) {
                            screen.innerHTML = '';
                            const player = video.cloneNode();
                            player.src = source;
                            player.play();
                            screen.appendChild(player);
                        } else {
                            screen.innerHTML = '';
                            const player = audio.cloneNode();
                            player.src = source;
                            player.play();
                            screen.appendChild(player);
                        }
                        renderPlaylist();
                    }

                    controls.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'add': {
                                const path = prompt('Enter media path (e.g. /Music/song.mp3)');
                                if (!path) break;
                                try {
                                    const meta = fileSystem.readFileMeta(path);
                                    state.playlist.push({ path, name: meta.name });
                                    renderPlaylist();
                                    notifications.notify('Playlist', `${meta.name} added`);
                                } catch (error) {
                                    notifications.notify('Error', error.message);
                                }
                                break;
                            }
                            case 'remove':
                                if (state.currentIndex >= 0) {
                                    state.playlist.splice(state.currentIndex, 1);
                                    state.currentIndex = -1;
                                    screen.innerHTML = '';
                                    renderPlaylist();
                                }
                                break;
                            case 'clear':
                                state.playlist = [];
                                state.currentIndex = -1;
                                screen.innerHTML = '';
                                renderPlaylist();
                                break;
                        }
                    });

                    playlistPane.addEventListener('click', event => {
                        const button = event.target.closest('button');
                        if (!button) return;
                        if (button.dataset.role === 'delete') {
                            const index = Number(button.dataset.index);
                            state.playlist.splice(index, 1);
                            if (state.currentIndex === index) {
                                state.currentIndex = -1;
                                screen.innerHTML = '';
                            }
                            renderPlaylist();
                        } else if (button.dataset.action === 'save') {
                            localStorage.setItem(STORAGE_KEYS.MEDIA_PLAYLIST, JSON.stringify(state.playlist));
                            notifications.notify('Playlist', 'Saved');
                        }
                    });

                    if (context.path) {
                        try {
                            const meta = fileSystem.readFileMeta(context.path);
                            state.playlist.unshift({ path: context.path, name: meta.name });
                            playIndex(0);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    }

                    container.addEventListener('dragover', event => event.preventDefault());
                    container.addEventListener('drop', event => {
                        event.preventDefault();
                        const path = event.dataTransfer?.getData('text/plain');
                        if (path && fileSystem.exists(path)) {
                            const meta = fileSystem.readFileMeta(path);
                            state.playlist.push({ path, name: meta.name });
                            renderPlaylist();
                        }
                    });

                    renderPlaylist();
                    return {
                        element: container,
                        width: '900px',
                        height: '580px'
                    };
                }
            };
        }
        function createWebShortcutApp(shortcut) {
            return {
                id: shortcut.id,
                name: shortcut.name,
                icon: shortcut.icon,
                launch({ appManager, notifications }) {
                    const wrapper = utils.createEl('div', 'shortcut-app');
                    const header = utils.createEl('div', 'shortcut-header');
                    const title = document.createElement('h2');
                    title.textContent = shortcut.name;
                    const url = utils.createEl('span', 'shortcut-url', { text: shortcut.url });
                    header.append(title, url);

                    const body = utils.createEl('div', 'shortcut-body', { text: shortcut.description || '' });

                    if (shortcut.availability) {
                        const note = document.createElement('div');
                        note.style.marginTop = '8px';
                        note.style.fontSize = '0.8rem';
                        note.style.opacity = '0.8';
                        note.textContent = shortcut.availability;
                        body.appendChild(note);
                    }

                    let tagsRow = null;
                    if (shortcut.categories?.length) {
                        tagsRow = utils.createEl('div', 'shortcut-tags');
                        shortcut.categories.forEach(label => {
                            tagsRow.appendChild(utils.createEl('span', 'shortcut-tag', { text: label }));
                        });
                    }

                    const actions = utils.createEl('div', 'shortcut-actions');
                    const launchBtn = utils.createEl('button', 'primary', { type: 'button', text: 'Open in Web Navigator' });
                    launchBtn.addEventListener('click', () => {
                        appManager.open('browser', { url: shortcut.url });
                        notifications.notify(shortcut.name, 'Opening in Web Navigator…');
                    });
                    const tabBtn = utils.createEl('button', '', { type: 'button', text: 'Open in New Tab' });
                    tabBtn.addEventListener('click', () => window.open(shortcut.url, '_blank', 'noopener'));
                    const copyBtn = utils.createEl('button', '', { type: 'button', text: 'Copy Link' });
                    copyBtn.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard?.writeText(shortcut.url);
                            notifications.notify(shortcut.name, 'Link copied to clipboard.');
                        } catch (error) {
                            notifications.notify(shortcut.name, 'Unable to copy link automatically.');
                        }
                    });
                    actions.append(launchBtn, tabBtn, copyBtn);

                    wrapper.append(header, body);
                    if (tagsRow) wrapper.append(tagsRow);
                    wrapper.append(actions);

                    return {
                        element: wrapper,
                        width: '520px',
                        height: '420px'
                    };
                }
            };
        }
        function createImageViewerApp() {
            return {
                id: 'image-viewer',
                name: 'Image Viewer',
                icon: '🖼️',
                launch({ context, fileSystem, notifications }) {
                    const container = utils.createEl('div', 'image-viewer');
                    const img = new Image();
                    img.alt = 'Image';
                    container.appendChild(img);
                    const controls = utils.createEl('div', 'image-controls');
                    controls.innerHTML = '<button data-action="zoom-in">➕</button><button data-action="zoom-out">➖</button><button data-action="rotate">🔄</button><button data-action="fullscreen">⤢</button>';
                    container.appendChild(controls);

                    const state = { scale: 1, rotation: 0 };
                    const applyTransform = () => {
                        img.style.transform = `scale(${state.scale}) rotate(${state.rotation}deg)`;
                    };

                    controls.addEventListener('click', event => {
                        const action = event.target.closest('button')?.dataset.action;
                        if (!action) return;
                        switch (action) {
                            case 'zoom-in':
                                state.scale = utils.clamp(state.scale + 0.1, 0.2, 3);
                                break;
                            case 'zoom-out':
                                state.scale = utils.clamp(state.scale - 0.1, 0.2, 3);
                                break;
                            case 'rotate':
                                state.rotation = (state.rotation + 90) % 360;
                                break;
                            case 'fullscreen':
                                if (!document.fullscreenElement) container.requestFullscreen();
                                else document.exitFullscreen();
                                break;
                        }
                        applyTransform();
                    });

                    if (context.path) {
                        try {
                            const meta = fileSystem.readFileMeta(context.path);
                            img.src = `data:${meta.mime};base64,${meta.data}`;
                            notifications.notify('Image Viewer', meta.name);
                        } catch (error) {
                            notifications.notify('Error', error.message);
                        }
                    } else {
                        container.innerHTML = '<div class="preview-card"><strong>No image loaded</strong><div class="preview-body">Open an image from ToastSearcher to view it here.</div></div>';
                    }

                    return {
                        element: container,
                        width: '720px',
                        height: '540px'
                    };
                }
            };
        }
        function createTetrisApp() {
            return createCanvasGameApp({
                id: 'tetris',
                name: 'Tetris Classic',
                icon: '🧱',
                hint: 'Stack falling tetrominoes',
                instructions: [
                    'Use ← and → to slide pieces, ↓ to soft drop, ↑ to rotate.',
                    'Press Enter for a hard drop. Space or Esc pauses the game.',
                    'Clear multiple lines at once for combo bonuses.'
                ],
                legend: [
                    { color: '#42a5f5', label: 'I Piece' },
                    { color: '#5c6bc0', label: 'J Piece' },
                    { color: '#ff9800', label: 'L Piece' },
                    { color: '#fdd835', label: 'O Piece' },
                    { color: '#66bb6a', label: 'S Piece' },
                    { color: '#ab47bc', label: 'T Piece' },
                    { color: '#ef5350', label: 'Z Piece' }
                ],
                createGame(api) {
                    const COLS = 10;
                    const ROWS = 20;
                    const COLORS = {
                        I: '#42a5f5',
                        J: '#5c6bc0',
                        L: '#ff9800',
                        O: '#fdd835',
                        S: '#66bb6a',
                        T: '#ab47bc',
                        Z: '#ef5350'
                    };
                    const templates = {
                        I: ['....', '####', '....', '....'],
                        J: ['#..', '###', '...'],
                        L: ['..#', '###', '...'],
                        O: ['.##.', '.##.', '....', '....'],
                        S: ['.##', '##.', '...'],
                        T: ['.#.', '###', '...'],
                        Z: ['##.', '.##', '...']
                    };

                    const rotateMatrix = matrix => {
                        const h = matrix.length;
                        const w = matrix[0].length;
                        const result = Array.from({ length: w }, () => Array(h).fill('.'));
                        for (let y = 0; y < h; y++) {
                            for (let x = 0; x < w; x++) {
                                result[x][h - 1 - y] = matrix[y][x];
                            }
                        }
                        return result;
                    };

                    const normalizeRotation = matrix => {
                        const cells = [];
                        matrix.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value === '#') cells.push({ x, y });
                            });
                        });
                        if (!cells.length) return { cells: [], width: 0, height: 0 };
                        const minX = Math.min(...cells.map(cell => cell.x));
                        const minY = Math.min(...cells.map(cell => cell.y));
                        const normalized = cells.map(cell => ({ x: cell.x - minX, y: cell.y - minY }));
                        const width = Math.max(...normalized.map(cell => cell.x)) + 1;
                        const height = Math.max(...normalized.map(cell => cell.y)) + 1;
                        return { cells: normalized, width, height };
                    };

                    const SHAPES = {};
                    Object.entries(templates).forEach(([name, rows]) => {
                        const width = Math.max(...rows.map(row => row.length));
                        let matrix = rows.map(row => row.padEnd(width, '.').split(''));
                        const rotations = [];
                        for (let i = 0; i < 4; i++) {
                            rotations.push(normalizeRotation(matrix));
                            matrix = rotateMatrix(matrix);
                        }
                        SHAPES[name] = { color: COLORS[name], rotations };
                    });

                    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                    let bag = [];
                    let current = null;
                    let next = null;
                    let dropTimer = 0;
                    let softDrop = false;
                    let linesCleared = 0;
                    let level = 1;
                    let ended = false;

                    const cellSize = Math.floor(Math.min(api.height / ROWS, api.width / COLS));
                    const wellWidth = cellSize * COLS;
                    const wellHeight = cellSize * ROWS;
                    const offsetX = Math.floor((api.width - wellWidth) / 2);
                    const offsetY = Math.floor((api.height - wellHeight) / 2);

                    const shuffleBag = () => {
                        bag = Object.keys(SHAPES);
                        for (let i = bag.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [bag[i], bag[j]] = [bag[j], bag[i]];
                        }
                    };

                    const drawCell = (ctx, x, y, color, alpha = 1) => {
                        const px = offsetX + x * cellSize;
                        const py = offsetY + y * cellSize;
                        ctx.save();
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = color;
                        ctx.fillRect(px + 1, py + 1, cellSize - 2, cellSize - 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.12)';
                        ctx.fillRect(px + 1, py + 1, cellSize - 2, 4);
                        ctx.restore();
                    };

                    const newPiece = () => {
                        if (!bag.length) shuffleBag();
                        const type = bag.pop();
                        return { type, rotation: 0, x: 0, y: 0 };
                    };

                    const shapeAt = (piece, rotationIndex = piece.rotation) => SHAPES[piece.type].rotations[(rotationIndex + 4) % 4];

                    const collides = (x, y, rotationIndex = current.rotation) => {
                        const shape = shapeAt(current, rotationIndex);
                        return shape.cells.some(cell => {
                            const px = x + cell.x;
                            const py = y + cell.y;
                            if (px < 0 || px >= COLS) return true;
                            if (py >= ROWS) return true;
                            if (py < 0) return false;
                            return Boolean(board[py][px]);
                        });
                    };

                    const placePiece = () => {
                        const shape = shapeAt(current);
                        let topOut = false;
                        shape.cells.forEach(cell => {
                            const px = current.x + cell.x;
                            const py = current.y + cell.y;
                            if (py < 0) {
                                topOut = true;
                            } else {
                                board[py][px] = SHAPES[current.type].color;
                            }
                        });
                        if (topOut) {
                            ended = true;
                            api.gameOver('Stack overflow — game over');
                        }
                    };

                    const clearLines = () => {
                        let cleared = 0;
                        for (let y = ROWS - 1; y >= 0; y--) {
                            if (board[y].every(cell => cell)) {
                                board.splice(y, 1);
                                board.unshift(Array(COLS).fill(null));
                                cleared += 1;
                                y += 1;
                            }
                        }
                        if (cleared) {
                            linesCleared += cleared;
                            const scoreTable = [0, 100, 300, 500, 800];
                            const gained = scoreTable[cleared] * level;
                            api.addScore(gained);
                            api.log(`${cleared} line${cleared > 1 ? 's' : ''} cleared (+${gained}).`);
                            const nextLevel = Math.floor(linesCleared / 10) + 1;
                            if (nextLevel !== level) {
                                level = nextLevel;
                                api.setLevel(level);
                                api.log(`Level up — Level ${level}`);
                            }
                        }
                    };

                    const spawn = () => {
                        current = next || newPiece();
                        current.rotation = 0;
                        const shape = shapeAt(current, 0);
                        current.x = Math.floor((COLS - shape.width) / 2);
                        current.y = -shape.height + 1;
                        next = newPiece();
                        api.log(`Next: ${next.type}`);
                        if (collides(current.x, current.y, current.rotation)) {
                            ended = true;
                            api.gameOver('No room for new piece — game over');
                        }
                    };

                    const move = (dx, dy) => {
                        if (!current || ended) return false;
                        const nextX = current.x + dx;
                        const nextY = current.y + dy;
                        if (!collides(nextX, nextY)) {
                            current.x = nextX;
                            current.y = nextY;
                            return true;
                        }
                        return false;
                    };

                    const rotate = direction => {
                        if (!current || ended) return false;
                        const nextRotation = (current.rotation + direction + 4) % 4;
                        if (!collides(current.x, current.y, nextRotation)) {
                            current.rotation = nextRotation;
                            return true;
                        }
                        const kicks = [-1, 1, -2, 2];
                        for (const offset of kicks) {
                            if (!collides(current.x + offset, current.y, nextRotation)) {
                                current.x += offset;
                                current.rotation = nextRotation;
                                return true;
                            }
                        }
                        return false;
                    };

                    const hardDrop = () => {
                        if (!current || ended) return;
                        let distance = 0;
                        while (move(0, 1)) distance += 1;
                        api.addScore(distance * 2);
                        lock();
                    };

                    const ghostPosition = () => {
                        if (!current) return null;
                        let y = current.y;
                        while (!collides(current.x, y + 1)) y += 1;
                        return y;
                    };

                    const lock = () => {
                        placePiece();
                        if (ended) return;
                        clearLines();
                        api.addScore(10);
                        spawn();
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#050b18';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                        for (let x = 0; x <= COLS; x++) {
                            ctx.beginPath();
                            ctx.moveTo(offsetX + x * cellSize + 0.5, offsetY + 0.5);
                            ctx.lineTo(offsetX + x * cellSize + 0.5, offsetY + wellHeight + 0.5);
                            ctx.stroke();
                        }
                        for (let y = 0; y <= ROWS; y++) {
                            ctx.beginPath();
                            ctx.moveTo(offsetX + 0.5, offsetY + y * cellSize + 0.5);
                            ctx.lineTo(offsetX + wellWidth + 0.5, offsetY + y * cellSize + 0.5);
                            ctx.stroke();
                        }

                        for (let y = 0; y < ROWS; y++) {
                            for (let x = 0; x < COLS; x++) {
                                const color = board[y][x];
                                if (color) drawCell(ctx, x, y, color, 1);
                            }
                        }

                        if (current && !ended) {
                            const ghostY = ghostPosition();
                            if (ghostY !== null && ghostY !== current.y) {
                                const shape = shapeAt(current);
                                shape.cells.forEach(cell => {
                                    const px = current.x + cell.x;
                                    const py = ghostY + cell.y;
                                    if (py >= 0) drawCell(ctx, px, py, SHAPES[current.type].color, 0.18);
                                });
                            }
                            const shape = shapeAt(current);
                            shape.cells.forEach(cell => {
                                const px = current.x + cell.x;
                                const py = current.y + cell.y;
                                if (py >= 0) drawCell(ctx, px, py, SHAPES[current.type].color, 1);
                            });
                        }

                        if (next) {
                            const previewSize = Math.max(16, Math.floor(cellSize * 0.6));
                            const previewX = offsetX + wellWidth + 24;
                            const previewY = offsetY + 24;
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,255,255,0.08)';
                            ctx.fillRect(previewX - 16, previewY - 16, previewSize * 4, previewSize * 4);
                            ctx.fillStyle = '#fff';
                            ctx.font = '14px "SF Pro Text", sans-serif';
                            ctx.fillText('Next', previewX - 12, previewY - 20);
                            const shape = shapeAt(next, 0);
                            shape.cells.forEach(cell => {
                                const px = previewX + cell.x * previewSize;
                                const py = previewY + cell.y * previewSize;
                                ctx.fillStyle = SHAPES[next.type].color;
                                ctx.fillRect(px, py, previewSize - 4, previewSize - 4);
                            });
                            ctx.restore();
                        }
                    };

                    const step = delta => {
                        if (ended || !current) return;
                        const dropSpeed = Math.max(0.12, 0.85 - (level - 1) * 0.07);
                        dropTimer += delta * (softDrop ? 6 : 1);
                        if (dropTimer >= dropSpeed) {
                            dropTimer = 0;
                            if (!move(0, 1)) {
                                lock();
                            }
                        }
                    };

                    return {
                        init() {
                            api.resetMetrics();
                            api.setLives('∞');
                            api.setLevel(1);
                            api.setStatus('Ready');
                            linesCleared = 0;
                            level = 1;
                            ended = false;
                            for (let y = 0; y < ROWS; y++) board[y].fill(null);
                            shuffleBag();
                            current = null;
                            next = newPiece();
                            spawn();
                            draw(api.ctx);
                        },
                        start() {
                            if (!current) spawn();
                            dropTimer = 0;
                            api.setStatus('Running');
                        },
                        update(delta) {
                            step(delta);
                        },
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event, state) {
                            if (!current || ended || state.paused) return false;
                            switch (event.key) {
                                case 'ArrowLeft':
                                    move(-1, 0);
                                    return true;
                                case 'ArrowRight':
                                    move(1, 0);
                                    return true;
                                case 'ArrowDown':
                                    softDrop = true;
                                    move(0, 1);
                                    api.addScore(1);
                                    return true;
                                case 'ArrowUp':
                                    rotate(1);
                                    return true;
                                case 'Enter':
                                    hardDrop();
                                    return true;
                                default:
                                    return false;
                            }
                        },
                        handleKeyUp(event) {
                            if (event.key === 'ArrowDown') {
                                softDrop = false;
                                return true;
                            }
                            return false;
                        },
                        destroy() {
                            ended = true;
                        }
                    };
                }
            });
        }

        function createSnakeApp() {
            return createCanvasGameApp({
                id: 'snake',
                name: 'Neon Snake',
                icon: '🐍',
                hint: 'Collect pellets and grow',
                instructions: [
                    'Use ← ↑ ↓ → or WASD to steer the snake.',
                    'Each fruit speeds things up. Avoid walls and your own tail.',
                    'Space or Esc pauses when you need a breather.'
                ],
                difficulty: [
                    { value: 'chill', label: 'Chill' },
                    { value: 'normal', label: 'Normal' },
                    { value: 'turbo', label: 'Turbo' }
                ],
                legend: [
                    { color: '#6ddccf', label: 'Snake' },
                    { color: '#ffbd2e', label: 'Fruit' }
                ],
                createGame(api) {
                    const GRID = 24;
                    const cellSize = Math.floor(Math.min(api.width, api.height) / GRID);
                    const playWidth = cellSize * GRID;
                    const playHeight = cellSize * GRID;
                    const offsetX = Math.floor((api.width - playWidth) / 2);
                    const offsetY = Math.floor((api.height - playHeight) / 2);
                    const difficultySpeed = { chill: 4, normal: 6, turbo: 8 };

                    let speed = difficultySpeed[api.difficulty] || difficultySpeed.normal;
                    let timer = 0;
                    let direction = { x: 1, y: 0 };
                    let nextDirection = { x: 1, y: 0 };
                    let snake = [];
                    let food = null;
                    let score = 0;
                    let alive = true;

                    const resetSnake = () => {
                        snake = [
                            { x: Math.floor(GRID / 2) - 1, y: Math.floor(GRID / 2) },
                            { x: Math.floor(GRID / 2) - 2, y: Math.floor(GRID / 2) },
                            { x: Math.floor(GRID / 2) - 3, y: Math.floor(GRID / 2) }
                        ];
                        direction = { x: 1, y: 0 };
                        nextDirection = { x: 1, y: 0 };
                        speed = difficultySpeed[api.difficulty] || difficultySpeed.normal;
                        score = 0;
                        api.setScore(0);
                        api.setLevel(1);
                        api.setLives('—');
                        api.setStatus('Ready');
                        alive = true;
                        spawnFood();
                    };

                    const spawnFood = () => {
                        let attempts = 0;
                        do {
                            food = {
                                x: Math.floor(Math.random() * GRID),
                                y: Math.floor(Math.random() * GRID)
                            };
                            attempts += 1;
                        } while (snake.some(segment => segment.x === food.x && segment.y === food.y) && attempts < 200);
                    };

                    const drawGrid = ctx => {
                        ctx.fillStyle = '#050b18';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.fillStyle = 'rgba(255,255,255,0.04)';
                        for (let y = 0; y < GRID; y++) {
                            for (let x = 0; x < GRID; x++) {
                                ctx.fillRect(offsetX + x * cellSize + 1, offsetY + y * cellSize + 1, cellSize - 2, cellSize - 2);
                            }
                        }
                    };

                    const drawSnake = ctx => {
                        snake.forEach((segment, index) => {
                            const hue = 160 + index * 2;
                            ctx.fillStyle = `hsl(${hue % 360}, 70%, 55%)`;
                            ctx.fillRect(offsetX + segment.x * cellSize + 2, offsetY + segment.y * cellSize + 2, cellSize - 4, cellSize - 4);
                        });
                        const head = snake[0];
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(offsetX + head.x * cellSize + cellSize * 0.2, offsetY + head.y * cellSize + cellSize * 0.25, cellSize * 0.12, cellSize * 0.12);
                        ctx.fillRect(offsetX + head.x * cellSize + cellSize * 0.68, offsetY + head.y * cellSize + cellSize * 0.25, cellSize * 0.12, cellSize * 0.12);
                    };

                    const drawFood = ctx => {
                        if (!food) return;
                        ctx.fillStyle = '#ffbd2e';
                        ctx.beginPath();
                        ctx.arc(
                            offsetX + food.x * cellSize + cellSize / 2,
                            offsetY + food.y * cellSize + cellSize / 2,
                            cellSize * 0.38,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.fillStyle = '#fff8';
                        ctx.beginPath();
                        ctx.arc(
                            offsetX + food.x * cellSize + cellSize * 0.3,
                            offsetY + food.y * cellSize + cellSize * 0.3,
                            cellSize * 0.1,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    };

                    const step = () => {
                        if (!alive) return;
                        direction = nextDirection;
                        const head = snake[0];
                        const newHead = { x: head.x + direction.x, y: head.y + direction.y };
                        if (
                            newHead.x < 0 ||
                            newHead.y < 0 ||
                            newHead.x >= GRID ||
                            newHead.y >= GRID ||
                            snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)
                        ) {
                            alive = false;
                            api.gameOver('Snake crashed!');
                            return;
                        }
                        snake.unshift(newHead);
                        if (food && newHead.x === food.x && newHead.y === food.y) {
                            score += 10;
                            api.addScore(10);
                            const level = Math.min(10, Math.floor(score / 50) + 1);
                            api.setLevel(level);
                            speed = (difficultySpeed[api.difficulty] || difficultySpeed.normal) + level * 0.4;
                            api.log(`Fruit collected! Score ${score}.`);
                            spawnFood();
                        } else {
                            snake.pop();
                        }
                    };

                    return {
                        init() {
                            api.resetMetrics();
                            resetSnake();
                            api.log('Snake ready. Collect fruit to grow!');
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!alive) return;
                            timer += delta * speed;
                            if (timer >= 1) {
                                timer = 0;
                                step();
                            }
                        },
                        render(ctx) {
                            drawGrid(ctx);
                            drawFood(ctx);
                            drawSnake(ctx);
                        },
                        handleKeyDown(event, state) {
                            if (state.paused) return false;
                            const key = event.key.toLowerCase();
                            const map = {
                                arrowup: { x: 0, y: -1 },
                                w: { x: 0, y: -1 },
                                arrowdown: { x: 0, y: 1 },
                                s: { x: 0, y: 1 },
                                arrowleft: { x: -1, y: 0 },
                                a: { x: -1, y: 0 },
                                arrowright: { x: 1, y: 0 },
                                d: { x: 1, y: 0 }
                            };
                            if (!(key in map)) return false;
                            const desired = map[key];
                            if (desired.x === -direction.x && desired.y === -direction.y) return true;
                            nextDirection = desired;
                            return true;
                        },
                        destroy() {
                            alive = false;
                        }
                    };
                }
            });
        }

        function createPongApp() {
            return createCanvasGameApp({
                id: 'pong',
                name: 'Quantum Pong',
                icon: '🏓',
                hint: 'Classic paddle duel',
                instructions: [
                    'Move with ↑ and ↓ (or W and S). Keep the ball in play.',
                    'First to 7 points wins. CPU adapts as rallies get longer.',
                    'Tap the canvas or press Space to pause/resume.'
                ],
                legend: [
                    { color: '#7b8bff', label: 'Player Paddle' },
                    { color: '#ff7096', label: 'CPU Paddle' },
                    { color: '#fdd835', label: 'Ball' }
                ],
                createGame(api) {
                    const paddleWidth = 14;
                    const paddleHeight = 96;
                    const paddleMargin = 36;
                    const ballRadius = 10;
                    const player = { y: api.height / 2 - paddleHeight / 2, score: 0 };
                    const cpu = { y: api.height / 2 - paddleHeight / 2, score: 0, momentum: 0 };
                    let ball = { x: api.width / 2, y: api.height / 2, vx: 260, vy: 160 };
                    let keys = { up: false, down: false };
                    let rally = 0;
                    let serving = 1; // 1 player, -1 cpu

                    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

                    const serve = () => {
                        ball.x = api.width / 2;
                        ball.y = api.height / 2;
                        const angle = (Math.random() * 0.6 - 0.3) * Math.PI;
                        const speed = 260 + Math.min(240, rally * 12);
                        ball.vx = Math.cos(angle) * speed * serving;
                        ball.vy = Math.sin(angle) * speed;
                        rally = 0;
                        api.log(`${serving === 1 ? 'Player' : 'CPU'} serves.`);
                    };

                    const resetMatch = () => {
                        player.score = 0;
                        cpu.score = 0;
                        rally = 0;
                        serving = 1;
                        api.setScore(0);
                        api.setLevel(0);
                        api.setLives('Rally 0');
                        api.setStatus('Ready');
                        serve();
                    };

                    const updateScoreboard = () => {
                        api.setScore(player.score);
                        api.setLevel(cpu.score);
                        api.setStatus(`Player ${player.score} — CPU ${cpu.score}`);
                    };

                    const pointWon = winner => {
                        if (winner === 'player') {
                            player.score += 1;
                            serving = -1;
                            api.log('Point for player!');
                            api.addScore(25);
                        } else {
                            cpu.score += 1;
                            serving = 1;
                            api.log('CPU scores.');
                        }
                        updateScoreboard();
                        if (player.score >= 7) {
                            api.gameOver('Victory! You outplayed the CPU.');
                            return;
                        }
                        if (cpu.score >= 7) {
                            api.gameOver('CPU wins the set. Try again!');
                            return;
                        }
                        api.setLives(`Rally ${rally}`);
                        serve();
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#030915';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.setLineDash([12, 12]);
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.beginPath();
                        ctx.moveTo(api.width / 2, 0);
                        ctx.lineTo(api.width / 2, api.height);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#7b8bff';
                        ctx.fillRect(paddleMargin, player.y, paddleWidth, paddleHeight);
                        ctx.fillStyle = '#ff7096';
                        ctx.fillRect(api.width - paddleMargin - paddleWidth, cpu.y, paddleWidth, paddleHeight);
                        ctx.fillStyle = '#fdd835';
                        ctx.beginPath();
                        ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    const paddleCollision = paddleY => ball.y + ballRadius >= paddleY && ball.y - ballRadius <= paddleY + paddleHeight;

                    return {
                        init() {
                            api.resetMetrics();
                            resetMatch();
                            api.log('Pong ready. First to 7 wins!');
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (delta > 0.1) return; // avoid large jumps
                            const playerSpeed = 420;
                            if (keys.up) player.y -= playerSpeed * delta;
                            if (keys.down) player.y += playerSpeed * delta;
                            player.y = clamp(player.y, 12, api.height - paddleHeight - 12);

                            const target = ball.y - (cpu.y + paddleHeight / 2);
                            const cpuSpeed = 260 + Math.min(220, rally * 8);
                            cpu.y += clamp(target, -cpuSpeed * delta, cpuSpeed * delta);
                            cpu.y = clamp(cpu.y, 12, api.height - paddleHeight - 12);

                            ball.x += ball.vx * delta;
                            ball.y += ball.vy * delta;

                            if (ball.y - ballRadius <= 6 || ball.y + ballRadius >= api.height - 6) {
                                ball.vy *= -1;
                                ball.y = clamp(ball.y, ballRadius + 6, api.height - ballRadius - 6);
                            }

                            const playerX = paddleMargin;
                            const cpuX = api.width - paddleMargin - paddleWidth;

                            if (ball.vx < 0 && ball.x - ballRadius <= playerX + paddleWidth && paddleCollision(player.y, playerX)) {
                                const relative = (ball.y - (player.y + paddleHeight / 2)) / (paddleHeight / 2);
                                const angle = relative * 0.75 * Math.PI;
                                const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2) * 1.05;
                                ball.vx = Math.cos(angle) * speed;
                                ball.vy = Math.sin(angle) * speed;
                                ball.x = playerX + paddleWidth + ballRadius + 1;
                                rally += 1;
                                api.setLives(`Rally ${rally}`);
                                api.log(`Rally length ${rally}.`);
                            } else if (ball.vx > 0 && ball.x + ballRadius >= cpuX && paddleCollision(cpu.y, cpuX)) {
                                const relative = (ball.y - (cpu.y + paddleHeight / 2)) / (paddleHeight / 2);
                                const angle = relative * 0.7 * Math.PI;
                                const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2) * 1.04;
                                ball.vx = -Math.cos(angle) * speed;
                                ball.vy = Math.sin(angle) * speed;
                                ball.x = cpuX - ballRadius - 1;
                                rally += 1;
                                api.setLives(`Rally ${rally}`);
                            }

                            if (ball.x < -ballRadius - 20) pointWon('cpu');
                            else if (ball.x > api.width + ballRadius + 20) pointWon('player');
                        },
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event, state) {
                            if (state.paused) return false;
                            if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') {
                                keys.up = true;
                                return true;
                            }
                            if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') {
                                keys.down = true;
                                return true;
                            }
                            return false;
                        },
                        handleKeyUp(event) {
                            if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') {
                                keys.up = false;
                                return true;
                            }
                            if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') {
                                keys.down = false;
                                return true;
                            }
                            return false;
                        },
                        handlePointer(type, event) {
                            if (type === 'move' && event.buttons) {
                                const rect = api.canvas.getBoundingClientRect();
                                const y = event.clientY - rect.top - paddleHeight / 2;
                                player.y = clamp(y * (api.canvas.height / rect.height), 12, api.height - paddleHeight - 12);
                            }
                        },
                        destroy() {
                            keys = { up: false, down: false };
                        }
                    };
                }
            });
        }

        function createBreakoutApp() {
            return createCanvasGameApp({
                id: 'breakout',
                name: 'Neon Breakout',
                icon: '🧱',
                hint: 'Smash every brick',
                instructions: [
                    'Move with ← and → (or A and D). Bounce the ball with the paddle.',
                    'Clear all bricks to advance. Missing the ball costs a life.',
                    'Power hits speed up the ball — keep control!' ],
                legend: [
                    { color: '#7b8bff', label: 'Standard brick' },
                    { color: '#ff8f70', label: 'Tough brick' },
                    { color: '#fdd835', label: 'Ball' }
                ],
                createGame(api) {
                    const rows = 6;
                    const cols = 10;
                    const topOffset = 80;
                    const brickGap = 8;
                    const paddle = { width: 120, height: 16, x: api.width / 2 - 60, y: api.height - 60, speed: 560 };
                    const ball = { x: api.width / 2, y: paddle.y - 18, vx: 220, vy: -260, radius: 9, stuck: true };
                    let bricks = [];
                    let lives = 3;
                    let level = 1;
                    let score = 0;
                    let pointerActive = false;
                    let pointerTarget = paddle.x;
                    let keys = { left: false, right: false };

                    const brickWidth = (api.width - brickGap * (cols + 1)) / cols;
                    const brickHeight = 22;

                    const buildLevel = () => {
                        bricks = [];
                        for (let row = 0; row < rows; row++) {
                            for (let col = 0; col < cols; col++) {
                                const strength = row < 2 ? 2 : 1;
                                bricks.push({
                                    x: brickGap + col * (brickWidth + brickGap),
                                    y: topOffset + row * (brickHeight + brickGap),
                                    strength,
                                    hue: 200 + row * 20 + col,
                                    alive: true
                                });
                            }
                        }
                    };

                    const resetBall = () => {
                        ball.x = paddle.x + paddle.width / 2;
                        ball.y = paddle.y - ball.radius - 2;
                        ball.vx = 200 * (Math.random() > 0.5 ? 1 : -1);
                        ball.vy = -260;
                        ball.stuck = true;
                    };

                    const resetGame = () => {
                        level = 1;
                        lives = 3;
                        score = 0;
                        api.setScore(0);
                        api.setLevel(level);
                        api.setLives(`Lives ${lives}`);
                        api.setStatus('Ready');
                        buildLevel();
                        resetBall();
                        api.log('Breakout ready. Click or press Space to launch!');
                    };

                    const launchBall = () => {
                        if (!ball.stuck) return;
                        ball.stuck = false;
                        const angle = (Math.random() * 0.6 + 0.2) * Math.PI;
                        ball.vx = Math.cos(angle) * 300 * (Math.random() > 0.5 ? 1 : -1);
                        ball.vy = -Math.abs(Math.sin(angle) * 300) - (level - 1) * 30;
                        api.setStatus('Running');
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#030c1d';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.fillStyle = '#1a233a';
                        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
                        bricks.forEach(brick => {
                            if (!brick.alive) return;
                            const alpha = brick.strength === 2 ? 0.95 : 0.78;
                            ctx.fillStyle = `hsla(${brick.hue % 360}, 70%, 60%, ${alpha})`;
                            ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);
                            ctx.fillStyle = 'rgba(255,255,255,0.15)';
                            ctx.fillRect(brick.x, brick.y, brickWidth, 4);
                        });
                        ctx.fillStyle = '#fdd835';
                        ctx.beginPath();
                        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    const advanceLevel = () => {
                        level += 1;
                        api.setLevel(level);
                        api.log(`Level ${level}! Bricks reinforced.`);
                        buildLevel();
                        resetBall();
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${lives}`);
                        if (lives <= 0) {
                            api.gameOver('No more paddles — game over!');
                            return;
                        }
                        api.log(`Missed! ${lives} lives remaining.`);
                        resetBall();
                    };

                    const updateBall = delta => {
                        if (ball.stuck) {
                            ball.x = paddle.x + paddle.width / 2;
                            ball.y = paddle.y - ball.radius - 2;
                            return;
                        }
                        ball.x += ball.vx * delta;
                        ball.y += ball.vy * delta;

                        if (ball.x - ball.radius <= 0 && ball.vx < 0) {
                            ball.x = ball.radius;
                            ball.vx *= -1;
                        }
                        if (ball.x + ball.radius >= api.width && ball.vx > 0) {
                            ball.x = api.width - ball.radius;
                            ball.vx *= -1;
                        }
                        if (ball.y - ball.radius <= 0 && ball.vy < 0) {
                            ball.y = ball.radius;
                            ball.vy *= -1;
                        }

                        if (ball.y + ball.radius >= paddle.y && ball.y <= paddle.y + paddle.height) {
                            if (ball.x >= paddle.x - ball.radius && ball.x <= paddle.x + paddle.width + ball.radius && ball.vy > 0) {
                                const offset = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                                const angle = offset * 0.8;
                                const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2) + 12;
                                ball.vx = Math.sin(angle) * speed;
                                ball.vy = -Math.abs(Math.cos(angle) * speed);
                                ball.y = paddle.y - ball.radius - 1;
                                api.log('Nice save!');
                            }
                        }

                        if (ball.y - ball.radius > api.height) {
                            loseLife();
                        }

                        bricks.forEach(brick => {
                            if (!brick.alive) return;
                            if (
                                ball.x + ball.radius >= brick.x &&
                                ball.x - ball.radius <= brick.x + brickWidth &&
                                ball.y + ball.radius >= brick.y &&
                                ball.y - ball.radius <= brick.y + brickHeight
                            ) {
                                brick.strength -= 1;
                                if (brick.strength <= 0) {
                                    brick.alive = false;
                                    score += 20;
                                    api.addScore(20);
                                } else {
                                    api.addScore(5);
                                }
                                const overlapLeft = Math.abs((brick.x - (ball.x + ball.radius)));
                                const overlapRight = Math.abs(((brick.x + brickWidth) - (ball.x - ball.radius)));
                                const overlapTop = Math.abs((brick.y - (ball.y + ball.radius)));
                                const overlapBottom = Math.abs(((brick.y + brickHeight) - (ball.y - ball.radius)));
                                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                                if (minOverlap === overlapLeft || minOverlap === overlapRight) ball.vx *= -1;
                                else ball.vy *= -1;
                            }
                        });

                        if (bricks.every(brick => !brick.alive)) {
                            advanceLevel();
                        }
                    };

                    return {
                        init() {
                            api.resetMetrics();
                            resetGame();
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (delta > 0.05) delta = 0.05;
                            if (pointerActive) {
                                const dx = pointerTarget - paddle.x;
                                paddle.x += dx * Math.min(1, delta * 12);
                            } else {
                                if (keys.left) paddle.x -= paddle.speed * delta;
                                if (keys.right) paddle.x += paddle.speed * delta;
                            }
                            paddle.x = Math.max(12, Math.min(api.width - paddle.width - 12, paddle.x));
                            updateBall(delta);
                        },
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event, state) {
                            if (state.paused) return false;
                            if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') {
                                keys.left = true;
                                return true;
                            }
                            if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') {
                                keys.right = true;
                                return true;
                            }
                            if (event.key === ' ' && ball.stuck) {
                                launchBall();
                                return true;
                            }
                            return false;
                        },
                        handleKeyUp(event) {
                            if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') {
                                keys.left = false;
                                return true;
                            }
                            if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') {
                                keys.right = false;
                                return true;
                            }
                            return false;
                        },
                        handlePointer(type, event) {
                            if (type === 'down') {
                                pointerActive = true;
                                if (ball.stuck) launchBall();
                            }
                            if (type === 'up' || type === 'cancel') pointerActive = false;
                            if (type === 'move') {
                                const rect = api.canvas.getBoundingClientRect();
                                pointerTarget = (event.clientX - rect.left) * (api.canvas.width / rect.width) - paddle.width / 2;
                            }
                        },
                        destroy() {
                            pointerActive = false;
                        }
                    };
                }
            });
        }

        function createMinesweeperApp() {
            return createCanvasGameApp({
                id: 'minesweeper',
                name: 'Minesweeper Pro',
                icon: '🧨',
                hint: 'Classic logic puzzle',
                instructions: [
                    'Left click to reveal tiles. Right click (or Alt/⌘) to flag mines.',
                    'Clear the board without detonating a mine.',
                    'Space / Esc pauses. Change difficulty from the dropdown.'
                ],
                difficulty: [
                    { value: 'beginner', label: 'Beginner 9×9 · 10 mines' },
                    { value: 'intermediate', label: 'Intermediate 16×16 · 40' },
                    { value: 'expert', label: 'Expert 16×30 · 99' }
                ],
                legend: [
                    { color: '#4aa3ff', label: '1 adjacent mine' },
                    { color: '#66bb6a', label: '2 adjacent mines' },
                    { color: '#ef5350', label: 'Mine' }
                ],
                createGame(api) {
                    const configs = {
                        beginner: { rows: 9, cols: 9, mines: 10 },
                        intermediate: { rows: 16, cols: 16, mines: 40 },
                        expert: { rows: 16, cols: 30, mines: 99 }
                    };

                    const consumeContextMenu = event => event.preventDefault();

                    const colors = {
                        1: '#42a5f5',
                        2: '#66bb6a',
                        3: '#ef5350',
                        4: '#ab47bc',
                        5: '#ff9800',
                        6: '#26c6da',
                        7: '#bdbdbd',
                        8: '#90a4ae'
                    };

                    const config = configs[api.difficulty] || configs.beginner;
                    const rows = config.rows;
                    const cols = config.cols;
                    const mineTotal = config.mines;

                    const cellSize = Math.floor(Math.min(api.height / rows, api.width / cols));
                    const boardWidth = cellSize * cols;
                    const boardHeight = cellSize * rows;
                    const offsetX = Math.floor((api.width - boardWidth) / 2);
                    const offsetY = Math.floor((api.height - boardHeight) / 2);

                    let cells = [];
                    let firstReveal = true;
                    let flagsPlaced = 0;
                    let revealedSafe = 0;
                    let active = true;

                    const index = (r, c) => r * cols + c;

                    const neighbors = (r, c, consumer) => {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (!dr && !dc) continue;
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) consumer(cells[index(nr, nc)], nr, nc);
                            }
                        }
                    };

                    const seedBoard = (safeRow, safeCol) => {
                        let placed = 0;
                        while (placed < mineTotal) {
                            const r = Math.floor(Math.random() * rows);
                            const c = Math.floor(Math.random() * cols);
                            const cell = cells[index(r, c)];
                            if (cell.mine) continue;
                            if (Math.abs(r - safeRow) <= 1 && Math.abs(c - safeCol) <= 1) continue;
                            cell.mine = true;
                            placed += 1;
                        }
                        cells.forEach((cell, i) => {
                            const r = Math.floor(i / cols);
                            const c = i % cols;
                            if (cell.mine) {
                                cell.adjacent = -1;
                                return;
                            }
                            let count = 0;
                            neighbors(r, c, neighborCell => { if (neighborCell.mine) count += 1; });
                            cell.adjacent = count;
                        });
                    };

                    const resetBoard = () => {
                        cells = Array.from({ length: rows * cols }, () => ({ mine: false, revealed: false, flagged: false, adjacent: 0 }));
                        firstReveal = true;
                        flagsPlaced = 0;
                        revealedSafe = 0;
                        active = true;
                        api.setScore(0);
                        api.setLevel(rows * cols - mineTotal);
                        api.setLives(`Flags ${mineTotal}`);
                        api.setStatus('Ready');
                    };

                    const revealCell = (r, c) => {
                        const cell = cells[index(r, c)];
                        if (!cell || cell.revealed || cell.flagged) return 0;
                        if (cell.mine) {
                            cell.revealed = true;
                            return -1;
                        }
                        const stack = [cell];
                        const queue = [[r, c]];
                        let revealed = 0;
                        while (queue.length) {
                            const [cr, cc] = queue.pop();
                            const current = cells[index(cr, cc)];
                            if (current.revealed || current.flagged) continue;
                            current.revealed = true;
                            revealed += 1;
                            if (!current.mine && current.adjacent === 0) {
                                neighbors(cr, cc, (neighborCell, nr, nc) => {
                                    if (!neighborCell.revealed && !neighborCell.flagged) queue.push([nr, nc]);
                                });
                            }
                        }
                        return revealed;
                    };

                    const toggleFlag = (r, c) => {
                        const cell = cells[index(r, c)];
                        if (!cell || cell.revealed) return;
                        cell.flagged = !cell.flagged;
                        flagsPlaced += cell.flagged ? 1 : -1;
                        api.setLives(`Flags ${Math.max(0, mineTotal - flagsPlaced)}`);
                    };

                    const detonate = () => {
                        active = false;
                        cells.forEach(cell => {
                            if (cell.mine) cell.revealed = true;
                        });
                        api.gameOver('KABOOM! Mine triggered.');
                    };

                    const checkVictory = () => {
                        if (revealedSafe >= rows * cols - mineTotal) {
                            active = false;
                            api.gameOver('Field cleared!🎉');
                        }
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#030c1d';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.translate(offsetX, offsetY);
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                const cell = cells[index(r, c)];
                                const x = c * cellSize;
                                const y = r * cellSize;
                                ctx.save();
                                ctx.translate(x, y);
                                ctx.fillStyle = cell.revealed ? 'rgba(255,255,255,0.15)' : 'rgba(28,36,58,0.85)';
                                ctx.fillRect(1, 1, cellSize - 2, cellSize - 2);
                                if (!cell.revealed) {
                                    ctx.fillStyle = 'rgba(255,255,255,0.12)';
                                    ctx.fillRect(1, 1, cellSize - 2, 4);
                                }
                                if (cell.revealed) {
                                    if (cell.mine) {
                                        ctx.fillStyle = '#ef5350';
                                        ctx.beginPath();
                                        ctx.arc(cellSize / 2, cellSize / 2, cellSize * 0.28, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.fillStyle = '#ffffff66';
                                        ctx.beginPath();
                                        ctx.arc(cellSize / 2 - 2, cellSize / 2 - 2, cellSize * 0.12, 0, Math.PI * 2);
                                        ctx.fill();
                                    } else if (cell.adjacent > 0) {
                                        ctx.fillStyle = colors[cell.adjacent] || '#ffffff';
                                        ctx.font = `${Math.floor(cellSize * 0.6)}px "SF Pro Text", sans-serif`;
                                        ctx.textAlign = 'center';
                                        ctx.textBaseline = 'middle';
                                        ctx.fillText(cell.adjacent, cellSize / 2, cellSize / 2 + 1);
                                    }
                                } else if (cell.flagged) {
                                    ctx.fillStyle = '#ffbd2e';
                                    ctx.beginPath();
                                    ctx.moveTo(cellSize * 0.28, cellSize * 0.72);
                                    ctx.lineTo(cellSize * 0.28, cellSize * 0.28);
                                    ctx.lineTo(cellSize * 0.7, cellSize * 0.42);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                                ctx.restore();
                            }
                        }
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                    };

                    const handleReveal = (r, c) => {
                        if (!active) return;
                        const cell = cells[index(r, c)];
                        if (!cell || cell.flagged || cell.revealed) return;
                        if (firstReveal) {
                            seedBoard(r, c);
                            firstReveal = false;
                            api.setStatus('Running');
                        }
                        const result = revealCell(r, c);
                        if (result === -1) {
                            cell.mine = true;
                            detonate();
                            return;
                        }
                        revealedSafe += result;
                        api.addScore(result);
                        checkVictory();
                    };

                    return {
                        init() {
                            api.resetMetrics();
                            resetBoard();
                            api.canvas.addEventListener('contextmenu', consumeContextMenu, { passive: false });
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update() {},
                        render(ctx) {
                            draw(ctx);
                        },
                        handlePointer(type, event, state) {
                            if (type !== 'down' || !active || state.paused) return;
                            const rect = api.canvas.getBoundingClientRect();
                            const scaleX = api.canvas.width / rect.width;
                            const scaleY = api.canvas.height / rect.height;
                            const canvasX = (event.clientX - rect.left) * scaleX;
                            const canvasY = (event.clientY - rect.top) * scaleY;
                            const col = Math.floor((canvasX - offsetX) / cellSize);
                            const row = Math.floor((canvasY - offsetY) / cellSize);
                            if (row < 0 || row >= rows || col < 0 || col >= cols) return;
                            if (event.button === 2 || event.ctrlKey || event.metaKey) toggleFlag(row, col);
                            else handleReveal(row, col);
                        },
                        destroy() {
                            api.canvas.removeEventListener('contextmenu', consumeContextMenu);
                        }
                    };
                }
            });
        }

        function createFlappyBirdApp() {
            return createCanvasGameApp({
                id: 'flappy-bird',
                name: 'Flappy Flight',
                icon: '🐦',
                hint: 'Endless obstacle runner',
                instructions: [
                    'Press Space or click to flap upwards.',
                    'Navigate through the gaps to score.',
                    'Pipes speed up as you survive longer.'
                ],
                legend: [
                    { color: '#4aa3ff', label: 'Safe gap' },
                    { color: '#ef5350', label: 'Obstacle' }
                ],
                createGame(api) {
                    const bird = { x: api.width * 0.28, y: api.height / 2, vy: 0 };
                    const gravity = 820;
                    const flapVelocity = -320;
                    const pipes = [];
                    const pipeWidth = 68;
                    const gapHeight = 180;
                    const spawnInterval = 1.5;
                    let spawnTimer = 0;
                    let score = 0;
                    let best = Number(localStorage.getItem('webos.flappy.best') || '0');
                    let alive = true;

                    const reset = () => {
                        bird.y = api.height / 2;
                        bird.vy = 0;
                        pipes.length = 0;
                        spawnTimer = 0;
                        score = 0;
                        alive = true;
                        api.setScore(0);
                        api.setLevel(best);
                        api.setLives('Best ' + best);
                        api.setStatus('Ready');
                    };

                    const flap = () => {
                        if (!alive) {
                            reset();
                            return;
                        }
                        bird.vy = flapVelocity;
                        api.setStatus('Running');
                    };

                    const spawnPipe = () => {
                        const margin = 60;
                        const gapCenter = Math.random() * (api.height - margin * 2 - gapHeight) + gapHeight / 2 + margin;
                        pipes.push({ x: api.width + pipeWidth, gapCenter, passed: false });
                    };

                    const collide = () => {
                        api.gameOver('Bird down! Tap to retry.');
                        alive = false;
                        best = Math.max(best, score);
                        localStorage.setItem('webos.flappy.best', String(best));
                        api.setLevel(best);
                        api.setStatus('Game over');
                    };

                    const step = delta => {
                        if (!alive) return;
                        bird.vy += gravity * delta;
                        bird.y += bird.vy * delta;
                        if (bird.y < 0) bird.y = 0;
                        if (bird.y > api.height) collide();

                        spawnTimer += delta;
                        if (spawnTimer >= spawnInterval) {
                            spawnTimer = 0;
                            spawnPipe();
                        }

                        pipes.forEach(pipe => {
                            pipe.x -= (220 + score * 2) * delta;
                            if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                                pipe.passed = true;
                                score += 1;
                                api.setScore(score);
                                api.log(`Great! Score ${score}`);
                            }
                            const gapTop = pipe.gapCenter - gapHeight / 2;
                            const gapBottom = pipe.gapCenter + gapHeight / 2;
                            if (bird.x + 18 > pipe.x && bird.x - 18 < pipe.x + pipeWidth) {
                                if (bird.y - 18 < gapTop || bird.y + 18 > gapBottom) {
                                    collide();
                                }
                            }
                        });
                        while (pipes.length && pipes[0].x + pipeWidth < -80) pipes.shift();
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#4a90e2';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.fillStyle = '#2ec66d';
                        ctx.fillRect(0, api.height - 40, api.width, 40);
                        ctx.fillStyle = '#8ecbff';
                        ctx.fillRect(0, api.height - 60, api.width, 20);

                        pipes.forEach(pipe => {
                            const gapTop = pipe.gapCenter - gapHeight / 2;
                            const gapBottom = pipe.gapCenter + gapHeight / 2;
                            ctx.fillStyle = '#1d3557';
                            ctx.fillRect(pipe.x, 0, pipeWidth, gapTop);
                            ctx.fillRect(pipe.x, gapBottom, pipeWidth, api.height - gapBottom);
                            ctx.fillStyle = '#457b9d';
                            ctx.fillRect(pipe.x - 4, gapTop - 16, pipeWidth + 8, 16);
                            ctx.fillRect(pipe.x - 4, gapBottom, pipeWidth + 8, 16);
                        });

                        ctx.save();
                        ctx.translate(bird.x, bird.y);
                        ctx.rotate(Math.min(Math.max(bird.vy / 420, -0.5), 0.6));
                        ctx.fillStyle = '#ffdd59';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 20, 16, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.moveTo(14, -4);
                        ctx.lineTo(24, 0);
                        ctx.lineTo(14, 4);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(6, -4, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    };

                    return {
                        init() {
                            api.resetMetrics();
                            reset();
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (delta > 0.05) delta = 0.05;
                            step(delta);
                        },
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event) {
                            if (event.key === ' ' || event.key.toLowerCase() === 'w' || event.key === 'ArrowUp') {
                                flap();
                                return true;
                            }
                            return false;
                        },
                        handlePointer(type, event) {
                            if (type === 'down') flap();
                        }
                    };
                }
            });
        }

        function create2048App() {
            return createCanvasGameApp({
                id: 'game-2048',
                name: '2048 Fusion',
                icon: '🔢',
                hint: 'Combine matching numbers',
                instructions: [
                    'Use the arrow keys (or WASD) to slide tiles.',
                    'Matching tiles merge into their sum. Reach 2048 to win!',
                    'Board fills up when no moves remain — plan ahead.'
                ],
                createGame(api) {
                    const size = 4;
                    const board = Array.from({ length: size }, () => Array(size).fill(0));
                    let score = 0;
                    let best = Number(localStorage.getItem('webos.2048.best') || '0');
                    let won = false;

                    const tileColors = {
                        0: '#1c253e',
                        2: '#42a5f5',
                        4: '#66bb6a',
                        8: '#ffb74d',
                        16: '#ff8a65',
                        32: '#ef5350',
                        64: '#ab47bc',
                        128: '#7e57c2',
                        256: '#5c6bc0',
                        512: '#26c6da',
                        1024: '#26a69a',
                        2048: '#9c27b0'
                    };

                    const reset = () => {
                        for (let r = 0; r < size; r++) board[r].fill(0);
                        score = 0;
                        won = false;
                        spawnTile();
                        spawnTile();
                        api.setScore(0);
                        api.setLevel(best);
                        api.setLives('2048 target');
                        api.setStatus('Ready');
                    };

                    const spawnTile = () => {
                        const empty = [];
                        for (let r = 0; r < size; r++) {
                            for (let c = 0; c < size; c++) if (!board[r][c]) empty.push({ r, c });
                        }
                        if (!empty.length) return;
                        const { r, c } = empty[Math.floor(Math.random() * empty.length)];
                        board[r][c] = Math.random() < 0.9 ? 2 : 4;
                    };

                    const slide = direction => {
                        let moved = false;
                        const traverseRows = direction === 'up' || direction === 'down';
                        const outer = traverseRows ? size : size;
                        const inner = traverseRows ? size : size;

                        for (let outerIndex = 0; outerIndex < outer; outerIndex++) {
                            const line = [];
                            for (let innerIndex = 0; innerIndex < inner; innerIndex++) {
                                const r = traverseRows ? (direction === 'up' ? innerIndex : size - 1 - innerIndex) : outerIndex;
                                const c = traverseRows ? outerIndex : (direction === 'left' ? innerIndex : size - 1 - innerIndex);
                                const value = board[r][c];
                                if (value) line.push({ r, c, value });
                            }
                            if (!line.length) continue;
                            for (let i = 0; i < line.length - 1; i++) {
                                if (line[i].value === line[i + 1].value) {
                                    line[i].value *= 2;
                                    score += line[i].value;
                                    line.splice(i + 1, 1);
                                    if (line[i].value === 2048 && !won) {
                                        won = true;
                                        api.log('2048 tile created! Keep going or press R to restart.');
                                    }
                                }
                            }
                            while (line.length < size) line.push({ value: 0 });
                            for (let innerIndex = 0; innerIndex < inner; innerIndex++) {
                                const r = traverseRows ? (direction === 'up' ? innerIndex : size - 1 - innerIndex) : outerIndex;
                                const c = traverseRows ? outerIndex : (direction === 'left' ? innerIndex : size - 1 - innerIndex);
                                const nextValue = line[innerIndex].value;
                                if (board[r][c] !== nextValue) {
                                    board[r][c] = nextValue;
                                    moved = true;
                                }
                            }
                        }
                        if (moved) {
                            spawnTile();
                            api.setScore(score);
                            if (score > best) {
                                best = score;
                                api.setLevel(best);
                                localStorage.setItem('webos.2048.best', String(best));
                            }
                        }
                        if (!movesAvailable()) {
                            api.gameOver('Board locked — game over! Press R to retry.');
                        }
                    };

                    const movesAvailable = () => {
                        for (let r = 0; r < size; r++) {
                            for (let c = 0; c < size; c++) {
                                if (!board[r][c]) return true;
                                if (c < size - 1 && board[r][c] === board[r][c + 1]) return true;
                                if (r < size - 1 && board[r][c] === board[r + 1][c]) return true;
                            }
                        }
                        return false;
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#0b162f';
                        ctx.fillRect(0, 0, api.width, api.height);
                        const tileSize = Math.min(api.width, api.height) * 0.8 / size;
                        const startX = (api.width - tileSize * size) / 2;
                        const startY = (api.height - tileSize * size) / 2;
                        for (let r = 0; r < size; r++) {
                            for (let c = 0; c < size; c++) {
                                const value = board[r][c];
                                const x = startX + c * tileSize;
                                const y = startY + r * tileSize;
                                ctx.fillStyle = tileColors[value] || '#1c253e';
                                ctx.beginPath();
                                if (ctx.roundRect) ctx.roundRect(x + 6, y + 6, tileSize - 12, tileSize - 12, 12);
                                else {
                                    ctx.moveTo(x + 6, y + 6);
                                    ctx.lineTo(x + tileSize - 6, y + 6);
                                    ctx.lineTo(x + tileSize - 6, y + tileSize - 6);
                                    ctx.lineTo(x + 6, y + tileSize - 6);
                                    ctx.closePath();
                                }
                                ctx.fill();
                                if (value) {
                                    ctx.fillStyle = value <= 4 ? '#11223c' : '#fff';
                                    ctx.font = `${Math.floor(tileSize * 0.4)}px "SF Pro Display", sans-serif`;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(String(value), x + tileSize / 2, y + tileSize / 2);
                                }
                            }
                        }
                    };

                    const directionFromKey = key => {
                        switch (key.toLowerCase()) {
                            case 'arrowup':
                            case 'w':
                                return 'up';
                            case 'arrowdown':
                            case 's':
                                return 'down';
                            case 'arrowleft':
                            case 'a':
                                return 'left';
                            case 'arrowright':
                            case 'd':
                                return 'right';
                            default:
                                return null;
                        }
                    };

                    let swipeStart = null;

                    return {
                        init() {
                            api.resetMetrics();
                            reset();
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update() {},
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event) {
                            if (event.key.toLowerCase() === 'r') {
                                reset();
                                return true;
                            }
                            const direction = directionFromKey(event.key);
                            if (!direction) return false;
                            slide(direction);
                            return true;
                        },
                        handlePointer(type, event) {
                            if (type === 'down') {
                                swipeStart = { x: event.clientX, y: event.clientY };
                            } else if (type === 'up' && swipeStart) {
                                const dx = event.clientX - swipeStart.x;
                                const dy = event.clientY - swipeStart.y;
                                if (Math.hypot(dx, dy) > 24) {
                                    if (Math.abs(dx) > Math.abs(dy)) slide(dx > 0 ? 'right' : 'left');
                                    else slide(dy > 0 ? 'down' : 'up');
                                }
                                swipeStart = null;
                            }
                        }
                    };
                }
            });
        }

        function createSolitaireApp() {
            return {
                id: 'solitaire',
                name: 'Solitaire Desk',
                icon: '🃏',
                hint: 'Drag cards to foundations',
                launch() {
                    const container = utils.createEl('div', 'game-app');
                    const header = utils.createEl('div', 'game-header');
                    const meta = utils.createEl('div', 'game-meta');
                    const title = document.createElement('h2');
                    title.style.margin = '0';
                    title.style.fontSize = '1.4rem';
                    title.textContent = 'Solitaire Desk';
                    const subtitle = document.createElement('span');
                    subtitle.style.color = 'var(--text-muted)';
                    subtitle.style.fontSize = '0.85rem';
                    subtitle.textContent = 'Classic Klondike rules';
                    meta.append(title, subtitle);

                    const controls = utils.createEl('div', 'game-controls');
                    const newGameBtn = utils.createEl('button', '', { text: 'New Deal' });
                    controls.appendChild(newGameBtn);

                    const metricsContainer = utils.createEl('div', 'game-metrics');
                    const metrics = {
                        score: createGameMetric('Score', '0'),
                        moves: createGameMetric('Moves', '0'),
                        status: createGameMetric('Status', 'Ready'),
                        foundations: createGameMetric('Foundations', '0 / 4')
                    };
                    Object.values(metrics).forEach(metric => metricsContainer.appendChild(metric.wrapper));
                    header.append(meta, controls, metricsContainer);

                    const playfield = utils.createEl('div', 'game-playfield');
                    playfield.classList.add('single-column');
                    const layout = utils.createEl('div');
                    layout.style.display = 'flex';
                    layout.style.flexDirection = 'column';
                    layout.style.gap = '18px';

                    const topRow = utils.createEl('div', 'solitaire-top');
                    const stockHolder = utils.createEl('div');
                    stockHolder.innerHTML = '<div class="solitaire-pile-label">Stock</div>';
                    const stockPile = utils.createEl('div', 'solitaire-stock');
                    stockHolder.appendChild(stockPile);

                    const wasteHolder = utils.createEl('div');
                    wasteHolder.innerHTML = '<div class="solitaire-pile-label">Waste</div>';
                    const wastePile = utils.createEl('div', 'solitaire-waste');
                    wasteHolder.appendChild(wastePile);

                    const foundationHolder = utils.createEl('div');
                    foundationHolder.innerHTML = '<div class="solitaire-pile-label">Foundations</div>';
                    const foundationsWrap = utils.createEl('div', 'solitaire-foundations');
                    ['♠', '♥', '♦', '♣'].forEach(suit => {
                        const slot = utils.createEl('div', 'solitaire-foundation-slot');
                        slot.dataset.suit = suit;
                        slot.dataset.pile = `foundation-${suit}`;
                        foundationsWrap.appendChild(slot);
                    });
                    foundationHolder.appendChild(foundationsWrap);

                    topRow.append(stockHolder, wasteHolder, foundationHolder);

                    const tableauHolder = utils.createEl('div');
                    tableauHolder.innerHTML = '<div class="solitaire-pile-label">Tableau</div>';
                    const tableauGrid = utils.createEl('div', 'solitaire-table');
                    tableauHolder.appendChild(tableauGrid);

                    layout.append(topRow, tableauHolder);
                    playfield.appendChild(layout);
                    container.append(header, playfield);

                    const suits = ['♠', '♥', '♦', '♣'];
                    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                    const valueMap = Object.fromEntries(ranks.map((rank, index) => [rank, index + 1]));
                    const isRed = suit => suit === '♥' || suit === '♦';

                    const tableau = Array.from({ length: 7 }, () => []);
                    const foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                    let stock = [];
                    let waste = [];
                    let moves = 0;
                    let score = 0;
                    let dragState = null;

                    const updateMetrics = () => {
                        metrics.score.value.textContent = String(score);
                        metrics.moves.value.textContent = String(moves);
                        const foundationCount = suits.filter(suit => foundations[suit].length === 13).length;
                        metrics.foundations.value.textContent = `${foundationCount} / 4`;
                        if (foundationCount === 4) metrics.status.value.textContent = 'Completed';
                    };

                    const shuffleDeck = () => {
                        const deck = [];
                        suits.forEach(suit => {
                            ranks.forEach(rank => {
                                deck.push({ id: `${suit}${rank}${Math.random()}`, suit, rank, value: valueMap[rank], faceUp: false });
                            });
                        });
                        for (let i = deck.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [deck[i], deck[j]] = [deck[j], deck[i]];
                        }
                        return deck;
                    };

                    const deal = () => {
                        tableau.forEach(column => column.splice(0));
                        waste = [];
                        suits.forEach(suit => foundations[suit].splice(0));
                        const deck = shuffleDeck();
                        for (let column = 0; column < 7; column++) {
                            for (let row = 0; row <= column; row++) {
                                const card = deck.pop();
                                card.faceUp = row === column;
                                tableau[column].push(card);
                            }
                        }
                        stock = deck;
                        stock.forEach(card => (card.faceUp = false));
                        moves = 0;
                        score = 0;
                        metrics.status.value.textContent = 'Ready';
                        updateMetrics();
                        renderAll();
                    };

                    const renderStock = () => {
                        stockPile.innerHTML = '';
                        if (stock.length) {
                            const back = createCardBack();
                            stockPile.appendChild(back);
                        } else {
                            stockPile.appendChild(createEmptyIndicator());
                        }
                    };

                    const renderWaste = () => {
                        wastePile.innerHTML = '';
                        const topThree = waste.slice(-3);
                        topThree.forEach((card, index) => {
                            const cardEl = createCardElement(card);
                            cardEl.style.left = `${index * 16}px`;
                            cardEl.dataset.origin = 'waste';
                            if (index === topThree.length - 1) attachCardDrag(cardEl, { type: 'waste', index: waste.length - 1 });
                            wastePile.appendChild(cardEl);
                        });
                    };

                    const renderFoundations = () => {
                        foundationsWrap.querySelectorAll('.solitaire-foundation-slot').forEach(slot => {
                            const suit = slot.dataset.suit;
                            slot.innerHTML = '';
                            const pile = foundations[suit];
                            if (!pile.length) return;
                            const card = pile[pile.length - 1];
                            const cardEl = createCardElement(card);
                            cardEl.dataset.origin = `foundation-${suit}`;
                            cardEl.style.left = '8px';
                            cardEl.style.top = '8px';
                            attachCardDrag(cardEl, { type: 'foundation', suit });
                            slot.appendChild(cardEl);
                        });
                    };

                    const renderTableau = () => {
                        tableauGrid.innerHTML = '';
                        tableau.forEach((column, columnIndex) => {
                            const columnEl = utils.createEl('div', 'solitaire-column');
                            columnEl.dataset.column = String(columnIndex);
                            column.forEach((card, rowIndex) => {
                                const cardEl = createCardElement(card);
                                cardEl.style.top = `${rowIndex * 28}px`;
                                cardEl.dataset.column = String(columnIndex);
                                cardEl.dataset.row = String(rowIndex);
                                if (card.faceUp) attachCardDrag(cardEl, { type: 'tableau', column: columnIndex, row: rowIndex });
                                columnEl.appendChild(cardEl);
                            });
                            if (!column.length) {
                                const placeholder = createEmptyIndicator();
                                attachPileDrop(columnEl, 'tableau', columnIndex);
                                columnEl.appendChild(placeholder);
                            } else {
                                attachPileDrop(columnEl, 'tableau', columnIndex);
                            }
                            tableauGrid.appendChild(columnEl);
                        });
                    };

                    const renderAll = () => {
                        renderStock();
                        renderWaste();
                        renderFoundations();
                        renderTableau();
                        updateMetrics();
                    };

                    const createEmptyIndicator = () => {
                        const indicator = document.createElement('div');
                        indicator.className = 'solitaire-drop-indicator';
                        return indicator;
                    };

                    const createCardBack = () => {
                        const card = utils.createEl('div', 'solitaire-card face-down');
                        card.textContent = '★';
                        return card;
                    };

                    const createCardElement = card => {
                        const el = utils.createEl('div', 'solitaire-card');
                        if (!card.faceUp) {
                            el.classList.add('face-down');
                            el.textContent = '★';
                            return el;
                        }
                        const top = document.createElement('div');
                        top.textContent = card.rank;
                        const middle = document.createElement('div');
                        middle.textContent = card.suit;
                        middle.style.fontSize = '1.4rem';
                        const bottom = document.createElement('div');
                        bottom.textContent = card.rank;
                        bottom.style.alignSelf = 'flex-end';
                        if (isRed(card.suit)) {
                            el.style.color = '#ff6f61';
                        } else {
                            el.style.color = '#e0e7ff';
                        }
                        el.append(top, middle, bottom);
                        return el;
                    };

                    const attachPileDrop = (element, type, columnIndex) => {
                        element.addEventListener('pointerup', event => {
                            if (!dragState) return;
                            if (type === 'tableau') completeDrop({ type: 'tableau', column: columnIndex }, event);
                        });
                    };

                    const attachCardDrag = (element, origin) => {
                        element.addEventListener('pointerdown', event => {
                            if (event.button !== 0) return;
                            if (dragState) return;
                            const card = getCardFromOrigin(origin);
                            if (!card?.faceUp) return;
                            event.preventDefault();
                            startDrag(event, origin);
                        });
                        element.addEventListener('dblclick', () => {
                            const card = getCardFromOrigin(origin);
                            if (!card?.faceUp) return;
                            autoMoveToFoundation(origin);
                        });
                    };

                    const getCardFromOrigin = origin => {
                        switch (origin.type) {
                            case 'tableau':
                                return tableau[origin.column]?.[origin.row] || null;
                            case 'waste':
                                return waste[origin.index] || null;
                            case 'foundation':
                                const stack = foundations[origin.suit];
                                return stack[stack.length - 1] || null;
                            default:
                                return null;
                        }
                    };

                    const startDrag = (event, origin) => {
                        const sourceCards = extractSelection(origin);
                        if (!sourceCards.length) return;
                        const preview = buildDragPreview(sourceCards);
                        const rect = event.currentTarget.getBoundingClientRect();
                        dragState = {
                            origin,
                            cards: sourceCards,
                            preview,
                            offsetX: event.clientX - rect.left,
                            offsetY: event.clientY - rect.top,
                            pointerId: event.pointerId
                        };
                        document.body.appendChild(preview);
                        movePreview(event.clientX, event.clientY);
                        markSourceCards(origin, true);
                        window.addEventListener('pointermove', handleDragMove);
                        window.addEventListener('pointerup', onDragEnd);
                        window.addEventListener('pointercancel', cancelDrag);
                    };

                    const extractSelection = origin => {
                        switch (origin.type) {
                            case 'tableau':
                                return tableau[origin.column].slice(origin.row);
                            case 'waste':
                                return [waste[origin.index]].filter(Boolean);
                            case 'foundation':
                                return [foundations[origin.suit][foundations[origin.suit].length - 1]].filter(Boolean);
                            default:
                                return [];
                        }
                    };

                    const markSourceCards = (origin, dragging) => {
                        let cards = [];
                        switch (origin.type) {
                            case 'tableau':
                                cards = tableauGrid.querySelectorAll(`.solitaire-card[data-column="${origin.column}"]`);
                                break;
                            case 'waste':
                                cards = wastePile.querySelectorAll('.solitaire-card');
                                break;
                            case 'foundation':
                                cards = foundationsWrap.querySelectorAll(`[data-suit="${origin.suit}"] .solitaire-card`);
                                break;
                        }
                        cards.forEach(cardEl => {
                            if (dragging) cardEl.classList.add('drag-source');
                            else cardEl.classList.remove('drag-source');
                        });
                    };

                    const buildDragPreview = cards => {
                        const wrapper = document.createElement('div');
                        wrapper.style.position = 'fixed';
                        wrapper.style.pointerEvents = 'none';
                        wrapper.style.zIndex = '4000';
                        cards.forEach((card, index) => {
                            const cardEl = createCardElement(card);
                            cardEl.style.position = 'absolute';
                            cardEl.style.top = `${index * 28}px`;
                            wrapper.appendChild(cardEl);
                        });
                        return wrapper;
                    };

                    const movePreview = (clientX, clientY) => {
                        if (!dragState) return;
                        dragState.preview.style.transform = `translate(${clientX - dragState.offsetX}px, ${clientY - dragState.offsetY}px)`;
                    };

                    const handleDragMove = event => {
                        if (!dragState || event.pointerId !== dragState.pointerId) return;
                        movePreview(event.clientX, event.clientY);
                    };

                    const onDragEnd = event => {
                        if (!dragState || event.pointerId !== dragState.pointerId) return;
                        completeDrop(detectDropTarget(event), event);
                    };

                    const cancelDrag = () => {
                        if (!dragState) return;
                        cleanupDrag();
                        renderAll();
                    };

                    const detectDropTarget = event => {
                        const element = document.elementFromPoint(event.clientX, event.clientY);
                        if (!element) return null;
                        const foundationSlot = element.closest('.solitaire-foundation-slot');
                        if (foundationSlot) return { type: 'foundation', suit: foundationSlot.dataset.suit };
                        const columnEl = element.closest('.solitaire-column');
                        if (columnEl) return { type: 'tableau', column: Number(columnEl.dataset.column) };
                        return null;
                    };

                    const completeDrop = (target, event) => {
                        if (!dragState) return;
                        if (!target) {
                            cancelDrag();
                            return;
                        }
                        const { cards, origin } = dragState;
                        if (target.type === 'foundation') {
                            if (cards.length !== 1) {
                                cancelDrag();
                                return;
                            }
                            const card = cards[0];
                            if (!canMoveToFoundation(card, target.suit)) {
                                cancelDrag();
                                return;
                            }
                            removeFromOrigin(origin);
                            foundations[target.suit].push(card);
                            score += 10;
                            metrics.status.value.textContent = `Placed ${card.rank}${card.suit} to foundation ${target.suit}`;
                            moves += 1;
                        } else if (target.type === 'tableau') {
                            const column = tableau[target.column];
                            const targetCard = column[column.length - 1];
                            const firstCard = cards[0];
                            if (!canMoveToTableau(firstCard, targetCard)) {
                                cancelDrag();
                                return;
                            }
                            removeFromOrigin(origin);
                            column.push(...cards);
                            moves += 1;
                            metrics.status.value.textContent = `Moved ${cards.length} card${cards.length > 1 ? 's' : ''}`;
                        }
                        cleanupDrag();
                        postMoveCleanup();
                        renderAll();
                        checkVictory();
                    };

                    const cleanupDrag = () => {
                        if (!dragState) return;
                        markSourceCards(dragState.origin, false);
                        dragState.preview.remove();
                        window.removeEventListener('pointermove', handleDragMove);
                        window.removeEventListener('pointerup', onDragEnd);
                        window.removeEventListener('pointercancel', cancelDrag);
                        dragState = null;
                    };

                    const removeFromOrigin = origin => {
                        switch (origin.type) {
                            case 'tableau':
                                tableau[origin.column] = tableau[origin.column].slice(0, origin.row);
                                break;
                            case 'waste':
                                waste.pop();
                                break;
                            case 'foundation':
                                foundations[origin.suit].pop();
                                break;
                        }
                    };

                    const postMoveCleanup = () => {
                        tableau.forEach(column => {
                            if (column.length) {
                                const lastCard = column[column.length - 1];
                                if (!lastCard.faceUp) {
                                    lastCard.faceUp = true;
                                    score += 5;
                                    metrics.status.value.textContent = `Flipped ${lastCard.rank}${lastCard.suit}`;
                                }
                            }
                        });
                        updateMetrics();
                    };

                    const canMoveToFoundation = (card, suit) => {
                        if (card.suit !== suit) return false;
                        const pile = foundations[suit];
                        if (!pile.length) return card.value === 1;
                        return pile[pile.length - 1].value === card.value - 1;
                    };

                    const canMoveToTableau = (card, targetCard) => {
                        if (!targetCard) return card.value === 13; // King
                        const differentColor = isRed(card.suit) !== isRed(targetCard.suit);
                        return differentColor && card.value === targetCard.value - 1;
                    };

                    const autoMoveToFoundation = origin => {
                        const card = getCardFromOrigin(origin);
                        if (!card) return;
                        const pile = foundations[card.suit];
                        if (!canMoveToFoundation(card, card.suit)) return;
                        removeFromOrigin(origin);
                        pile.push(card);
                        score += 10;
                        moves += 1;
                        postMoveCleanup();
                        renderAll();
                        checkVictory();
                    };

                    const checkVictory = () => {
                        const complete = suits.every(suit => foundations[suit].length === 13);
                        if (complete) {
                            metrics.status.value.textContent = 'Victory!';
                        }
                    };

                    stockPile.addEventListener('click', () => {
                        if (dragState) return;
                        if (stock.length) {
                            const card = stock.pop();
                            card.faceUp = true;
                            waste.push(card);
                            moves += 1;
                            score = Math.max(0, score - 1);
                            metrics.status.value.textContent = 'Drew from stock';
                        } else {
                            while (waste.length) {
                                const card = waste.pop();
                                card.faceUp = false;
                                stock.push(card);
                            }
                            metrics.status.value.textContent = 'Recycled waste';
                        }
                        renderAll();
                    });

                    newGameBtn.addEventListener('click', () => {
                        deal();
                    });

                    deal();

                    return {
                        element: container,
                        width: '1040px',
                        height: '720px'
                    };

                }
            };
        }

        function createPacManApp() {
            return createCanvasGameApp({
                id: 'pac-man',
                name: 'Pac Maze',
                icon: '😋',
                hint: 'Eat pellets, dodge ghosts',
                instructions: [
                    'Use the arrow keys to guide Pac through the maze.',
                    'Eat all pellets to clear the level. Power pellets turn ghosts blue.',
                    'Colliding with a ghost costs a life unless they are frightened.'
                ],
                legend: [
                    { color: '#ffeb3b', label: 'Pac' },
                    { color: '#9c27b0', label: 'Ghosts' },
                    { color: '#ffffff', label: 'Pellet' }
                ],
                createGame(api) {
                    const layout = [
                        '#################',
                        '#.......#.......#',
                        '#.###.#.#.#.###.#',
                        '#o#.#.#.#.#.#.#o#',
                        '#.#.#.###.#.#.#.#',
                        '#...............#',
                        '#.###.#.###.#.###',
                        '#.....#...#.....#',
                        '###.#.#####.#.###',
                        '#...#...#...#...#',
                        '#.#####.#.#####.#',
                        '#...............#',
                        '#################'
                    ];
                    const rows = layout.length;
                    const cols = layout[0].length;
                    const tileSize = Math.floor(Math.min(api.width / cols, api.height / rows));
                    const offsetX = Math.floor((api.width - tileSize * cols) / 2);
                    const offsetY = Math.floor((api.height - tileSize * rows) / 2);

                    const pellets = new Set();
                    const powerPellets = new Set();
                    layout.forEach((row, r) => {
                        for (let c = 0; c < cols; c++) {
                            const tile = row[c];
                            if (tile === '.') pellets.add(`${r},${c}`);
                            if (tile === 'o') powerPellets.add(`${r},${c}`);
                        }
                    });

                    const dirs = {
                        up: { dr: -1, dc: 0 },
                        down: { dr: 1, dc: 0 },
                        left: { dr: 0, dc: -1 },
                        right: { dr: 0, dc: 1 }
                    };

                    const makeEntity = (row, col, dir = dirs.left) => ({
                        row,
                        col,
                        prevRow: row,
                        prevCol: col,
                        dir,
                        next: dir,
                        progress: 0
                    });

                    const pac = makeEntity(5, 8, dirs.left);
                    const ghosts = [
                        { ...makeEntity(5, 7, dirs.right), color: '#ff4081' },
                        { ...makeEntity(5, 9, dirs.left), color: '#7c4dff' },
                        { ...makeEntity(6, 8, dirs.up), color: '#4caf50' }
                    ];

                    const speedBase = 0.12;
                    let moveTimer = 0;
                    let ghostTimer = 0;
                    let lives = 3;
                    let score = 0;
                    let level = 1;
                    let frightenedTimer = 0;
                    let gameOver = false;

                    const isWall = (r, c) => {
                        if (r < 0) r = rows - 1;
                        if (r >= rows) r = 0;
                        if (c < 0) c = cols - 1;
                        if (c >= cols) c = 0;
                        return layout[r][c] === '#';
                    };

                    const canMove = (entity, dir) => {
                        if (!dir) return false;
                        let r = entity.row + dir.dr;
                        let c = entity.col + dir.dc;
                        if (r < 0) r = rows - 1;
                        if (r >= rows) r = 0;
                        if (c < 0) c = cols - 1;
                        if (c >= cols) c = 0;
                        return !isWall(r, c);
                    };

                    const stepEntity = (entity, delta) => {
                        const interval = Math.max(0.07, speedBase - (level - 1) * 0.005);
                        entity.progress += delta / interval;
                        while (entity.progress >= 1) {
                            entity.progress -= 1;
                            if (entity.next && canMove(entity, entity.next)) entity.dir = entity.next;
                            if (!canMove(entity, entity.dir)) {
                                entity.dir = { dr: 0, dc: 0 };
                                continue;
                            }
                            entity.prevRow = entity.row;
                            entity.prevCol = entity.col;
                            entity.row = (entity.row + entity.dir.dr + rows) % rows;
                            entity.col = (entity.col + entity.dir.dc + cols) % cols;
                            onEntityStep(entity);
                        }
                    };

                    const onEntityStep = entity => {
                        if (entity === pac) {
                            const key = `${entity.row},${entity.col}`;
                            if (powerPellets.has(key)) {
                                powerPellets.delete(key);
                                frightenedTimer = 8;
                                score += 50;
                                api.setStatus('Power mode!');
                                api.log('Ghosts are frightened!');
                            }
                            if (pellets.has(key)) {
                                pellets.delete(key);
                                score += 10;
                                api.addScore(10);
                            }
                            if (!pellets.size && !powerPellets.size) {
                                level += 1;
                                api.log(`Level ${level}`);
                                resetBoard(true);
                            }
                        }
                    };

                    const ghostDirections = entity => {
                        const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
                        const currentKey = Object.keys(dirs).find(key => dirs[key] === entity.dir);
                        return Object.values(dirs).filter(dir => {
                            const nextRow = (entity.row + dir.dr + rows) % rows;
                            const nextCol = (entity.col + dir.dc + cols) % cols;
                            if (isWall(nextRow, nextCol)) return false;
                            const dirKey = Object.keys(dirs).find(key => dirs[key] === dir);
                            if (dirKey && currentKey && opposites[currentKey] === dirKey && (entity.dir.dr !== 0 || entity.dir.dc !== 0)) return false;
                            return true;
                        });
                    };

                    const updateGhosts = delta => {
                        const interval = Math.max(0.08, speedBase - (level - 1) * 0.004);
                        ghostTimer += delta;
                        if (ghostTimer < interval) return;
                        ghostTimer = 0;
                        ghosts.forEach(ghost => {
                            const possible = ghostDirections(ghost);
                            if (!possible.length) return;
                            if (frightenedTimer > 0) {
                                ghost.dir = possible[Math.floor(Math.random() * possible.length)];
                            } else {
                                const best = possible.reduce((bestDir, dir) => {
                                    const nextRow = (ghost.row + dir.dr + rows) % rows;
                                    const nextCol = (ghost.col + dir.dc + cols) % cols;
                                    const dist = Math.abs(nextRow - pac.row) + Math.abs(nextCol - pac.col);
                                    if (!bestDir || dist < bestDir.dist) return { dir, dist };
                                    return bestDir;
                                }, null);
                                if (best && Math.random() < 0.65) ghost.dir = best.dir; else ghost.dir = possible[Math.floor(Math.random() * possible.length)];
                            }
                            ghost.prevRow = ghost.row;
                            ghost.prevCol = ghost.col;
                            ghost.row = (ghost.row + ghost.dir.dr + rows) % rows;
                            ghost.col = (ghost.col + ghost.dir.dc + cols) % cols;
                        });
                    };

                    const resetPositions = () => {
                        pac.row = 5;
                        pac.col = 8;
                        pac.prevRow = pac.row;
                        pac.prevCol = pac.col;
                        pac.dir = dirs.left;
                        pac.next = dirs.left;
                        pac.progress = 0;
                        ghosts[0].row = 5; ghosts[0].col = 7; ghosts[0].dir = dirs.right;
                        ghosts[1].row = 5; ghosts[1].col = 9; ghosts[1].dir = dirs.left;
                        ghosts[2].row = 6; ghosts[2].col = 8; ghosts[2].dir = dirs.up;
                        ghosts.forEach(g => { g.prevRow = g.row; g.prevCol = g.col; g.progress = 0; });
                    };

                    const resetBoard = (keepScore = false) => {
                        pellets.clear();
                        powerPellets.clear();
                        layout.forEach((row, r) => {
                            for (let c = 0; c < cols; c++) {
                                const tile = row[c];
                                if (tile === '.') pellets.add(`${r},${c}`);
                                if (tile === 'o') powerPellets.add(`${r},${c}`);
                            }
                        });
                        if (!keepScore) score = 0;
                        frightenedTimer = 0;
                        resetPositions();
                        api.setScore(score);
                        api.setLevel(level);
                        api.setLives(`Lives ${lives}`);
                    };

                    const checkCollisions = () => {
                        ghosts.forEach(ghost => {
                            if (ghost.row === pac.row && ghost.col === pac.col) {
                                if (frightenedTimer > 0) {
                                    ghost.row = 5;
                                    ghost.col = 8;
                                    ghost.dir = dirs.up;
                                    score += 200;
                                    api.addScore(200);
                                    api.log('Ghost captured!');
                                } else {
                                    loseLife();
                                }
                            }
                        });
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${lives}`);
                        api.log('Ouch!');
                        if (lives <= 0) {
                            api.gameOver('All lives lost.');
                            gameOver = true;
                        } else {
                            resetPositions();
                        }
                    };

                    const draw = ctx => {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(0, 0, api.width, api.height);
                        ctx.save();
                        ctx.translate(offsetX, offsetY);
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                if (layout[r][c] === '#') {
                                    ctx.fillStyle = '#1e2b57';
                                    ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);
                                }
                            }
                        }
                        ctx.fillStyle = '#fff';
                        pellets.forEach(key => {
                            const [r, c] = key.split(',').map(Number);
                            ctx.beginPath();
                            ctx.arc(c * tileSize + tileSize / 2, r * tileSize + tileSize / 2, tileSize * 0.08, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.fillStyle = '#ff6f00';
                        powerPellets.forEach(key => {
                            const [r, c] = key.split(',').map(Number);
                            ctx.beginPath();
                            ctx.arc(c * tileSize + tileSize / 2, r * tileSize + tileSize / 2, tileSize * 0.18, 0, Math.PI * 2);
                            ctx.fill();
                        });

                        const drawEntity = (entity, color, mouth = true) => {
                            const interpRow = entity.prevRow + (entity.row - entity.prevRow) * entity.progress;
                            const interpCol = entity.prevCol + (entity.col - entity.prevCol) * entity.progress;
                            ctx.save();
                            ctx.translate(interpCol * tileSize + tileSize / 2, interpRow * tileSize + tileSize / 2);
                            ctx.fillStyle = color;
                            if (mouth) {
                                const angle = entity.dir === dirs.left ? Math.PI
                                    : entity.dir === dirs.right ? 0
                                    : entity.dir === dirs.up ? -Math.PI / 2
                                    : Math.PI / 2;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.arc(0, 0, tileSize * 0.45, angle + 0.3, angle - 0.3, true);
                                ctx.closePath();
                                ctx.fill();
                            } else {
                                ctx.beginPath();
                                ctx.arc(0, 0, tileSize * 0.42, 0, Math.PI * 2);
                                ctx.fill();
                                if (frightenedTimer > 0) {
                                    ctx.fillStyle = '#fff';
                                    ctx.beginPath();
                                    ctx.arc(-tileSize * 0.14, -tileSize * 0.1, tileSize * 0.1, 0, Math.PI * 2);
                                    ctx.arc(tileSize * 0.14, -tileSize * 0.1, tileSize * 0.1, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            ctx.restore();
                        };

                        drawEntity(pac, '#ffeb3b', true);
                        ghosts.forEach(ghost => {
                            const color = frightenedTimer > 0 ? '#42a5f5' : ghost.color;
                            drawEntity(ghost, color, false);
                        });

                        ctx.restore();
                    };

                    const update = delta => {
                        if (gameOver) return;
                        moveTimer += delta;
                        frightenedTimer = Math.max(0, frightenedTimer - delta);
                        const interval = Math.max(0.07, speedBase - (level - 1) * 0.005);
                        if (moveTimer >= interval) {
                            moveTimer -= interval;
                            stepEntity(pac, interval);
                            updateGhosts(interval);
                            checkCollisions();
                            api.setScore(score);
                        }
                    };

                    resetBoard();

                    return {
                        init() {
                            api.resetMetrics();
                            api.setScore(score);
                            api.setLevel(level);
                            api.setLives(`Lives ${lives}`);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            update(delta);
                        },
                        render(ctx) {
                            draw(ctx);
                        },
                        handleKeyDown(event) {
                            const dir = (() => {
                                switch (event.key.toLowerCase()) {
                                    case 'arrowup':
                                    case 'w':
                                        return dirs.up;
                                    case 'arrowdown':
                                    case 's':
                                        return dirs.down;
                                    case 'arrowleft':
                                    case 'a':
                                        return dirs.left;
                                    case 'arrowright':
                                    case 'd':
                                        return dirs.right;
                                    default:
                                        return null;
                                }
                            })();
                            if (!dir) return false;
                            pac.next = dir;
                            return true;
                        }
                    };
                }
            });
        }

        function createSpaceInvadersApp() {
            return createCanvasGameApp({
                id: 'space-invaders',
                name: 'Space Invaders',
                icon: '👾',
                hint: 'Defend Earth against alien waves',
                instructions: [
                    'Move with ← and →, fire with Space.',
                    'Eliminate all invaders before they reach the ground.',
                    'Dodge incoming shots and survive as long as possible.'
                ],
                legend: [
                    { color: '#8bc34a', label: 'Invaders' },
                    { color: '#ffeb3b', label: 'Player' }
                ],
                createGame(api) {
                    const player = { x: api.width / 2, y: api.height - 80, width: 48, height: 20, cooldown: 0 };
                    const bullets = [];
                    const enemyBullets = [];
                    let invaders = [];
                    let direction = 1;
                    let stepTimer = 0;
                    let stepInterval = 0.9;
                    let lives = 3;
                    let level = 1;
                    let score = 0;
                    const keys = { left: false, right: false };
                    let active = true;

                    const spawnInvaders = () => {
                        invaders = [];
                        const rows = 4 + Math.min(3, level - 1);
                        const cols = 8;
                        for (let row = 0; row < rows; row++) {
                            for (let col = 0; col < cols; col++) {
                                invaders.push({ x: 120 + col * 70, y: 80 + row * 52, alive: true, row, col });
                            }
                        }
                        direction = 1;
                        stepInterval = Math.max(0.3, 0.9 - level * 0.08);
                        api.setLevel(level);
                    };

                    const firePlayer = () => {
                        if (player.cooldown > 0) return;
                        bullets.push({ x: player.x, y: player.y - 20, speed: 520 });
                        player.cooldown = 0.25;
                    };

                    const fireEnemy = () => {
                        const alive = invaders.filter(invader => invader.alive);
                        if (!alive.length) return;
                        const shooters = new Map();
                        alive.forEach(invader => {
                            const existing = shooters.get(invader.col);
                            if (!existing || invader.row > existing.row) shooters.set(invader.col, invader);
                        });
                        const candidates = Array.from(shooters.values());
                        if (!candidates.length) return;
                        const shooter = candidates[Math.floor(Math.random() * candidates.length)];
                        enemyBullets.push({ x: shooter.x, y: shooter.y + 20, speed: 260 + level * 20 });
                    };

                    const updateBullets = delta => {
                        bullets.forEach(bullet => bullet.y -= bullet.speed * delta);
                        enemyBullets.forEach(bullet => bullet.y += bullet.speed * delta);
                        for (let i = bullets.length - 1; i >= 0; i--) {
                            const bullet = bullets[i];
                            if (bullet.y < -20) bullets.splice(i, 1);
                            else {
                                const hit = invaders.find(invader => invader.alive && Math.abs(invader.x - bullet.x) < 26 && Math.abs(invader.y - bullet.y) < 24);
                                if (hit) {
                                    hit.alive = false;
                                    bullets.splice(i, 1);
                                    score += 50;
                                    api.addScore(50);
                                }
                            }
                        }
                        for (let i = enemyBullets.length - 1; i >= 0; i--) {
                            const bullet = enemyBullets[i];
                            if (bullet.y > api.height + 40) enemyBullets.splice(i, 1);
                            else if (Math.abs(bullet.x - player.x) < player.width / 2 && bullet.y > player.y - player.height) {
                                enemyBullets.splice(i, 1);
                                loseLife();
                            }
                        }
                    };

                    const moveInvaders = () => {
                        const alive = invaders.filter(invader => invader.alive);
                        if (!alive.length) {
                            level += 1;
                            api.log(`Level ${level}`);
                            spawnInvaders();
                            return;
                        }
                        let shouldDrop = false;
                        alive.forEach(invader => {
                            invader.x += direction * 18;
                            if (invader.x < 60 || invader.x > api.width - 60) shouldDrop = true;
                        });
                        if (shouldDrop) {
                            direction *= -1;
                            alive.forEach(invader => {
                                invader.y += 28;
                                if (invader.y >= player.y - 40) loseLife();
                            });
                        }
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${Math.max(0, lives)}`);
                        if (lives < 0) {
                            api.gameOver('Invaders conquered Earth.');
                            lives = 0;
                            active = false;
                        } else {
                            enemyBullets.length = 0;
                            bullets.length = 0;
                            player.x = api.width / 2;
                        }
                    };

                    spawnInvaders();

                    return {
                        init() {
                            api.resetMetrics();
                            lives = 3;
                            level = 1;
                            score = 0;
                            active = true;
                            spawnInvaders();
                            api.setScore(0);
                            api.setLevel(level);
                            api.setLives(`Lives ${lives}`);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!active) return;
                            player.cooldown = Math.max(0, player.cooldown - delta);
                            const moveSpeed = 360;
                            if (keys.left) player.x -= moveSpeed * delta;
                            if (keys.right) player.x += moveSpeed * delta;
                            player.x = Math.max(60, Math.min(api.width - 60, player.x));
                            stepTimer += delta;
                            if (stepTimer >= stepInterval) {
                                stepTimer = 0;
                                moveInvaders();
                                if (Math.random() < 0.55) fireEnemy();
                            }
                            updateBullets(delta);
                        },
                        render(ctx) {
                            ctx.fillStyle = '#020515';
                            ctx.fillRect(0, 0, api.width, api.height);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(player.x - player.width / 2, player.y + player.height);
                            ctx.lineTo(player.x + player.width / 2, player.y + player.height);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillStyle = '#8bc34a';
                            invaders.forEach(invader => {
                                if (!invader.alive) return;
                                ctx.fillRect(invader.x - 20, invader.y - 16, 40, 20);
                            });
                            ctx.fillStyle = '#fff';
                            bullets.forEach(bullet => ctx.fillRect(bullet.x - 3, bullet.y - 12, 6, 12));
                            ctx.fillStyle = '#ff5252';
                            enemyBullets.forEach(bullet => ctx.fillRect(bullet.x - 2, bullet.y, 4, 12));
                        },
                        handleKeyDown(event) {
                            switch (event.key) {
                                case 'ArrowLeft':
                                case 'a':
                                    keys.left = true;
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    keys.right = true;
                                    return true;
                                case ' ': {
                                    firePlayer();
                                    return true;
                                }
                                default:
                                    return false;
                            }
                        },
                        handleKeyUp(event) {
                            switch (event.key) {
                                case 'ArrowLeft':
                                case 'a':
                                    keys.left = false;
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    keys.right = false;
                                    return true;
                                default:
                                    return false;
                            }
                        }
                    };
                }
            });
        }

        function createGalagaApp() {
            return createCanvasGameApp({
                id: 'galaga',
                name: 'Galaga Squadron',
                icon: '🚀',
                hint: 'Dogfight against diving enemies',
                instructions: [
                    'Use ← and → to move your starfighter and Space to shoot.',
                    'Enemies break formation and dive — dodge and counter.',
                    'Clear waves to escalate the challenge.'
                ],
                createGame(api) {
                    const player = { x: api.width / 2, y: api.height - 90, width: 36, height: 26, cooldown: 0 };
                    const bullets = [];
                    const enemyBullets = [];
                    const enemies = [];
                    let lives = 3;
                    let level = 1;
                    let score = 0;
                    let active = true;
                    const keys = { left: false, right: false };

                    const spawnFleet = () => {
                        enemies.length = 0;
                        const rows = 3 + Math.min(3, level - 1);
                        const cols = 6;
                        for (let row = 0; row < rows; row++) {
                            for (let col = 0; col < cols; col++) {
                                enemies.push({
                                    baseX: api.width / 2 + (col - cols / 2) * 80,
                                    baseY: 120 + row * 60,
                                    phase: Math.random() * Math.PI * 2,
                                    state: 'formation',
                                    x: 0,
                                    y: 0,
                                    diveTimer: 3 + Math.random() * 4,
                                    color: row === 0 ? '#ff5722' : row === 1 ? '#ffc107' : '#4caf50'
                                });
                            }
                        }
                        enemies.forEach(enemy => {
                            enemy.x = enemy.baseX;
                            enemy.y = enemy.baseY;
                        });
                        api.setLevel(level);
                    };

                    const firePlayer = () => {
                        if (player.cooldown > 0 || !active) return;
                        bullets.push({ x: player.x, y: player.y - 20, speed: 520 });
                        player.cooldown = 0.2;
                    };

                    const fireEnemy = enemy => {
                        enemyBullets.push({ x: enemy.x, y: enemy.y + 12, speed: 320 + level * 15 });
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${Math.max(0, lives)}`);
                        enemyBullets.length = 0;
                        bullets.length = 0;
                        player.x = api.width / 2;
                        if (lives < 0) {
                            active = false;
                            api.gameOver('Squadron lost in deep space.');
                        }
                    };

                    const updateBullets = delta => {
                        bullets.forEach(bullet => bullet.y -= bullet.speed * delta);
                        for (let i = bullets.length - 1; i >= 0; i--) {
                            const bullet = bullets[i];
                            if (bullet.y < -20) {
                                bullets.splice(i, 1);
                                continue;
                            }
                            const hit = enemies.find(enemy => enemy.state !== 'die' && Math.abs(enemy.x - bullet.x) < 24 && Math.abs(enemy.y - bullet.y) < 24);
                            if (hit) {
                                hit.state = 'die';
                                bullets.splice(i, 1);
                                score += 75;
                                api.addScore(75);
                            }
                        }
                        for (let i = enemyBullets.length - 1; i >= 0; i--) {
                            const bullet = enemyBullets[i];
                            bullet.y += bullet.speed * delta;
                            if (bullet.y > api.height + 20) enemyBullets.splice(i, 1);
                            else if (Math.abs(bullet.x - player.x) < player.width / 2 && bullet.y > player.y - player.height / 2) {
                                enemyBullets.splice(i, 1);
                                loseLife();
                            }
                        }
                    };

                    const updateEnemies = delta => {
                        let aliveCount = 0;
                        enemies.forEach(enemy => {
                            if (enemy.state === 'die') return;
                            aliveCount += 1;
                            if (enemy.state === 'formation') {
                                enemy.phase += delta * 1.5;
                                enemy.x = enemy.baseX + Math.sin(enemy.phase) * 40;
                                enemy.y = enemy.baseY + Math.cos(enemy.phase * 0.8) * 12;
                                enemy.diveTimer -= delta;
                                if (enemy.diveTimer <= 0) {
                                    enemy.state = 'dive';
                                    enemy.progress = 0;
                                    enemy.startX = enemy.x;
                                    enemy.startY = enemy.y;
                                    enemy.targetX = player.x;
                                    enemy.targetY = api.height - 40;
                                }
                            } else if (enemy.state === 'dive') {
                                enemy.progress += delta * (0.7 + level * 0.1);
                                const t = enemy.progress;
                                enemy.x = enemy.startX * (1 - t) * (1 - t) + 2 * (1 - t) * t * enemy.targetX + t * t * enemy.targetX;
                                enemy.y = enemy.startY * Math.pow(1 - t, 2) + 2 * (1 - t) * t * (enemy.startY + 60) + t * t * enemy.targetY;
                                if (Math.random() < 0.01) fireEnemy(enemy);
                                if (t >= 1) {
                                    enemy.state = 'return';
                                    enemy.progress = 0;
                                }
                            } else if (enemy.state === 'return') {
                                enemy.progress += delta;
                                enemy.x = enemy.targetX + Math.sin(enemy.progress * 6) * 80;
                                enemy.y -= delta * 120;
                                if (enemy.y <= enemy.baseY) {
                                    enemy.state = 'formation';
                                    enemy.diveTimer = 3 + Math.random() * 4;
                                    enemy.x = enemy.baseX;
                                    enemy.y = enemy.baseY;
                                }
                            }
                            if (Math.abs(enemy.x - player.x) < 28 && Math.abs(enemy.y - player.y) < 28) loseLife();
                        });
                        if (!aliveCount) {
                            level += 1;
                            api.log(`Wave ${level}`);
                            spawnFleet();
                        }
                    };

                    spawnFleet();

                    return {
                        init() {
                            api.resetMetrics();
                            lives = 3;
                            level = 1;
                            score = 0;
                            active = true;
                            spawnFleet();
                            api.setScore(0);
                            api.setLevel(level);
                            api.setLives(`Lives ${lives}`);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!active) return;
                            player.cooldown = Math.max(0, player.cooldown - delta);
                            const speed = 380;
                            if (keys.left) player.x -= speed * delta;
                            if (keys.right) player.x += speed * delta;
                            player.x = Math.max(40, Math.min(api.width - 40, player.x));
                            updateBullets(delta);
                            updateEnemies(delta);
                        },
                        render(ctx) {
                            ctx.fillStyle = '#03030f';
                            ctx.fillRect(0, 0, api.width, api.height);
                            ctx.fillStyle = '#ffeb3b';
                            ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
                            enemies.forEach(enemy => {
                                if (enemy.state === 'die') return;
                                ctx.fillStyle = enemy.color;
                                ctx.beginPath();
                                ctx.moveTo(enemy.x, enemy.y - 18);
                                ctx.lineTo(enemy.x - 18, enemy.y + 12);
                                ctx.lineTo(enemy.x + 18, enemy.y + 12);
                                ctx.closePath();
                                ctx.fill();
                            });
                            ctx.fillStyle = '#fff';
                            bullets.forEach(bullet => ctx.fillRect(bullet.x - 2, bullet.y - 12, 4, 12));
                            ctx.fillStyle = '#ff5252';
                            enemyBullets.forEach(bullet => ctx.fillRect(bullet.x - 2, bullet.y, 4, 12));
                        },
                        handleKeyDown(event) {
                            switch (event.key) {
                                case 'ArrowLeft':
                                case 'a':
                                    keys.left = true;
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    keys.right = true;
                                    return true;
                                case ' ':
                                    firePlayer();
                                    return true;
                                default:
                                    return false;
                            }
                        },
                        handleKeyUp(event) {
                            switch (event.key) {
                                case 'ArrowLeft':
                                case 'a':
                                    keys.left = false;
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    keys.right = false;
                                    return true;
                                default:
                                    return false;
                            }
                        }
                    };
                }
            });
        }

        function createAsteroidsApp() {
            return createCanvasGameApp({
                id: 'asteroids',
                name: 'Asteroid Belt',
                icon: '☄️',
                hint: 'Pilot through drifting debris',
                instructions: [
                    'Rotate with ← and →, thrust with ↑, fire blasters with Space.',
                    'Large asteroids break into smaller shards.',
                    'Avoid collisions to preserve hull integrity.'
                ],
                legend: [
                    { color: '#81d4fa', label: 'Ship' },
                    { color: '#ef9a9a', label: 'Asteroid' }
                ],
                createGame(api) {
                    const ship = {
                        x: api.width / 2,
                        y: api.height / 2,
                        vx: 0,
                        vy: 0,
                        angle: -Math.PI / 2,
                        thrust: false,
                        cooldown: 0
                    };
                    const bullets = [];
                    const asteroids = [];
                    let lives = 3;
                    let score = 0;
                    let level = 1;
                    let active = true;

                    const spawnAsteroids = count => {
                        asteroids.length = 0;
                        for (let i = 0; i < count; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 30 + Math.random() * 40 + level * 10;
                            asteroids.push({
                                x: Math.random() * api.width,
                                y: Math.random() * api.height,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                size: 3
                            });
                        }
                    };

                    const wrap = entity => {
                        if (entity.x < -50) entity.x = api.width + 50;
                        if (entity.x > api.width + 50) entity.x = -50;
                        if (entity.y < -50) entity.y = api.height + 50;
                        if (entity.y > api.height + 50) entity.y = -50;
                    };

                    const fire = () => {
                        if (ship.cooldown > 0 || !active) return;
                        bullets.push({
                            x: ship.x + Math.cos(ship.angle) * 16,
                            y: ship.y + Math.sin(ship.angle) * 16,
                            vx: Math.cos(ship.angle) * 420 + ship.vx,
                            vy: Math.sin(ship.angle) * 420 + ship.vy,
                            life: 1.4
                        });
                        ship.cooldown = 0.18;
                    };

                    const splitAsteroid = (asteroid, scoreBonus = true) => {
                        if (scoreBonus) {
                            const value = asteroid.size === 3 ? 50 : asteroid.size === 2 ? 100 : 150;
                            score += value;
                            api.addScore(value);
                        }
                        if (asteroid.size > 1) {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 60 + Math.random() * 60;
                                asteroids.push({
                                    x: asteroid.x,
                                    y: asteroid.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: asteroid.size - 1
                                });
                            }
                        }
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${Math.max(0, lives)}`);
                        if (lives < 0) {
                            active = false;
                            api.gameOver('Ship destroyed.');
                            return;
                        }
                        ship.x = api.width / 2;
                        ship.y = api.height / 2;
                        ship.vx = 0;
                        ship.vy = 0;
                    };

                    const updateShip = delta => {
                        ship.cooldown = Math.max(0, ship.cooldown - delta);
                        if (ship.thrust) {
                            ship.vx += Math.cos(ship.angle) * 220 * delta;
                            ship.vy += Math.sin(ship.angle) * 220 * delta;
                        }
                        ship.vx *= 0.992;
                        ship.vy *= 0.992;
                        ship.x += ship.vx * delta;
                        ship.y += ship.vy * delta;
                        wrap(ship);
                    };

                    const updateBullets = delta => {
                        for (let i = bullets.length - 1; i >= 0; i--) {
                            const bullet = bullets[i];
                            bullet.x += bullet.vx * delta;
                            bullet.y += bullet.vy * delta;
                            bullet.life -= delta;
                            if (bullet.life <= 0) {
                                bullets.splice(i, 1);
                                continue;
                            }
                            wrap(bullet);
                        }
                    };

                    const updateAsteroids = delta => {
                        asteroids.forEach(asteroid => {
                            asteroid.x += asteroid.vx * delta;
                            asteroid.y += asteroid.vy * delta;
                            wrap(asteroid);
                        });
                    };

                    const checkCollisions = () => {
                        for (let i = asteroids.length - 1; i >= 0; i--) {
                            const asteroid = asteroids[i];
                            const radius = asteroid.size * 16;
                            if (active && Math.hypot(asteroid.x - ship.x, asteroid.y - ship.y) < radius + 12) {
                                asteroids.splice(i, 1);
                                splitAsteroid(asteroid, false);
                                loseLife();
                                continue;
                            }
                            for (let j = bullets.length - 1; j >= 0; j--) {
                                const bullet = bullets[j];
                                if (Math.hypot(asteroid.x - bullet.x, asteroid.y - bullet.y) < radius) {
                                    bullets.splice(j, 1);
                                    asteroids.splice(i, 1);
                                    splitAsteroid(asteroid);
                                    break;
                                }
                            }
                        }
                        if (!asteroids.length && active) {
                            level += 1;
                            api.log(`Sector ${level}`);
                            spawnAsteroids(3 + level);
                        }
                    };

                    spawnAsteroids(4);

                    return {
                        init() {
                            api.resetMetrics();
                            score = 0;
                            level = 1;
                            lives = 3;
                            active = true;
                            bullets.length = 0;
                            spawnAsteroids(4);
                            api.setScore(0);
                            api.setLevel(level);
                            api.setLives(`Lives ${lives}`);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!active) return;
                            updateShip(delta);
                            updateBullets(delta);
                            updateAsteroids(delta);
                            checkCollisions();
                        },
                        render(ctx) {
                            ctx.fillStyle = '#050812';
                            ctx.fillRect(0, 0, api.width, api.height);
                            ctx.save();
                            ctx.translate(ship.x, ship.y);
                            ctx.rotate(ship.angle);
                            ctx.strokeStyle = '#81d4fa';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(20, 0);
                            ctx.lineTo(-14, -12);
                            ctx.lineTo(-6, 0);
                            ctx.lineTo(-14, 12);
                            ctx.closePath();
                            ctx.stroke();
                            if (ship.thrust) {
                                ctx.beginPath();
                                ctx.moveTo(-14, -6);
                                ctx.lineTo(-24, 0);
                                ctx.lineTo(-14, 6);
                                ctx.stroke();
                            }
                            ctx.restore();
                            ctx.fillStyle = '#fff';
                            bullets.forEach(bullet => {
                                ctx.beginPath();
                                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            });
                            ctx.strokeStyle = '#ef9a9a';
                            asteroids.forEach(asteroid => {
                                ctx.beginPath();
                                const radius = asteroid.size * 16;
                                ctx.arc(asteroid.x, asteroid.y, radius, 0, Math.PI * 2);
                                ctx.stroke();
                            });
                        },
                        handleKeyDown(event) {
                            switch (event.key.toLowerCase()) {
                                case 'arrowleft':
                                case 'a':
                                    ship.angle -= Math.PI / 36;
                                    return true;
                                case 'arrowright':
                                case 'd':
                                    ship.angle += Math.PI / 36;
                                    return true;
                                case 'arrowup':
                                case 'w':
                                    ship.thrust = true;
                                    return true;
                                case ' ':
                                    fire();
                                    return true;
                                default:
                                    return false;
                            }
                        },
                        handleKeyUp(event) {
                            if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') {
                                ship.thrust = false;
                                return true;
                            }
                            return false;
                        }
                    };
                }
            });
        }

        function createFroggerApp() {
            return createCanvasGameApp({
                id: 'frogger',
                name: 'Pixel Frogger',
                icon: '🐸',
                hint: 'Cross roads and rivers safely',
                instructions: [
                    'Use the arrow keys to hop one tile at a time.',
                    'Avoid cars on the roadway and ride logs across the water.',
                    'Reach the top to score bonus points.'
                ],
                legend: [
                    { color: '#4caf50', label: 'Frog' },
                    { color: '#ff5722', label: 'Traffic' },
                    { color: '#90caf9', label: 'Logs' }
                ],
                createGame(api) {
                    const cols = 13;
                    const rows = 13;
                    const tile = Math.floor(Math.min(api.width / cols, api.height / rows));
                    const offsetX = Math.floor((api.width - tile * cols) / 2);
                    const offsetY = Math.floor((api.height - tile * rows) / 2);

                    const frog = { row: rows - 1, col: Math.floor(cols / 2), safe: true };
                    let lives = 3;
                    let score = 0;
                    let level = 1;
                    let active = true;

                    const lanes = [
                        { type: 'goal' },
                        { type: 'river', speed: 1.5, dir: 1, segments: [] },
                        { type: 'river', speed: 2.1, dir: -1, segments: [] },
                        { type: 'river', speed: 1.7, dir: 1, segments: [] },
                        { type: 'river', speed: 2.5, dir: -1, segments: [] },
                        { type: 'safe' },
                        { type: 'road', speed: 2.2, dir: -1, segments: [] },
                        { type: 'road', speed: 1.8, dir: 1, segments: [] },
                        { type: 'road', speed: 2.6, dir: -1, segments: [] },
                        { type: 'road', speed: 2.1, dir: 1, segments: [] },
                        { type: 'safe' },
                        { type: 'safe' },
                        { type: 'safe' }
                    ];

                    const resetLanes = () => {
                        lanes.forEach((lane, index) => {
                            if (lane.type === 'road' || lane.type === 'river') {
                                lane.segments = [];
                                const count = lane.type === 'road' ? 4 : 3;
                                for (let i = 0; i < count; i++) {
                                    lane.segments.push({
                                        x: Math.random() * cols,
                                        length: lane.type === 'road' ? 1.6 : 2.5
                                    });
                                }
                            }
                        });
                    };

                    const resetFrog = () => {
                        frog.row = rows - 1;
                        frog.col = Math.floor(cols / 2);
                        frog.safe = true;
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Lives ${Math.max(0, lives)}`);
                        if (lives < 0) {
                            active = false;
                            api.gameOver('Frogger failed to cross.');
                            return;
                        }
                        resetFrog();
                    };

                    const moveSegments = delta => {
                        lanes.forEach((lane, laneIndex) => {
                            if (lane.type !== 'road' && lane.type !== 'river') return;
                            const speed = lane.speed + level * 0.2;
                            lane.segments.forEach(segment => {
                                segment.x += lane.dir * speed * delta;
                                if (segment.x < -4) segment.x = cols + 2;
                                if (segment.x > cols + 4) segment.x = -2;
                            });
                            if (lane.type === 'river' && frog.row === laneIndex) {
                                frog.col += lane.dir * speed * delta;
                            }
                        });
                    };

                    const checkHazards = () => {
                        const lane = lanes[frog.row];
                        if (!lane || lane.type === 'safe' || lane.type === 'goal') return;
                        const onSegment = lane.segments.some(segment => frog.col >= segment.x && frog.col <= segment.x + segment.length);
                        if (lane.type === 'road' && onSegment) {
                            loseLife();
                        }
                        if (lane.type === 'river' && !onSegment) {
                            loseLife();
                        }
                    };

                    const clampFrog = () => {
                        frog.col = Math.max(0, Math.min(cols - 1, frog.col));
                    };

                    const hop = (dr, dc) => {
                        if (!active) return;
                        frog.row = Math.max(0, Math.min(rows - 1, frog.row + dr));
                        frog.col += dc;
                        clampFrog();
                        frog.safe = lanes[frog.row]?.type !== 'river';
                        if (frog.row === 0) {
                            score += 100;
                            api.addScore(100);
                            api.log('Reached safety!');
                            level += 1;
                            resetFrog();
                        }
                    };

                    resetLanes();

                    return {
                        init() {
                            api.resetMetrics();
                            lives = 3;
                            level = 1;
                            score = 0;
                            active = true;
                            resetLanes();
                            resetFrog();
                            api.setScore(0);
                            api.setLives(`Lives ${lives}`);
                            api.setLevel(level);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!active) return;
                            moveSegments(delta);
                            clampFrog();
                            if (frog.col < 0 || frog.col >= cols) loseLife();
                            checkHazards();
                        },
                        render(ctx) {
                            ctx.fillStyle = '#263238';
                            ctx.fillRect(0, 0, api.width, api.height);
                            lanes.forEach((lane, index) => {
                                const y = offsetY + index * tile;
                                if (lane.type === 'road') {
                                    ctx.fillStyle = '#424242';
                                    ctx.fillRect(offsetX, y, tile * cols, tile);
                                } else if (lane.type === 'river') {
                                    ctx.fillStyle = '#1976d2';
                                    ctx.fillRect(offsetX, y, tile * cols, tile);
                                } else if (lane.type === 'goal' || lane.type === 'safe') {
                                    ctx.fillStyle = '#2e7d32';
                                    ctx.fillRect(offsetX, y, tile * cols, tile);
                                }
                                if (lane.type === 'road' || lane.type === 'river') {
                                    ctx.fillStyle = lane.type === 'road' ? '#ff5722' : '#90caf9';
                                    lane.segments.forEach(segment => {
                                        ctx.fillRect(offsetX + segment.x * tile, y + tile * 0.1, tile * segment.length, tile * 0.8);
                                    });
                                }
                            });
                            ctx.fillStyle = '#4caf50';
                            ctx.fillRect(offsetX + frog.col * tile + tile * 0.2, offsetY + frog.row * tile + tile * 0.2, tile * 0.6, tile * 0.6);
                        },
                        handleKeyDown(event) {
                            switch (event.key) {
                                case 'ArrowUp':
                                case 'w':
                                    hop(-1, 0);
                                    return true;
                                case 'ArrowDown':
                                case 's':
                                    hop(1, 0);
                                    return true;
                                case 'ArrowLeft':
                                case 'a':
                                    hop(0, -1);
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    hop(0, 1);
                                    return true;
                                default:
                                    return false;
                            }
                        }
                    };
                }
            });
        }

        function createPinballApp() {
            return createCanvasGameApp({
                id: 'pinball',
                name: 'Neon Pinball',
                icon: '🎰',
                hint: 'Keep the ball alive with flippers',
                instructions: [
                    'Fire the ball with Space. Use ← and → to trigger the left/right flippers.',
                    'Hit glowing bumpers to rack up points.',
                    'Don’t let the ball fall through the drain!' ],
                createGame(api) {
                    const ball = { x: api.width / 2, y: api.height * 0.2, vx: 0, vy: 0, radius: 12, active: false };
                    const gravity = 620;
                    const flippers = {
                        left: { x: api.width * 0.35, y: api.height - 90, angle: 0, active: false },
                        right: { x: api.width * 0.65, y: api.height - 90, angle: 0, active: false }
                    };
                    const bumpers = [
                        { x: api.width * 0.3, y: api.height * 0.35, radius: 26 },
                        { x: api.width * 0.5, y: api.height * 0.28, radius: 30 },
                        { x: api.width * 0.7, y: api.height * 0.4, radius: 26 }
                    ];
                    let lives = 3;
                    let score = 0;
                    let active = true;

                    const resetBall = () => {
                        ball.x = api.width * 0.82;
                        ball.y = api.height * 0.1;
                        ball.vx = 0;
                        ball.vy = 0;
                        ball.active = false;
                    };

                    const launchBall = () => {
                        if (ball.active || !active) return;
                        ball.vy = 0;
                        ball.vx = -120;
                        ball.active = true;
                    };

                    const loseLife = () => {
                        lives -= 1;
                        api.setLives(`Balls ${Math.max(0, lives)}`);
                        resetBall();
                        if (lives < 0) {
                            active = false;
                            api.gameOver('Game over — insert coin.');
                        }
                    };

                    const updateBall = delta => {
                        if (!ball.active) return;
                        ball.vy += gravity * delta;
                        ball.x += ball.vx * delta;
                        ball.y += ball.vy * delta;

                        if (ball.x < ball.radius) {
                            ball.x = ball.radius;
                            ball.vx *= -0.85;
                        } else if (ball.x > api.width - ball.radius) {
                            ball.x = api.width - ball.radius;
                            ball.vx *= -0.85;
                        }
                        if (ball.y < ball.radius + 40) {
                            ball.y = ball.radius + 40;
                            ball.vy *= -0.9;
                        }
                        if (ball.y > api.height + 40) loseLife();
                    };

                    const handleFlippers = delta => {
                        const power = 420;
                        ['left', 'right'].forEach(side => {
                            const flipper = flippers[side];
                            if (flipper.active) {
                                flipper.angle = Math.min(0.5, flipper.angle + delta * 12);
                                if (Math.abs(ball.x - flipper.x) < 80 && ball.y > flipper.y - 20 && ball.y < flipper.y + 20) {
                                    const direction = side === 'left' ? -1 : 1;
                                    ball.vx += direction * power * 0.5;
                                    ball.vy = -power;
                                    score += 5;
                                }
                            } else {
                                flipper.angle = Math.max(-0.35, flipper.angle - delta * 12);
                            }
                        });
                    };

                    const handleBumpers = () => {
                        bumpers.forEach(bumper => {
                            const dx = ball.x - bumper.x;
                            const dy = ball.y - bumper.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist < ball.radius + bumper.radius) {
                                const normalX = dx / dist;
                                const normalY = dy / dist;
                                const dot = ball.vx * normalX + ball.vy * normalY;
                                ball.vx -= 2 * dot * normalX;
                                ball.vy -= 2 * dot * normalY;
                                ball.x = bumper.x + normalX * (ball.radius + bumper.radius + 1);
                                ball.y = bumper.y + normalY * (ball.radius + bumper.radius + 1);
                                score += 25;
                                api.addScore(25);
                            }
                        });
                    };

                    resetBall();

                    return {
                        init() {
                            api.resetMetrics();
                            lives = 3;
                            score = 0;
                            active = true;
                            resetBall();
                            api.setScore(0);
                            api.setLives(`Balls ${lives}`);
                            api.setLevel(1);
                        },
                        start() {
                            api.setStatus('Running');
                        },
                        update(delta) {
                            if (!active) return;
                            updateBall(delta);
                            handleFlippers(delta);
                            handleBumpers();
                        },
                        render(ctx) {
                            ctx.fillStyle = '#101325';
                            ctx.fillRect(0, 0, api.width, api.height);
                            ctx.strokeStyle = '#607d8b';
                            ctx.lineWidth = 6;
                            ctx.strokeRect(20, 20, api.width - 40, api.height - 40);
                            ctx.fillStyle = '#263238';
                            ctx.fillRect(api.width * 0.75, 20, api.width * 0.2, api.height - 40);
                            ctx.fillStyle = '#ffab40';
                            bumpers.forEach(bumper => {
                                ctx.beginPath();
                                ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                                ctx.fill();
                            });
                            ctx.fillStyle = '#fff';
                            ctx.beginPath();
                            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#8bc34a';
                            ctx.lineWidth = 8;
                            ['left', 'right'].forEach(side => {
                                const flipper = flippers[side];
                                ctx.save();
                                ctx.translate(flipper.x, flipper.y);
                                ctx.rotate(flipper.angle * (side === 'left' ? 1 : -1));
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(side === 'left' ? -70 : 70, 0);
                                ctx.stroke();
                                ctx.restore();
                            });
                        },
                        handleKeyDown(event) {
                            switch (event.key) {
                                case 'ArrowLeft':
                                case 'a':
                                    flippers.left.active = true;
                                    return true;
                                case 'ArrowRight':
                                case 'd':
                                    flippers.right.active = true;
                                    return true;
                                case ' ':
                                    launchBall();
                                    return true;
                                default:
                                    return false;
                            }
                        },
                        handleKeyUp(event) {
                            if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') {
                                flippers.left.active = false;
                                return true;
                            }
                            if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') {
                                flippers.right.active = false;
                                return true;
                            }
                            return false;
                        }
                    };
                }
            });
        }

        function createSettingsApp(fileSystem, settings, notifications, desktopManager, appManager, modals, permissionManager) {
            return {
                id: 'settings',
                name: 'System Settings',
                icon: '⚙️',
                launch() {
                    const container = utils.createEl('div', 'settings');
                    const nav = utils.createEl('div', 'settings-nav');
                    const content = utils.createEl('div', 'settings-content');
                    container.append(nav, content);

                    const sections = [
                        { id: 'appearance', label: 'Appearance' },
                        { id: 'desktop', label: 'Desktop' },
                        { id: 'system', label: 'System' },
                        { id: 'storage', label: 'Storage' },
                        { id: 'about', label: 'About' }
                    ];

                    function renderSection(id) {
                        content.innerHTML = '';
                        if (id === 'appearance') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Theme</h3>
                                <div class="settings-row">
                                    <label>Theme mode</label>
                                    <select id="theme-mode">
                                        <option value="dark">Dark</option>
                                        <option value="light">Light</option>
                                        <option value="auto">Auto</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Accent color</label>
                                    <input type="color" id="accent-color" />
                                </div>
                                <div class="settings-row">
                                    <label>Font scale</label>
                                    <input type="range" id="font-scale" min="0.8" max="1.4" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label>Wallpaper</label>
                                    <select id="wallpaper-style">
                                        <option value="aurora">Aurora</option>
                                        <option value="nebula">Nebula</option>
                                        <option value="sunset">Sunset</option>
                                        <option value="minimal">Minimal</option>
                                        <option value="galaxy">Galaxy</option>
                                        <option value="custom">Custom</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Custom wallpaper</label>
                                    <div class="settings-controls">
                                        <button id="wallpaper-upload">Upload image</button>
                                        <button id="wallpaper-reset">Reset to theme</button>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <label>Blur intensity</label>
                                    <input type="range" id="wallpaper-blur" min="0" max="30" step="1" />
                                </div>
                                <div class="settings-row">
                                    <label>Brightness</label>
                                    <input type="range" id="wallpaper-brightness" min="0.5" max="1.5" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label>Transparency</label>
                                    <input type="range" id="wallpaper-opacity" min="0.3" max="1" step="0.05" />
                                </div>
                                <div class="settings-row">
                                    <label><input type="checkbox" id="show-seconds"> Show seconds in clock</label>
                                </div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#theme-mode').value = settings.state.theme;
                            section.querySelector('#accent-color').value = settings.state.accent;
                            section.querySelector('#font-scale').value = settings.state.fontScale;
                            section.querySelector('#wallpaper-style').value = settings.state.wallpaper;
                            section.querySelector('#show-seconds').checked = settings.state.showSeconds;

                            const wallpaperSelect = section.querySelector('#wallpaper-style');
                            const uploadBtn = section.querySelector('#wallpaper-upload');
                            const resetBtn = section.querySelector('#wallpaper-reset');
                            const blurInput = section.querySelector('#wallpaper-blur');
                            const brightnessInput = section.querySelector('#wallpaper-brightness');
                            const opacityInput = section.querySelector('#wallpaper-opacity');

                            blurInput.value = settings.state.wallpaperBlur ?? 0;
                            brightnessInput.value = settings.state.wallpaperBrightness ?? 1;
                            opacityInput.value = settings.state.wallpaperOpacity ?? 1;

                            section.querySelector('#theme-mode').addEventListener('change', event => settings.update({ theme: event.target.value }));
                            section.querySelector('#accent-color').addEventListener('input', event => settings.update({ accent: event.target.value }));
                            section.querySelector('#font-scale').addEventListener('input', event => settings.update({ fontScale: Number(event.target.value) }));
                            section.querySelector('#show-seconds').addEventListener('change', event => settings.update({ showSeconds: event.target.checked }));

                            wallpaperSelect.addEventListener('change', event => {
                                const value = event.target.value;
                                if (value === 'custom') {
                                    if (!settings.state.wallpaperCustom) {
                                        uploadBtn.click();
                                    } else {
                                        settings.update({ wallpaper: 'custom' });
                                    }
                                } else {
                                    settings.update({ wallpaper: value });
                                }
                            });

                            uploadBtn.addEventListener('click', event => {
                                event.preventDefault();
                                const picker = document.createElement('input');
                                picker.type = 'file';
                                picker.accept = 'image/*';
                                picker.onchange = () => {
                                    const file = picker.files?.[0];
                                    if (!file) return;
                                    const reader = new FileReader();
                                    reader.onload = () => {
                                        settings.update({ wallpaper: 'custom', wallpaperCustom: reader.result });
                                        wallpaperSelect.value = 'custom';
                                    };
                                    reader.readAsDataURL(file);
                                };
                                picker.click();
                            });

                            resetBtn.addEventListener('click', event => {
                                event.preventDefault();
                                settings.update({ wallpaper: 'aurora', wallpaperCustom: null });
                                wallpaperSelect.value = 'aurora';
                            });

                            blurInput.addEventListener('input', event => settings.update({ wallpaperBlur: Number(event.target.value) }));
                            brightnessInput.addEventListener('input', event => settings.update({ wallpaperBrightness: Number(event.target.value) }));
                            opacityInput.addEventListener('input', event => settings.update({ wallpaperOpacity: Number(event.target.value) }));
                        } else if (id === 'desktop') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Desktop Layout</h3>
                                <div class="settings-row">
                                    <label>Taskbar position</label>
                                    <select id="taskbar-position">
                                        <option value="bottom">Bottom</option>
                                        <option value="top">Top</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label>Icon density</label>Performance & Optimization
Code Splitting: Break monolithic HTML into modules
Bundle Optimization: Minify and compress assets
Tree Shaking: Remove unused code
Asset Compression: Compress images, audio, fonts
Lazy Loading: Implement progressive loading for apps
Web Workers: Offload heavy computations
IndexedDB: Replace localStorage for larger datasets
Memory Management: Implement garbage collection for closed apps
Caching Strategy: Implement intelligent cache invalidation
Performance & Optimization
Code Splitting: Break monolithic HTML into modules
Bundle Optimization: Minify and compress assets
Tree Shaking: Remove unused code
Asset Compression: Compress images, audio, fonts
Lazy Loading: Implement progressive loading for apps
Web Workers: Offload heavy computations
IndexedDB: Replace localStorage for larger datasets
Memory Management: Implement garbage collection for closed apps
Caching Strategy: Implement intelligent cache invalidation

                                        <option value="compact">Compact</option>
                                        <option value="comfortable">Comfortable</option>
                                        <option value="spacious">Spacious</option>
                                    </select>
                                </div>
                                <div class="settings-row">
                                    <label><input type="checkbox" id="particles-toggle"> Animated background particles</label>
                                </div>
                                <div class="settings-row">
                                    <button id="open-desktop-folder">Open desktop folder</button>
                                </div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#taskbar-position').value = settings.state.taskbarPosition;
                            section.querySelector('#desktop-density').value = settings.state.desktopDensity;
                            section.querySelector('#particles-toggle').checked = settings.state.showParticles;
                            section.querySelector('#taskbar-position').addEventListener('change', event => settings.update({ taskbarPosition: event.target.value }));
                            section.querySelector('#desktop-density').addEventListener('change', event => settings.update({ desktopDensity: event.target.value }));
                            section.querySelector('#particles-toggle').addEventListener('change', event => settings.update({ showParticles: event.target.checked }));
                            section.querySelector('#open-desktop-folder').addEventListener('click', () => appManager.open('toastsearcher', { path: '/Desktop' }));
                        } else if (id === 'system') {
                            const section = utils.createEl('div', 'settings-section');
                            section.innerHTML = `
                                <h3>Preferences</h3>
                                <div class="settings-row"><label><input type="checkbox" id="notifications-toggle"> Enable notifications</label></div>
                                <div class="settings-row"><label><input type="checkbox" id="autosave-toggle"> Auto-save documents</label></div>
                                <div class="settings-row"><label><input type="checkbox" id="proxy-toggle"> Use compatibility proxy in browser</label></div>
                                <div class="settings-row"><button id="reset-files">Reset file system</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#notifications-toggle').checked = settings.state.notifications;
                            section.querySelector('#autosave-toggle').checked = settings.state.autoSave;
                            section.querySelector('#proxy-toggle').checked = settings.state.useBrowserProxy !== false;
                            section.querySelector('#notifications-toggle').addEventListener('change', event => settings.update({ notifications: event.target.checked }));
                            section.querySelector('#autosave-toggle').addEventListener('change', event => settings.update({ autoSave: event.target.checked }));
                            section.querySelector('#proxy-toggle').addEventListener('change', event => settings.update({ useBrowserProxy: event.target.checked }));
                            section.querySelector('#reset-files').addEventListener('click', () => {
                                if (!confirm('Reset file system to defaults? This will erase your data.')) return;
                                localStorage.removeItem(STORAGE_KEYS.FILE_SYSTEM);
                                fileSystem.load();
                                desktopManager.render();
                                notifications.notify('File system', 'Restored to defaults');
                            });
                        } else if (id === 'storage') {
                            const section = utils.createEl('div', 'settings-section');
                            const fsData = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM) || '[]';
                            const approxBytes = new TextEncoder().encode(fsData).length;
                            section.innerHTML = `
                                <h3>Storage</h3>
                                <p>Export or import your WebOS virtual file system.</p>
                                <div class="settings-row"><span>Approximate size: ${(approxBytes / 1024).toFixed(1)} KB</span></div>
                                <div class="settings-row"><button id="export-fs">Export file system</button></div>
                                <div class="settings-row"><button id="import-fs">Import file system</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#export-fs').addEventListener('click', () => {
                                const data = localStorage.getItem(STORAGE_KEYS.FILE_SYSTEM);
                                const blob = new Blob([data], { type: 'application/json' });
                                const url = URL.createObjectURL(blob);
                                const anchor = document.createElement('a');
                                anchor.href = url;
                                anchor.download = 'webos-filesystem.json';
                                anchor.click();
                                URL.revokeObjectURL(url);
                            });
                            section.querySelector('#import-fs').addEventListener('click', () => {
                                const picker = document.createElement('input');
                                picker.type = 'file';
                                picker.accept = 'application/json';
                                picker.onchange = async () => {
                                    const file = picker.files[0];
                                    const text = await file.text();
                                    localStorage.setItem(STORAGE_KEYS.FILE_SYSTEM, text);
                                    fileSystem.load();
                                    desktopManager.render();
                                    notifications.notify('Storage', 'File system imported');
                                    renderSection('storage');
                                };
                                picker.click();
                            });
                        } else if (id === 'about') {
                            const section = utils.createEl('div', 'settings-section');
                            const stats = { files: 0, folders: 0 };
                            const scan = (entry) => {
                                if (!entry) return;
                                if (entry.type === 'directory') {
                                    if (entry !== fileSystem.root) stats.folders += 1;
                                    Object.values(entry.children || {}).forEach(scan);
                                } else if (entry.type === 'file') {
                                    stats.files += 1;
                                }
                            };
                            scan(fileSystem.root);
                            section.innerHTML = `
                                <h3>About WebOS</h3>
                                <p>Version 1.0 · Browser-based operating system.</p>
                                <div class="settings-row"><span>Creator: Jared Sanford (Slighty.Toasted)</span></div>
                                <div class="settings-row"><span>Total files: ${stats.files}</span></div>
                                <div class="settings-row"><span>Total folders: ${stats.folders}</span></div>
                                <div class="settings-row"><button id="view-shortcuts">View keyboard shortcuts</button></div>
                                <div class="settings-row"><button id="support-link">Visit support page</button></div>
                            `;
                            content.appendChild(section);
                            section.querySelector('#view-shortcuts').addEventListener('click', () => {
                                modals.open({
                                    title: 'Keyboard Shortcuts',
                                    body: `<ul style="padding-left:18px; line-height:1.6;">
                                        <li><strong>Alt + Tab</strong> — Cycle windows</li>
                                        <li><strong>Ctrl/⌘ + Shift + N</strong> — New editor window</li>
                                        <li><strong>Ctrl/⌘ + Shift + D</strong> — Show desktop</li>
                                        <li><strong>F11</strong> — Toggle fullscreen</li>
                                    </ul>`,
                                    actions: [{ label: 'Close', primary: true }]
                                });
                            });
                            section.querySelector('#support-link').addEventListener('click', () => window.open('https://cascade.cool', '_blank', 'noopener'));
                        }
                    }

                    sections.forEach((section, index) => {
                        const button = utils.createEl('button', index === 0 ? 'active' : '', { text: section.label });
                        button.addEventListener('click', () => {
                            nav.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            renderSection(section.id);
                        });
                        nav.appendChild(button);
                    });

                    nav.querySelector('button').classList.add('active');
                    renderSection(sections[0].id);

                    return {
                        element: container,
                        width: '720px',
                        height: '560px'
                    };
                }
            };
        }
        function startBackgroundAnimation(canvas) {
            const ctx = canvas.getContext('2d');
            let enabled = true;
            let mode = document.body.dataset.wallpaper || 'aurora';
            let particles = [];
            let pixelRatio = window.devicePixelRatio || 1;

            const resize = () => {
                pixelRatio = window.devicePixelRatio || 1;
                canvas.width = Math.floor(window.innerWidth * pixelRatio);
                canvas.height = Math.floor(window.innerHeight * pixelRatio);
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight}px`;
                ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                spawnParticles();
            };

            const createAmbientParticle = () => ({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                radius: Math.random() * 1.6 + 0.5,
                speedX: (Math.random() - 0.5) * 0.25,
                speedY: (Math.random() - 0.5) * 0.25,
                hue: 200 + Math.random() * 80,
                alpha: 0.35 + Math.random() * 0.3
            });

            const createGalaxyParticle = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const maxDistance = Math.min(width, height) * 0.55;
                const distance = (Math.random() ** 0.35) * maxDistance * (0.4 + Math.random() * 0.6);
                const spiral = distance / maxDistance * 1.45;
                const base = Math.random() * Math.PI * 2;
                const arm = Math.random() < 0.5 ? 1 : -1;
                return {
                    distance,
                    angle: base + spiral * arm,
                    speed: 0.0008 + (1 - distance / maxDistance) * 0.0018,
                    size: 1.2 + Math.random() * 1.6,
                    eccentricity: 0.55 + Math.random() * 0.35,
                    hue: 200 + Math.random() * 160,
                    twinkle: Math.random() * Math.PI * 2,
                    drift: (Math.random() - 0.5) * 0.0005
                };
            };

            const spawnParticles = () => {
                if (mode === 'galaxy') {
                    particles = Array.from({ length: 240 }, createGalaxyParticle);
                } else {
                    particles = Array.from({ length: 140 }, createAmbientParticle);
                }
            };

            const drawAmbient = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                particles.forEach(particle => {
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    if (particle.x < -80) particle.x = width + 80;
                    if (particle.x > width + 80) particle.x = -80;
                    if (particle.y < -80) particle.y = height + 80;
                    if (particle.y > height + 80) particle.y = -80;
                    const gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.radius * 32);
                    gradient.addColorStop(0, `hsla(${particle.hue}, 80%, 70%, ${particle.alpha})`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius * 32, 0, Math.PI * 2);
                    ctx.fill();
                });
            };

            const drawGalaxy = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const cx = width / 2;
                const cy = height / 2;
                particles.forEach(particle => {
                    particle.angle += particle.speed;
                    particle.angle += particle.drift;
                    particle.twinkle += 0.02;
                    const wobble = 1 + Math.sin(particle.twinkle) * 0.03;
                    const x = cx + Math.cos(particle.angle) * particle.distance * wobble;
                    const y = cy + Math.sin(particle.angle) * particle.distance * particle.eccentricity * wobble;
                    const radius = particle.size * (1 + Math.sin(particle.twinkle) * 0.3);
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 18);
                    gradient.addColorStop(0, `hsla(${particle.hue}, 100%, 82%, 0.7)`);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 18, 0, Math.PI * 2);
                    ctx.fill();
                });
            };

            const draw = () => {
                if (!enabled) {
                    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                    requestAnimationFrame(draw);
                    return;
                }
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                if (mode === 'galaxy') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    drawGalaxy();
                    ctx.restore();
                } else {
                    drawAmbient();
                }
                requestAnimationFrame(draw);
            };

            resize();
            window.addEventListener('resize', utils.debounce(resize, 120));
            draw();

            return {
                setEnabled(value) {
                    enabled = Boolean(value);
                    if (!enabled) {
                        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                    } else {
                        spawnParticles();
                    }
                },
                setMode(nextMode) {
                    mode = nextMode || 'aurora';
                    spawnParticles();
                }
            };
        }

        function updateClock(settings) {
            const clockEl = document.getElementById('tray-clock');
            const tick = () => {
                const options = settings.state.showSeconds ? { hour: '2-digit', minute: '2-digit', second: '2-digit' } : { hour: '2-digit', minute: '2-digit' };
                clockEl.textContent = new Date().toLocaleTimeString([], options);
            };
            tick();
            setInterval(tick, 1000);
        }

        function registerPWA() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js').catch(() => {});
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('desktop-bg');
            const settings = new SettingsManager();
            const particles = startBackgroundAnimation(canvas);
            settings.setBackgroundController(particles);

            const updateViewportHeight = () => {
                document.documentElement.style.setProperty('--viewport-h', `${window.innerHeight}px`);
            };
            updateViewportHeight();
            window.addEventListener('resize', utils.throttle(updateViewportHeight, 150));
            window.addEventListener('orientationchange', utils.throttle(updateViewportHeight, 150));

            const pointerModeQuery = typeof window.matchMedia === 'function' ? window.matchMedia('(pointer: coarse)') : null;
            const applyInputMode = () => {
                document.body.dataset.input = pointerModeQuery?.matches ? 'touch' : 'mouse';
            };
            applyInputMode();
            if (pointerModeQuery) {
                if (typeof pointerModeQuery.addEventListener === 'function') pointerModeQuery.addEventListener('change', applyInputMode);
                else if (typeof pointerModeQuery.addListener === 'function') pointerModeQuery.addListener(applyInputMode);
            }

            const notifications = new NotificationCenter(settings);
            const modals = new ModalManager();
            const fileSystem = new FileSystem();
            const windowManager = new WindowManager();
            const categoryManager = new AppCategoryManager(APP_CATALOG);
            const permissionManager = new PermissionManager(settings, modals, notifications);
            settings.setPermissionManager(permissionManager);
            const appManager = new AppManager(windowManager, fileSystem, notifications, settings, modals, categoryManager, permissionManager);
            const desktopManager = new DesktopManager(fileSystem, appManager, notifications);
            const dockManager = new DockManager(appManager, windowManager, notifications, settings, categoryManager);
            desktopManager.setDockManager(dockManager);
            appManager.setDockManager(dockManager);

            const registerApp = (id, loader, options) => appManager.register(id, loader, options);

            registerApp('tasks', () => createTasksApp());
            registerApp('toastsearcher', () => createToastSearcherApp(desktopManager));
            registerApp('file-manager', () => createFileManagerApp(desktopManager));
            registerApp('calendar', () => createCalendarApp());
            registerApp('email', () => createEmailClientApp());
            registerApp('chat', () => createChatApp());
            registerApp('code-editor', () => createCodeEditorApp());
            registerApp('paint', () => createPaintApp());
            registerApp('spreadsheet', () => createSpreadsheetApp());
            registerApp('database', () => createDatabaseApp());
            registerApp('cloud-sync', () => createCloudSyncApp());
            registerApp('screen-recorder', () => createScreenRecorderApp(), { unloadOnClose: true });
            registerApp('screenshot-tool', () => createScreenshotToolApp());
            registerApp('package-manager', () => createPackageManagerApp());
            registerApp('app-store', () => createAppStoreApp());
            registerApp('text-editor', () => createTextEditorApp());
            registerApp('notes', () => createNotesApp());
            registerApp('calculator', () => createCalculatorApp());
            registerApp('terminal', () => createTerminalApp(desktopManager));
            registerApp('browser', () => createBrowserApp());
            registerApp('media-player', () => createMediaPlayerApp());
            registerApp('image-viewer', () => createImageViewerApp());
            registerApp('assistant', () => createAssistantApp());
            registerApp('system-monitor', () => createSystemMonitorApp());
            registerApp('settings', () => createSettingsApp(fileSystem, settings, notifications, desktopManager, appManager, modals));

            GAME_APP_IDS.forEach(id => {
                const loaders = {
                    'tetris': () => createTetrisApp(),
                    'snake': () => createSnakeApp(),
                    'pong': () => createPongApp(),
                    'breakout': () => createBreakoutApp(),
                    'minesweeper': () => createMinesweeperApp(),
                    'solitaire': () => createSolitaireApp(),
                    'flappy-bird': () => createFlappyBirdApp(),
                    'game-2048': () => create2048App(),
                    'pac-man': () => createPacManApp(),
                    'space-invaders': () => createSpaceInvadersApp(),
                    'galaga': () => createGalagaApp(),
                    'asteroids': () => createAsteroidsApp(),
                    'frogger': () => createFroggerApp(),
                    'pinball': () => createPinballApp()
                };
                const loader = loaders[id];
                if (loader) registerApp(id, loader, { unloadOnClose: true });
            });

            WEB_PORTAL_APPS.forEach(shortcut => registerApp(shortcut.id, () => createWebShortcutApp(shortcut)));

            GAME_APP_IDS.forEach(id => {
                const assigned = categoryManager.getCategoryForApp(id);
                if (!assigned || assigned === 'uncategorized') {
                    categoryManager.assignApp(id, 'games');
                }
            });

            const startMenu = new StartMenu({ appManager, categoryManager, dockManager, notifications, modals });

            const shortcuts = new ShortcutManager(windowManager, appManager, settings);
            const menuManager = new MenuManager({ desktopManager, windowManager, appManager, settings, notifications, modals, fileSystem, startMenu });
            document.querySelectorAll('#menu-items [data-menu]').forEach(button => menuManager.attach(button, button.dataset.menu));
            menuManager.attach(document.getElementById('menu-apple'), 'finder');

            document.getElementById('theme-toggle').addEventListener('click', () => {
                const next = settings.state.theme === 'dark' ? 'light' : settings.state.theme === 'light' ? 'auto' : 'dark';
                settings.update({ theme: next });
                notifications.notify('Theme', `Theme switched to ${next}`);
            });

            document.getElementById('notification-button').addEventListener('click', () => {
                notifications.notify('Notifications', 'This is a sample notification.');
            });

            settings.on('change', () => desktopManager.render());

            startMenu.setDockManager(dockManager);

            windowManager.on('focus', state => startMenu.handleExternalFocus(state));

            updateClock(settings);
            registerPWA();
            notifications.notify('Welcome to WebOS', 'All core services initialized.');

            window.webOS = { fileSystem, settings, notifications, windowManager, appManager, desktopManager, menuManager, dockManager, categoryManager, permissionManager, startMenu };
        });
    })();
    </script>
</body>
</html>
